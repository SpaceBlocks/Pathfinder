{"version":3,"sources":["view/navbar/TopBar.tsx","view/navbar/Buttons.tsx","view/navbar/DropDown.tsx","view/elements/DraggablePanel.tsx","view/grid/GridBackground.tsx","pathfinding/core/Components.ts","pathfinding/core/Grid.ts","view/grid/TileFg.tsx","view/grid/GridForeground.tsx","pathfinding/core/Navigator.ts","pathfinding/core/PlusNavigator.ts","pathfinding/algorithms/Heuristics.ts","pathfinding/core/AsteriskNavigator.ts","pathfinding/structures/Hash.ts","pathfinding/structures/Heap.ts","pathfinding/algorithms/Pathfinder.ts","pathfinding/algorithms/Node.ts","pathfinding/algorithms/AStar.ts","pathfinding/algorithms/BFS.ts","pathfinding/structures/Stack.ts","pathfinding/algorithms/DFS.ts","pathfinding/algorithms/BidirectionalAStar.ts","pathfinding/algorithms/BidirectionalBFS.ts","pathfinding/algorithms/PathfinderFactory.ts","pathfinding/algorithms/MazeGenerator.ts","view/grid/PathfindingVisualizer.tsx","view/elements/Checkbox.tsx","view/elements/SteppedRangeSlider.tsx","view/elements/RadioButtonGroup.tsx","view/navbar/SettingPanels.tsx","view/SettingsManager.ts","view/PathfindingSettings.ts","view/PathfindingApp.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["TopBar","bar","React","createRef","window","addEventListener","props","onChangeHeight","current","offsetHeight","this","ref","className","children","Component","VisualizeButton","color","onClick","SettingsButton","MazeButton","AlgorithmDropDown","show","setState","up","display","hide","toggle","isHidden","state","contentStyle","onChange","key","algText","arrowClass","onMouseOver","onMouseLeave","style","ClearDropDown","onClickPath","onClickTiles","DraggablePanel","draggable","draggableContainer","draggableContent","dragging","prevX","prevY","mouseDown","e","preventDefault","clientY","clientX","mouseUp","mouseMove","container","top","offsetTop","left","offsetLeft","content","innerHeight","innerWidth","offsetWidth","getPosition","renderDraggable","onMouseDown","nativeEvent","onClickXButton","document","GridBackground","visualization","clear","createEmptyBg","doGeneration","generation","point","tile","y","x","visualizeGeneration","visualizeGenerations","generations","renderTiles","tiles","tilesY","row","tilesX","push","renderTile","width","tileWidth","backgroundColor","height","createTile","isSolid","pathCost","SquareGrid","mutateDefault","solid","mutate","undefined","nodes","data","createEmptyGrid","console","str","log","JSON","stringify","get","TileFg","applyExpandAnimation","original","tileSize","i","setTimeout","applyShrinkAnimation","size","doAnimation","fill","stroke","shapeRendering","pointsEqual","point1","point2","GridForeground","svg","mouseDown0","mouseDown2","draggingInitial","draggingGoal","disable","doTileAnimation","bounds","getBoundingRect","onPress","button","onDrag","touchStart","touch","touches","changedTouches","onTouch","touchMove","onEndingEvent","xCoordinate","yCoordinate","calculatePoint","initial","goal","drawTile","eraseTile","grid","moveInitial","onTilesDragged","moveGoal","drawGrid","clone","inBounds","clearTiles","revealed","drawPath","path","slice","erasePath","Math","floor","renderLines","lines","length","first","second","renderLine","offset","x1","y1","x2","y2","strokeWidth","renderEndTile","end","calcEndPointInView","round","topMargin","getBoundingClientRect","xmlns","onContextMenu","onMouseUp","onMouseMove","onTouchStart","onTouchMoveCapture","onTouchEnd","onTouchCancel","Navigator","a","b","PlusNavigator","getWidth","getHeight","euclidean","dx","abs","dy","sqrt","AsteriskNavigator","walkBottomRight","walkTopRight","walkBottomLeft","walkTopLeft","HashSet","map","HashTable","Heap","compare","elements","siftUp","val","peek","move","pop","siftDown","pos","parent","swap","right","child","from","to","reconstructPath","bottomLeaf","reconstructPathReversed","reverse","Pathfinder","navigator","recentSearch","node","onGeneration","Node","AStarNode","g","fScore","AStarPathfinder","func","heuristic","clearRecentSearch","getGrid","openSet","f","closedSet","root","add","isEmpty","currentNode","addRecent","currentPoint","equals","neighbors","neighbor","neighborPoint","neighborKey","stepCost","has","neighborNode","addChild","cost","BFSPathfinder","queue","visited","shift","next","Stack","DFSPathfinder","stack","BiAStarPathfinder","startOpenSet","startClosedSet","endOpenSet","endClosedSet","initialRoot","goalRoot","startCurrentNode","startCurrentPoint","startCurrentPointKey","concat","endCurrentNode","endCurrentPoint","endCurrentPointKey","BiBFSPathfinder","startVisited","endVisited","startQueue","endQueue","CREATE_NAVIGATOR","CREATE_HEURISTIC","manhattan","max","chebyshev","SQRT2","min","octile","CREATE_PATHFINDER","PathfinderFactory","algorithm","createHeuristic","toLowerCase","Error","createPathfinder","createNavigator","getMidPoint","range","mid","points","getRand","random","MazeGenerator","topLeft","bottomRight","draw","divide","chamber","widthOf","heightOf","divideWidth","randY","randX","toDraw","edgeBlocked","drawArr","leftChamber","rightChamber","topChamber","bottomChamber","mutateTile","calcLength","len","toFixed","PathfindingVisualizer","background","foreground","visualized","visualizing","visualTimeouts","doPathfinding","settings","pathfinder","getPathfinder","findPath","visualizeAlg","reconstructSolution","doDelayedPathfinding","clearVisualization","clearPath","toggleDisable","clearTimeout","onChangeVisualizing","increment","delayInc","promises","delay","promise","Promise","resolve","timeout","all","then","algorithmKey","bidirectional","hasBidirectional","getBidirectional","getNavigator","navigatorKey","heuristicKey","t0","performance","now","t2","time","unshift","createMaze","prevGrid","generator","generateMaze","setPositions","endPoint","screen","availWidth","availHeight","xEnd","yEnd","xFloor","yFloor","yDecimal","ceil","id","Checkbox","prevState","checked","defaultChecked","type","disabled","boxStyle","defaultProps","SteppedRangeSlider","Number","currentTarget","value","list","defaultValue","default","step","sliderStyle","RadioButtonGroup","index","Children","toArray","radioButtons","VisualSettings","onChangeViz","SpeedSettings","onChangeSpeed","speedText","AlgorithmSettings","onChangeDiagonals","onChangeBidirectional","HeuristicSettings","enable","onClickManhattan","onClickEuclidean","onClickChebyshev","onClickOctile","SettingsManager","changeAlgo","algo","changeVisualize","changeBidirectional","changeDiagonals","changeSpeed","speeds","changeManhattan","changeEuclidean","changeChebyshev","changeOctile","PathfindingApp","settingsManager","changeVButtonColor","vButtonColor","toggleSettings","panelShow","hideSettings","hDisabled","usesHeuristic","aDisabled","setLength","setTime","test","userAgent","href","App","reportWebVitals","onPerfEntry","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"mQAwBeA,E,4MAhBHC,IAAiCC,IAAMC,Y,uDAE/C,WAAqB,IAAD,OAChBC,OAAOC,iBAAiB,UAAU,kBAAM,EAAKC,MAAMC,eAAe,EAAKN,IAAIO,QAASC,iBACpFC,KAAKJ,MAAMC,eAAeG,KAAKT,IAAIO,QAASC,gB,oBAGhD,WACI,OACI,qBAAKE,IAAKD,KAAKT,IAAKW,UAAU,yCAA9B,SACKF,KAAKJ,MAAMO,e,GAZPX,IAAMY,WCKdC,EAAb,4JAEI,WACI,OACI,wBAAQH,UAAW,UAAYF,KAAKJ,MAAMU,MAAOC,QAASP,KAAKJ,MAAMW,QAArE,4BAJZ,GAAqCf,IAAMY,WAW9BI,EAAb,4JAEI,WACI,OACI,wBAAQN,UAAU,yBAAyBK,QAASP,KAAKJ,MAAMW,QAA/D,0BAJZ,GAAoCf,IAAMY,WAW7BK,EAAb,4JAEI,WACI,OACI,wBAAQP,UAAU,qBAAqBK,QAASP,KAAKJ,MAAMW,QAA3D,sBAJZ,GAAgCf,IAAMY,WCrBzBM,EAAb,kDAEI,WAAYd,GAAkB,IAAD,8BACzB,cAAMA,IAQVe,KAAO,WACH,EAAKC,SAAS,CACVC,IAAI,EACJC,QAAS,WAZY,EAgB7BC,KAAO,WACH,EAAKH,SAAS,CACVC,IAAI,EACJC,QAAS,UAnBY,EAuB7BE,OAAS,WACF,EAAKC,WACJ,EAAKN,OAEL,EAAKI,QA3BgB,EA+B7BE,SAAW,WACP,MAA8B,SAAvB,EAAKC,MAAMJ,SAhCO,EAmC7BK,aAAe,WACX,MAAO,CACHL,QAAS,EAAKI,MAAMJ,UArCC,EAyC7BM,SAAW,SAACC,EAAaC,GACrB,EAAK1B,MAAMwB,SAASC,GACpB,EAAKT,SAAS,CACVU,QAASA,KA5CY,EAgD7BC,WAAa,WACT,OAAO,EAAKL,MAAML,GAAK,UAAY,aA/CnC,EAAKK,MAAQ,CACTL,IAAI,EACJC,QAAS,OACTQ,QAAS,aALY,EAFjC,0CAsDI,WAAU,IAAD,OACL,OACI,sBAAKpB,UAAU,0BAA0BsB,YAAaxB,KAAKW,KAAMc,aAAczB,KAAKe,KAApF,UACI,sBAAKb,UAAU,wCAAf,UACI,sBAAMA,UAAU,oCAAhB,SAAqDF,KAAKkB,MAAMI,UAChE,sBAAMpB,UAAW,WAAaF,KAAKuB,kBAEvC,sBAAKG,MAAO1B,KAAKmB,eAAgBjB,UAAU,0CAA3C,UACI,qBAAKK,QAAS,kBAAM,EAAKa,SAAS,KAAM,cAAxC,uBACA,qBAAKb,QAAS,kBAAM,EAAKa,SAAS,WAAY,aAA9C,kCACA,qBAAKb,QAAS,kBAAM,EAAKa,SAAS,aAAc,eAAhD,+BACA,qBAAKb,QAAS,kBAAM,EAAKa,SAAS,MAAO,kBAAzC,kCACA,qBAAKb,QAAS,kBAAM,EAAKa,SAAS,MAAO,gBAAzC,0CAlEpB,GAAuC5B,IAAMY,WAmFhCuB,EAAb,kDAEI,WAAY/B,GAAkB,IAAD,8BACzB,cAAMA,IAOVe,KAAO,WACH,EAAKC,SAAS,CACVC,IAAI,EACJC,QAAS,WAXY,EAe7BC,KAAO,WACH,EAAKH,SAAS,CACVC,IAAI,EACJC,QAAS,UAlBY,EAsB7BE,OAAS,WACF,EAAKC,WACJ,EAAKN,OAEL,EAAKI,QA1BgB,EA8B7BE,SAAW,WACP,MAA8B,SAAvB,EAAKC,MAAMJ,SA/BO,EAkC7BK,aAAe,WACX,MAAO,CACHL,QAAS,EAAKI,MAAMJ,UApCC,EAwC7BS,WAAa,WACT,OAAO,EAAKL,MAAML,GAAK,WAAa,cAvCpC,EAAKK,MAAQ,CACTL,IAAI,EACJC,QAAS,QAJY,EAFjC,0CA8CI,WACI,OACI,sBAAKZ,UAAU,0BAA0BsB,YAAaxB,KAAKW,KAAMc,aAAczB,KAAKe,KAApF,UACI,sBAAKb,UAAU,wCAAf,UACI,sBAAMA,UAAU,oCAAhB,wBACA,sBAAMA,UAAW,WAAaF,KAAKuB,kBAEvC,sBAAKG,MAAO1B,KAAKmB,eAAgBjB,UAAU,0CAA3C,UACI,qBAAKK,QAASP,KAAKJ,MAAMgC,YAAzB,wBACA,qBAAKrB,QAASP,KAAKJ,MAAMiC,aAAzB,mCAvDpB,GAAmCrC,IAAMY,WCsD1B0B,E,kDA7HX,WAAYlC,GAAgB,IAAD,8BACvB,cAAMA,IAVFmC,UAAuCvC,IAAMC,YAS1B,EARnBuC,mBAAgDxC,IAAMC,YAQnC,EAPnBwC,iBAA8CzC,IAAMC,YAOjC,EAJnByC,UAAW,EAIQ,EAHnBC,MAAQ,EAGW,EAFnBC,MAAQ,EAEW,EAwBnBC,UAAY,SAACC,GACjBA,EAAEC,iBACF,EAAKH,MAAQE,EAAEE,QACf,EAAKL,MAAQG,EAAEG,QACf,EAAKP,UAAW,GA5BO,EAmCnBQ,QAAU,SAACJ,GACfA,EAAEC,iBACF,EAAKL,UAAW,GArCO,EA6CnBS,UAAY,SAACL,GACjB,GAAG,EAAKJ,SAAU,CACd,IAAMU,EAAY,EAAKZ,mBAAmBlC,QACtC+C,EAAOD,EAAUE,WAAa,EAAKV,MAAQE,EAAEE,SAC7CO,EAAQH,EAAUI,YAAc,EAAKb,MAAQG,EAAEG,SAC7CQ,EAAU,EAAKhB,iBAAiBnC,QAChCiC,EAAY,EAAKA,UAAUjC,SAE9BwC,EAAEE,QAAU,GAAKF,EAAEE,QAAU9C,OAAOwD,aAC5BZ,EAAEG,QAAU,GAAKH,EAAEG,QAAU/C,OAAOyD,cAC3C,EAAKjB,UAAW,GAGjBW,EAAM,EACLA,EAAM,EACCA,EAAMnD,OAAOwD,YAAcnB,EAAUhC,eAC5C8C,EAAMnD,OAAOwD,YAAcnB,EAAUhC,cAEtCgD,GAAQE,EAAQG,YAAY,EAC3BL,GAAQE,EAAQG,YAAY,EACtBL,EAAOrD,OAAOyD,WAAaF,EAAQG,YAAY,IACrDL,EAAOrD,OAAOyD,WAAaF,EAAQG,YAAY,GAGnD,EAAKxC,SAAS,CACViC,IAAKA,IAET,EAAKjC,SAAS,CACVmC,KAAMA,IAGV,EAAKX,MAAQE,EAAEE,QACf,EAAKL,MAAQG,EAAEG,UA7EI,EAiF3BY,YAAc,WACV,IAAMN,EAAO,EAAK7B,MAAM6B,KAClBF,EAAM,EAAK3B,MAAM2B,IACvB,OAAa,IAAVE,IAAwB,IAATF,EACP,GAEJ,CACHE,KAAMA,EAAO,KACbF,IAAKA,EAAM,OAzFQ,EA6F3B1B,aAAe,WACX,MAAO,CACHL,QAAS,EAAKlB,MAAMe,KAAO,QAAU,SA/FlB,EAgHnB2C,gBAAkB,WACtB,OACI,sBAAK5B,MAAO,EAAKP,eAAgBjB,UAAU,YACtCD,IAAK,EAAK8B,UACVwB,YAAa,SAAAjB,GAAC,OAAI,EAAKD,UAAUC,EAAEkB,cAFxC,UAII,qBAAKtD,UAAU,kBAAf,2BACA,qBAAKA,UAAU,WAAWK,QAAS,EAAKX,MAAM6D,eAA9C,mBArHR,EAAKvC,MAAQ,CACT2B,KAAM,EACNE,MAAO,GAJY,E,qDAQ3B,WAAqB,IAAD,OAChBW,SAAS/D,iBAAiB,WAAW,SAAA2C,GACjC,EAAKI,QAAQJ,MAEjBoB,SAAS/D,iBAAiB,aAAa,SAAA2C,GACnC,EAAKK,UAAUL,MAEnB5C,OAAOC,iBAAiB,cAAc,SAAA2C,GAClC,EAAKI,QAAQJ,Q,oBAmFrB,WACI,OACI,sBAAKrC,IAAKD,KAAKgC,mBAAoB9B,UAAU,sBAAsBwB,MAAO1B,KAAKqD,cAA/E,UACKrD,KAAKsD,kBACN,qBAAKrD,IAAKD,KAAKiC,iBAAkBP,MAAO1B,KAAKmB,eAAgBjB,UAAU,oBAAvE,SACI,qBAAKA,UAAU,mBAAf,SACKF,KAAKJ,MAAMO,oB,GArHPX,IAAMY,W,OCsHpBuD,E,kDA3GX,WAAY/D,GAAgB,IAAD,8BACvB,cAAMA,IAHFgE,mBAEmB,IAuB3BC,MAAQ,WACJ,EAAKD,cAAgB,EAAKE,gBAC1B,EAAKlD,SAAS,KAzBS,EAiCnBmD,aAAe,SAACC,EAAkBJ,GAA+B,IAAD,gBAClDI,EAAW7D,UADuC,IACpE,IAAI,EAAJ,qBAAuC,CAAC,IAC9B8D,EAD6B,QAChBC,KAAKD,MACxBL,EAAcK,EAAME,GAAGF,EAAMG,GAhDvB,sBA6C0D,8BAKpE,IAAMH,EAAQD,EAAWE,KAAKD,MAE9B,OADAL,EAAcK,EAAME,GAAGF,EAAMG,GApDjB,qBAqDLR,GAxCgB,EA+C3BS,oBAAsB,SAACL,GACnB,EAAKD,aAAaC,EAAY,EAAKJ,eACnC,EAAKhD,SAAS,KAjDS,EAwD3B0D,qBAAuB,SAACC,GACpB,IAD4C,EACtCX,EAAgB,EAAKE,gBADiB,cAEpBS,GAFoB,IAE5C,IAAI,EAAJ,qBAAqC,CAAC,IAA5BP,EAA2B,QACjC,EAAKD,aAAaC,EAAYJ,IAHU,8BAK5C,EAAKA,cAAgBA,EACrB,EAAKhD,SAAS,KA9DS,EAyEnB4D,YAAc,WAElB,IADA,IAAMC,EAAyB,GACvBN,EAAI,EAAGA,EAAI,EAAKvE,MAAM8E,OAAQP,IAAK,CAEvC,IADA,IAAIQ,EAAqB,GACjBP,EAAI,EAAGA,EAAI,EAAKxE,MAAMgF,OAAQR,IAAK,CACvC,IAAMH,EAAQ,CACVG,EAAGA,EAAGD,EAAGA,GAEbQ,EAAIE,KACA,EAAKC,WAAWb,EAAO,EAAKL,cAAcK,EAAME,GAAGF,EAAMG,KAGjEK,EAAMI,KAAKF,GAEf,OAAOF,GAvFgB,EA0FnBK,WAAa,SAACb,EAAc3D,GAChC,IAAMyE,EAAQ,EAAKnF,MAAMoF,UAGnBtD,EAAQ,CACVuD,gBAAiB3E,EACjByE,MAAOA,EAAQ,KACfG,OAAQH,EAAQ,KAChBlC,IANQoB,EAAME,EAAI,EAAKvE,MAAMoF,UAO7BjC,KANSkB,EAAMG,EAAI,EAAKxE,MAAMoF,WAQlC,OACI,qBAAmCtD,MAAOA,EAAOxB,UAAU,QAAjD+D,EAAMG,EAAI,IAAMH,EAAME,IApGpC,EAAKP,cAAgB,EAAKE,gBAFH,E,iDAQ3B,WAEI,IADA,IAAMF,EAAgB,GACdO,EAAI,EAAGA,EAAInE,KAAKJ,MAAM8E,OAAQP,IAAK,CAEvC,IADA,IAAIQ,EAAgB,GACZP,EAAI,EAAGA,EAAIpE,KAAKJ,MAAMgF,OAAQR,IAClCO,EAAIE,KAxBD,SA0BPjB,EAAciB,KAAKF,GAEvB,OAAOf,I,oBAgDX,WACI,OACI,qBAAK1D,UAAU,KAAf,SACKF,KAAKwE,oB,GA7EOhF,IAAMY,WCmB5B,SAAS+E,EAAWC,GACvB,MAAO,CACHC,SAAU,EACVD,QAASA,GC+IFE,M,WA9IX,WAAYP,EAAeG,EAAgBT,GAAmB,IAAD,OAGzD,GAHyD,yBAX5CA,WAW4C,OAV5CM,WAU4C,OAT5CG,YAS4C,OA8E7DK,cAAgB,SAACtB,EAAcuB,GAC3B,EAAKC,OACDxB,EAAOkB,EAAWK,KA/EtBxF,KAAK+E,MAAQA,EACb/E,KAAKkF,OAASA,OACDQ,IAAVjB,EACCzE,KAAKyE,MAyHjB,SAAyBM,EAAeG,GAEpC,IADA,IAAMS,EAAkB,GAChBxB,EAAI,EAAGA,EAAIe,EAAQf,IAAK,CAE5B,IADA,IAAMQ,EAAc,GACZP,EAAI,EAAGA,EAAIW,EAAOX,IACtBO,EAAIE,KAAK,CACLZ,MAAO,CACHG,EAAGA,EAAGD,EAAGA,GAEbyB,KAAMT,GAAW,KAGzBQ,EAAMd,KAAKF,GAEf,OAAOgB,EAvIcE,CAAgBd,EAAOG,OACjC,CACHlF,KAAKyE,MAAQ,GACb,IAAI,IAAIN,EAAI,EAAGA,EAAIe,EAAQf,IAAK,CAE5B,IADA,IAAMQ,EAAc,GACZP,EAAI,EAAGA,EAAIW,EAAOX,IACtBO,EAAIE,KAAK,CACLe,KAAM,CACFP,SAAUZ,EAAMN,GAAGC,GAAGwB,KAAKP,SAC3BD,QAASX,EAAMN,GAAGC,GAAGwB,KAAKR,SAE9BnB,MAAO,CACHG,EAAGA,EAAGD,EAAGA,KAItBnE,KAAKyE,MAAMI,KAAKF,K,4CAK3B,WACI,OAAO3E,KAAK+E,Q,uBAGhB,WACI,OAAO/E,KAAKkF,S,sBAShB,SAASjB,GACL,OAAOA,EAAMG,GAAK,GAAKH,EAAMG,EAAIpE,KAAK+E,OAASd,EAAME,GAAK,GAAKF,EAAME,EAAInE,KAAKkF,S,iBASlF,SAAIjB,GACA,MAAO,CACHA,MAAOjE,KAAKyE,MAAMR,EAAME,GAAGF,EAAMG,GAAGH,MACpC2B,KAAM5F,KAAKyE,MAAMR,EAAME,GAAGF,EAAMG,GAAGwB,Q,oBAS3C,SAAO3B,EAAc2B,GACjB5F,KAAKyE,MAAMR,EAAME,GAAGF,EAAMG,GAAGwB,KAAOA,I,wBAOxC,SAAW1B,GACPlE,KAAKyE,MAAMP,EAAKD,MAAME,GAAGD,EAAKD,MAAMG,GAAGwB,KAAO1B,EAAK0B,O,oBAkBvD,SAAOE,GACH,IAAI,IAAI3B,EAAI,EAAGA,EAAInE,KAAKkF,OAAQf,IAAK,CAEjC,IADA,IAAI4B,EAAM,GACF3B,EAAI,EAAGA,EAAIpE,KAAK+E,MAAOX,IAC3B2B,GAAO/F,KAAKyE,MAAMN,GAAGC,GAAGwB,KAAKR,QAAU,KAE3CU,EAAQE,IAAID,M,qBAOpB,WACI,OAAOE,KAAKC,UAAUlG,KAAKyE,S,sBAO/B,SAASR,GACL,OAAQjE,KAAKmG,IAAIlC,GAAO2B,KAAKR,U,qBAGjC,SAAQnB,GACJ,OAAOjE,KAAKmG,IAAIlC,GAAO2B,KAAKR,U,mBAGhC,WACI,OAAO,IAAIE,EAAWtF,KAAK+E,MAAO/E,KAAKkF,OAAQlF,KAAKyE,W,KChF7C2B,E,kDA3DX,WAAYxG,GAAgB,IAAD,uBACvB,cAAMA,IAiBVyG,qBAAuB,WAGnB,IAFA,IACMC,EAAW,EAAKpF,MAAMqF,SAFH,WAGjBC,GAIJC,YAHe,kBAAM,EAAK7F,SAAS,CAC/B2F,SAAUD,EAAWE,GAAK,EAAK5G,MAAMoF,UAJ/B,OAMW,GAAFwB,IAJfA,EAAI,EAAGA,GAFD,EAEaA,IAAM,EAAzBA,IArBe,EA6B3BE,qBAAuB,WAGnB,IAFA,IACMJ,EAAW,EAAKpF,MAAMqF,SAFH,WAGjBC,GAIJC,YAHe,kBAAM,EAAK7F,SAAS,CAC/B2F,SAAUD,EAAWE,GAAK,EAAK5G,MAAMoF,UAJ/B,OAMW,GAAFwB,IAJfA,EAAI,EAAGA,GAFD,EAEaA,IAAM,EAAzBA,IA9BR,IAAMG,EAAO,EAAK/G,MAAMgH,YAAe,EAAI,EAAKhH,MAAMoF,UAF/B,OAGvB,EAAK9D,MAAQ,CACTqF,SAAUI,GAJS,E,qDAQ3B,WACO3G,KAAKJ,MAAMgH,aACV5G,KAAKqG,yB,oBA8Bb,WACI,IAAMtB,EAAQ/E,KAAKkB,MAAMqF,SACnB1D,EAAM7C,KAAKJ,MAAMqE,MAAME,EAAInE,KAAKJ,MAAMoF,WAAahF,KAAKJ,MAAMoF,UAAYD,GAAO,EACjFhC,EAAO/C,KAAKJ,MAAMqE,MAAMG,EAAIpE,KAAKJ,MAAMoF,WAAahF,KAAKJ,MAAMoF,UAAYD,GAAO,EAClFrD,EAAQ,CACVmF,KAAM7G,KAAKJ,MAAMU,MACjBwG,OAAQ,OACRhG,QAAS,SAEb,OACI,sBAAMsD,EAAGrB,EAAMoB,EAAGtB,EACZkE,eAAe,aACfhC,MAAOA,EAAOG,OAAQH,EACtBrD,MAAOA,EAAOxB,UAAW,sB,GAvDtBV,IAAMY,WCgW3B,SAAS4G,EAAYC,EAAeC,GAChC,OAAOD,EAAO7C,IAAM8C,EAAO9C,GAAK6C,EAAO9C,IAAM+C,EAAO/C,EAGzCgD,M,kDA9UX,WAAYvH,GAAgB,IAAD,uBACvB,cAAMA,IAXFwH,IAAgC5H,IAAMC,YAUnB,EARnB4H,YAAsB,EAQH,EAPnBC,YAAsB,EAOH,EANnBC,iBAA2B,EAMR,EALnBC,cAAwB,EAKL,EAJnBC,SAAmB,EAIA,EAFnBC,iBAA2B,EAER,EAiCnBrF,UAAY,SAACC,GACjBA,EAAEC,iBACF,IAAMoF,EAAS,EAAKC,kBACpB,EAAKC,QAAQvF,EAAEG,QAAUkF,EAAO5E,KAAMT,EAAEE,QAAUmF,EAAO9E,IAAKP,EAAEwF,SApCzC,EAuCnBpF,QAAU,SAACJ,GACfA,EAAEC,iBACc,IAAbD,EAAEwF,QACD,EAAKN,cAAe,EACpB,EAAKD,iBAAkB,EACvB,EAAKF,YAAa,GACC,IAAb/E,EAAEwF,SACR,EAAKR,YAAa,IA9CC,EAkDnB3E,UAAY,SAACL,GACjB,IAAMqF,EAAS,EAAKC,kBACpB,EAAKG,OAAOzF,EAAEG,QAAUkF,EAAO5E,KAAMT,EAAEE,QAAUmF,EAAO9E,MApDjC,EAuDnBmF,WAAa,SAAC1F,GAClB,IAAM2F,EAAQ3F,EAAE4F,QAAQ,IAAM5F,EAAE6F,eAAe,GACzCR,EAAS,EAAKC,kBACpB,EAAKQ,QAAQH,EAAMxF,QAAUkF,EAAO5E,KAAMkF,EAAMzF,QAAUmF,EAAO9E,MA1D1C,EA6DnBwF,UAAY,SAAC/F,GACjB,IAAM2F,EAAQ3F,EAAE4F,QAAQ,IAAM5F,EAAE6F,eAAe,GACzCR,EAAS,EAAKC,kBACpB,EAAKG,OAAOE,EAAMxF,QAAUkF,EAAO5E,KAAMkF,EAAMzF,QAAUmF,EAAO9E,MAhEzC,EAmEnByF,cAAgB,SAAChG,GACrBA,EAAEC,iBACF,EAAKiF,cAAe,EACpB,EAAKD,iBAAkB,EACvB,EAAKF,YAAa,EAClB,EAAKC,YAAa,GAxEK,EAiFnBO,QAAU,SAACU,EAAqBC,EAAqBV,GACzD,IAAM7D,EAAQ,EAAKwE,eAAeF,EAAYC,GAChC,IAAXV,GACC,EAAKT,YAAa,EACfL,EAAY/C,EAAO,EAAK/C,MAAMwH,SAC7B,EAAKnB,iBAAkB,EACjBP,EAAY/C,EAAO,EAAK/C,MAAMyH,MACpC,EAAKnB,cAAe,EACb,EAAKC,SACZ,EAAKmB,SAAS3E,IAED,IAAX6D,IACN,EAAKR,YAAa,EACdN,EAAY/C,EAAM,EAAK/C,MAAMwH,UAAa1B,EAAY/C,EAAO,EAAK/C,MAAMyH,OAAU,EAAKlB,SACvF,EAAKoB,UAAU5E,KA/FA,EAyGnBmE,QAAU,SAACG,EAAqBC,GACpC,IAAMvE,EAAQ,EAAKwE,eAAeF,EAAYC,GAC3CxB,EAAY/C,EAAO,EAAK/C,MAAMwH,UAC7B,EAAKrB,YAAa,EAClB,EAAKE,iBAAkB,GACjBP,EAAY/C,EAAO,EAAK/C,MAAMyH,OACpC,EAAKtB,YAAa,EAClB,EAAKG,cAAe,GACb,EAAKtG,MAAM4H,KAAK1D,QAAQnB,IAM/B,EAAKqD,YAAa,EACdN,EAAY/C,EAAO,EAAK/C,MAAMwH,UAAa1B,EAAY/C,EAAO,EAAK/C,MAAMyH,OAAU,EAAKlB,SACxF,EAAKoB,UAAU5E,KAPnB,EAAKoD,YAAa,EACd,EAAKI,SACL,EAAKmB,SAAS3E,KApHC,EAmInB8D,OAAS,SAACQ,EAAqBC,GACnC,IAAMvE,EAAQ,EAAKwE,eAAeF,EAAYC,GAC3C,EAAKnB,WACD,EAAKE,iBACJ,EAAKwB,YAAY9E,GACjB,EAAKrE,MAAMoJ,kBACL,EAAKxB,cACX,EAAKyB,SAAShF,GACd,EAAKrE,MAAMoJ,kBACJhC,EAAY/C,EAAM,EAAK/C,MAAMwH,UAAa1B,EAAY/C,EAAO,EAAK/C,MAAMyH,OAAU,EAAKlB,SAC9F,EAAKmB,SAAS3E,GAEZ,EAAKqD,aACPN,EAAY/C,EAAO,EAAK/C,MAAMwH,UAAa1B,EAAY/C,EAAO,EAAK/C,MAAMyH,OAAU,EAAKlB,SACxF,EAAKoB,UAAU5E,KAjJA,EA0J3BiF,SAAW,SAACJ,GACR,EAAKpB,iBAAkB,EACvB,EAAK9G,SAAS,CACVkI,KAAMA,IACP,kBAAM,EAAKpB,iBAAkB,MA9JT,EAqK3BkB,SAAW,SAAC3E,GACR,IAAM6E,EAAO,EAAK5H,MAAM4H,KAAKK,QAC1BL,EAAKM,SAASnF,IACb6E,EAAKvD,cAActB,GAAO,GAE9B,EAAKrD,SAAS,CACVkI,KAAMA,KA3Ka,EAmL3BD,UAAY,SAAC5E,GACT,IAAM6E,EAAO,EAAK5H,MAAM4H,KAAKK,QAC1BL,EAAKM,SAASnF,IACb6E,EAAKvD,cAActB,GAAO,GAE9B,EAAKrD,SAAS,CACVkI,KAAMA,KAzLa,EAgM3BO,WAAa,WAET,IADA,IAAMP,EAAO,EAAK5H,MAAM4H,KAAKK,QACrBhF,EAAI,EAAGA,EAAI,EAAKvE,MAAM8E,OAAQP,IAClC,IAAI,IAAIC,EAAI,EAAGA,EAAI,EAAKxE,MAAMgF,OAAQR,IAAK,CACvC,IAAMH,EAAQ,CACVG,EAAGA,EAAGD,EAAGA,GAEb2E,EAAKvD,cAActB,GAAO,GAGlC,EAAKrD,SAAS,CACVkI,KAAMA,KA3Ma,EAmN3BC,YAAc,SAAC9E,GACX,IAAMqF,EAAW,EAAKpI,MAAM4H,KAAK1D,QAAQnB,IACtC,EAAK/C,MAAM4H,KAAKM,SAASnF,IAAWqF,GAClCtC,EAAY,EAAK9F,MAAMyH,KAAM1E,IAAY,EAAKwD,SAC/C,EAAK7G,SAAS,CACV8H,QAASzE,KAxNM,EAiO3BgF,SAAW,SAAChF,GACR,IAAMqF,EAAW,EAAKpI,MAAM4H,KAAK1D,QAAQnB,IACtC,EAAK/C,MAAM4H,KAAKM,SAASnF,IAAWqF,GAClCtC,EAAY,EAAK9F,MAAMwH,QAASzE,IAAW,EAAKwD,SACjD,EAAK7G,SAAS,CACV+H,KAAM1E,KAtOS,EA2O3BsF,SAAW,SAACC,GACR,EAAK5I,SAAS,CACV4I,KAAMA,EAAKC,WA7OQ,EAiP3BC,UAAY,WACR,EAAK9I,SAAS,CACV4I,KAAM,MAnPa,EA6P3Bf,eAAiB,SAACF,EAAqBC,GACnC,MAAO,CACHpE,EAAGuF,KAAKC,MAAMrB,EAAY,EAAK3I,MAAMoF,WACrCb,EAAGwF,KAAKC,MAAMpB,EAAY,EAAK5I,MAAMoF,aAhQlB,EAyRnB6E,YAAc,WAElB,IADA,IAAMC,EAAuB,GACrBtD,EAAI,EAAGA,EAAI,EAAKtF,MAAMsI,KAAKO,OAAO,EAAGvD,IAAK,CAC9C,IAAMwD,EAAQ,EAAK9I,MAAMsI,KAAKhD,GAAGvC,MAC3BgG,EAAS,EAAK/I,MAAMsI,KAAKhD,EAAE,GAAGvC,MACpC6F,EAAMjF,KAAK,EAAKqF,WAAWF,EAAOC,IAEtC,OAAOH,GAhSgB,EAmSnBI,WAAa,SAACF,EAAcC,GAChC,IAAMlF,EAAQ,EAAKnF,MAAMoF,UACnBmF,EAASpF,EAAM,EACrB,OACI,sBACMqF,GAAIJ,EAAM5F,EAAIW,EAAQoF,EAAQE,GAAIL,EAAM7F,EAAIY,EAAQoF,EACpDG,GAAIL,EAAO7F,EAAIW,EAAQoF,EAAQI,GAAIN,EAAO9F,EAAIY,EAAQoF,EACtDrD,OAAO,QAAQ0D,YAAY,IAAItK,UAAU,QAHpC+J,EAAO7F,EAAI,IAAM6F,EAAO9F,IAvShB,EA8SnBK,YAAc,WAElB,IADA,IAAMC,EAAuB,GACrBN,EAAI,EAAGA,EAAI,EAAKvE,MAAM8E,OAAQP,IAClC,IAAI,IAAIC,EAAI,EAAGA,EAAI,EAAKxE,MAAMgF,OAAQR,IAAK,CACvC,IAAMH,EAAQ,CACVG,EAAGA,EAAGD,EAAGA,GAEV,EAAKjD,MAAM4H,KAAK1D,QAAQnB,IACvBQ,EAAMI,KACF,cAAC,EAAD,CAAsCZ,MAAOA,EACrC2C,YAAa,EAAKc,gBAClB1C,UAAW,EAAKpF,MAAMoF,UACtB1E,MA1UZ,mBAuUiB2D,EAAMG,EAAI,IAAMH,EAAME,IASnD,OAAOM,GAhUgB,EAmUnBgG,cAAgB,SAACxG,EAAc3D,EAAee,GAClD,OAAO,cAAC,EAAD,CAAkB4C,MAAOA,EAAO2C,aAAa,EACrC5B,UAAW,EAAKpF,MAAMoF,UACtB1E,MAAOA,GAFFe,IAlUpB,IAAMqJ,EAAM,EAAKC,qBAFM,OAGvB,EAAKzJ,MAAQ,CACT4H,KAAM,IAAIxD,EAAW,EAAK1F,MAAMgF,OAAQ,EAAKhF,MAAM8E,QACnD8E,KAAM,GACNd,QAAS,CACLtE,EAAKsG,EAAItG,EAAG,GAAM,EAClBD,EAAKuG,EAAIvG,EAAG,GAAM,GAEtBwE,KAAM,CACFvE,GAAK,EAAGsG,EAAItG,EAAG,GAAM,GAAK,EAC1BD,GAAK,EAAGuG,EAAIvG,EAAG,GAAM,GAAK,IAZX,E,sDAiB3B,WAGI,MAAO,CACHC,EAHSuF,KAAKiB,MAAMlL,OAAOyD,WAAanD,KAAKJ,MAAMoF,WAG1Cb,EAFAwF,KAAKiB,OAAOlL,OAAOwD,YAAclD,KAAKJ,MAAMiL,UAAY,IAAM7K,KAAKJ,MAAMoF,c,2BAM1F,WACIhF,KAAKyH,SAAWzH,KAAKyH,U,6BAGzB,WACI,OAAOzH,KAAKoH,IAAItH,QAASgL,0B,oBAsO7B,WAAU,IAAD,OACL,OACI,sBAAK7K,IAAKD,KAAKoH,IAAK2D,MAAM,6BAA6B7K,UAAU,OAC5D8K,cAAe,SAAA1I,GAAC,OAAIA,EAAEC,kBACtBgB,YAAa,SAAAjB,GAAC,OAAI,EAAKD,UAAUC,EAAEkB,cACnCyH,UAAW,SAAA3I,GAAC,OAAI,EAAKI,QAAQJ,EAAEkB,cAC/B0H,YAAa,SAAA5I,GAAC,OAAI,EAAKK,UAAUL,EAAEkB,cACnC/B,aAAc,SAAAa,GAAC,OAAI,EAAKgG,cAAchG,EAAEkB,cACxC2H,aAAc,SAAA7I,GAAC,OAAI,EAAK0F,WAAW1F,EAAEkB,cACrC4H,mBAAoB,SAAA9I,GAAC,OAAI,EAAK+F,UAAU/F,EAAEkB,cAC1C6H,WAAY,SAAA/I,GAAC,OAAI,EAAKgG,cAAchG,EAAEkB,cACtC8H,cAAe,SAAAhJ,GAAC,OAAI,EAAKgG,cAAchG,EAAEkB,cAT9C,UAWKxD,KAAKyK,cAAczK,KAAKkB,MAAMwH,QAhSzB,oBAgSgD,WACrD1I,KAAKyK,cAAczK,KAAKkB,MAAMyH,KAhS5B,mBAgS6C,QAC/C3I,KAAK6J,cACL7J,KAAKwE,qB,GAhSOhF,IAAMY,WCwBpBmL,E,WAhCX,WAAYzC,GAAa,yBAFNA,UAEK,EACpB9I,KAAK8I,KAAOA,E,2CAGhB,WACI,OAAO9I,KAAK8I,O,oBAQhB,SAAO0C,EAAUC,GACb,OAAOD,EAAEpH,IAAMqH,EAAErH,GAAKoH,EAAErH,IAAMsH,EAAEtH,M,KCmCzBuH,E,+JApDX,SAAUzH,GACN,IAAMQ,EAAgB,GACtB,GAAGR,EAAMG,EDZG,ECYQpE,KAAK8I,KAAK6C,WAAY,CACtC,IAAMzH,EAAOlE,KAAK8I,KAAK3C,IAAI,CACvB/B,EAAGH,EAAMG,EDdL,ECeJD,EAAGF,EAAME,IAETD,EAAK0B,KAAKR,SACVX,EAAMI,KAAKX,GAGnB,GAAGD,EAAME,EDrBG,ECqBQnE,KAAK8I,KAAK8C,YAAa,CACvC,IAAM1H,EAAOlE,KAAK8I,KAAK3C,IAAI,CACvB/B,EAAGH,EAAMG,EACTD,EAAGF,EAAME,EDxBL,IC0BJD,EAAK0B,KAAKR,SACVX,EAAMI,KAAKX,GAGnB,GAAGD,EAAMG,ED9BG,GC8BS,EAAG,CACpB,IAAMF,EAAOlE,KAAK8I,KAAK3C,IAAI,CACvB/B,EAAGH,EAAMG,EDhCL,ECiCJD,EAAGF,EAAME,IAETD,EAAK0B,KAAKR,SACVX,EAAMI,KAAKX,GAGnB,GAAGD,EAAME,EDvCG,GCuCS,EAAG,CACpB,IAAMD,EAAOlE,KAAK8I,KAAK3C,IAAI,CACvB/B,EAAGH,EAAMG,EACTD,EAAGF,EAAME,ED1CL,IC4CJD,EAAK0B,KAAKR,SACVX,EAAMI,KAAKX,GAGnB,OAAOO,I,kBASX,SAAK+G,EAAUC,GACX,OAAOzL,KAAK8I,KAAK3C,IAAIsF,GAAG7F,KAAKP,a,GAtDTkG,GCGrB,SAASM,EAAUL,EAAUC,GAChC,IAAIK,EAAKnC,KAAKoC,IAAIP,EAAEpH,EAAIqH,EAAErH,GACtB4H,EAAKrC,KAAKoC,IAAIP,EAAErH,EAAIsH,EAAEtH,GAC1B,OAAOwF,KAAKsC,KAAKH,EAAKA,EAAKE,EAAKA,G,ICkHrBE,E,+JAjHX,SAAUjI,GAEN,IAAIkI,GAAkB,EAClBC,GAAe,EACfC,GAAiB,EACjBC,GAAc,EAEZ7H,EAAgB,GACtB,GAAGR,EAAMG,EHnBG,EGmBQpE,KAAK8I,KAAK6C,WAAY,CACtC,IAAMzH,EAAOlE,KAAK8I,KAAK3C,IAAI,CACvB/B,EAAGH,EAAMG,EHrBL,EGsBJD,EAAGF,EAAME,IAETD,EAAK0B,KAAKR,UACVX,EAAMI,KAAKX,GACXiI,GAAkB,EAClBC,GAAe,GAGvB,GAAGnI,EAAME,EH9BG,EG8BQnE,KAAK8I,KAAK8C,YAAa,CACvC,IAAM1H,EAAOlE,KAAK8I,KAAK3C,IAAI,CACvB/B,EAAGH,EAAMG,EACTD,EAAGF,EAAME,EHjCL,IGmCJD,EAAK0B,KAAKR,UACVX,EAAMI,KAAKX,GACXiI,GAAkB,EAClBE,GAAiB,GAGzB,GAAGpI,EAAMG,EHzCG,GGyCS,EAAG,CACpB,IAAMF,EAAOlE,KAAK8I,KAAK3C,IAAI,CACvB/B,EAAGH,EAAMG,EH3CL,EG4CJD,EAAGF,EAAME,IAETD,EAAK0B,KAAKR,UACVX,EAAMI,KAAKX,GACXmI,GAAiB,EACjBC,GAAc,GAGtB,GAAGrI,EAAME,EHpDG,GGoDS,EAAG,CACpB,IAAMD,EAAOlE,KAAK8I,KAAK3C,IAAI,CACvB/B,EAAGH,EAAMG,EACTD,EAAGF,EAAME,EHvDL,IGyDJD,EAAK0B,KAAKR,UACVX,EAAMI,KAAKX,GACXkI,GAAe,EACfE,GAAc,GAItB,GAAGrI,EAAMG,EHhEG,EGgEQpE,KAAK8I,KAAK6C,YAC1B1H,EAAME,EHjEE,EGiESnE,KAAK8I,KAAK8C,aAC3BO,EAAiB,CACjB,IAAMjI,EAAOlE,KAAK8I,KAAK3C,IAAI,CACvB/B,EAAGH,EAAMG,EHpEL,EGqEJD,EAAGF,EAAME,EHrEL,IGuEJD,EAAK0B,KAAKR,SACVX,EAAMI,KAAKX,GAGnB,GAAGD,EAAMG,EH3EG,GG2ES,GACjBH,EAAME,EH5EE,EG4ESnE,KAAK8I,KAAK8C,aAC3BS,EAAgB,CAChB,IAAMnI,EAAOlE,KAAK8I,KAAK3C,IAAI,CACvB/B,EAAGH,EAAMG,EH/EL,EGgFJD,EAAGF,EAAME,EHhFL,IGkFJD,EAAK0B,KAAKR,SACVX,EAAMI,KAAKX,GAGnB,GAAGD,EAAMG,EHtFG,EGsFQpE,KAAK8I,KAAK6C,YAC1B1H,EAAME,EHvFE,GGuFU,GAClBiI,EAAc,CACd,IAAMlI,EAAQlE,KAAK8I,KAAK3C,IAAI,CACxB/B,EAAGH,EAAMG,EH1FL,EG2FJD,EAAGF,EAAME,EH3FL,IG6FJD,EAAK0B,KAAKR,SACVX,EAAMI,KAAKX,GAGnB,GAAGD,EAAMG,EHjGG,GGiGS,GACjBH,EAAME,EHlGE,GGkGU,GAClBmI,EAAa,CACb,IAAMpI,EAAQlE,KAAK8I,KAAK3C,IAAI,CACxB/B,EAAGH,EAAMG,EHrGL,EGsGJD,EAAGF,EAAME,EHtGL,IGwGJD,EAAK0B,KAAKR,SACVX,EAAMI,KAAKX,GAGnB,OAAOO,I,kBAUX,SAAK+G,EAAUC,GACX,OAAOI,EAAUL,EAAEC,GAAKzL,KAAK8I,KAAK3C,IAAIsF,GAAG7F,KAAKP,a,GAlHtBkG,GCHnBgB,EAAb,iDAEYC,IAAgC,GAF5C,uCAII,SAAInL,GACArB,KAAKwM,IAAInL,IAAO,IALxB,oBAQI,SAAOA,GACHrB,KAAKwM,IAAInL,IAAO,IATxB,iBAYI,SAAIA,GACA,OAAOrB,KAAKwM,IAAInL,KAbxB,mBAgBI,WACIrB,KAAKwM,IAAM,OAjBnB,KAwBaC,EAAb,iDAEYD,IAA0C,GAFtD,uCAII,SAAInL,EAAauE,GACb5F,KAAKwM,IAAInL,GAAOuE,IALxB,oBAQI,SAAOvE,GACHrB,KAAKwM,IAAInL,QAAOqE,IATxB,iBAYI,SAAIrE,GACA,OAAOrB,KAAKwM,IAAInL,KAbxB,iBAgBI,SAAIA,GACA,YAAyBqE,IAAlB1F,KAAKwM,IAAInL,KAjBxB,mBAoBI,WACIrB,KAAKwM,IAAM,OArBnB,KA6BO,SAAStG,EAAUjC,GACtB,MAAO,IAAMA,EAAMG,EAAI,IAAMH,EAAME,E,ICsExBuI,E,WApHX,WAAYC,GAAyB,yBAH7BC,SAAgB,GAGY,KAF3BD,aAE2B,EAChC3M,KAAK2M,QAAUA,E,2CAMnB,WACI,OAAO3M,KAAK4M,SAAS7C,S,qBAMzB,WACI,OAAgC,IAAzB/J,KAAK4M,SAAS7C,S,kBAOzB,SAAKzH,GACDtC,KAAK4M,SAAS/H,KAAKvC,GACnBtC,KAAK6M,OAAO7M,KAAK4M,SAAS7C,OAAO,K,kBAOrC,WACI,OAAO/J,KAAK4M,SAAS,K,iBAOzB,WACI,IAAIE,EAAM9M,KAAK+M,OAIf,OAHA/M,KAAKgN,KAAKhN,KAAK4M,SAAS7C,OAAS,EAAG,GACpC/J,KAAK4M,SAASK,MACdjN,KAAKkN,SAAS,GACPJ,I,mBAMX,WACI9M,KAAK4M,SAAW,K,oBAOpB,SAAeO,GAEX,IADA,IAAIC,GAAWD,EAAM,GAAK,GAAM,EAC1BC,GAAU,GAETpN,KAAK2M,QAAQ3M,KAAK4M,SAASO,GAAMnN,KAAK4M,SAASQ,KAE9CpN,KAAKqN,KAAKF,EAAKC,GAEfA,IADAD,EAAMC,GACW,GAAK,GAAM,GAG5BA,GAAU,I,sBAStB,SAAiBD,GACb,IAAIpK,EAAO,EAAIoK,EAAM,EACjBG,EAAQ,EAAIH,EAAM,EAEtB,KAAGpK,GAAQ/C,KAAK4M,SAAS7C,QAAzB,CAIA,IAAIwD,EAASD,GAAStN,KAAK4M,SAAS7C,QAAU/J,KAAK2M,QAAQ3M,KAAK4M,SAAS7J,GAAO/C,KAAK4M,SAASU,IACxFvK,EAAOuK,EAEVtN,KAAK2M,QAAQ3M,KAAK4M,SAASW,GAAQvN,KAAK4M,SAASO,MAChDnN,KAAKqN,KAAKE,EAAOJ,GACjBnN,KAAKkN,SAASK,O,kBAStB,SAAaC,EAAcC,GACvBzN,KAAK4M,SAASa,GAAMzN,KAAK4M,SAASY,K,kBAQtC,SAAahC,EAAWC,GACpB,IAAIqB,EAAM9M,KAAK4M,SAASpB,GACxBxL,KAAK4M,SAASpB,GAAKxL,KAAK4M,SAASnB,GACjCzL,KAAK4M,SAASnB,GAAKqB,M,KC/DpB,SAASY,EAAgBC,GAC5B,OAAOC,EAAwBD,GAAYE,UAQxC,SAASD,EAAwBD,GAEpC,IADA,IAAInE,EAAe,GACS,OAAtBmE,EAAWP,QACb5D,EAAK3E,KAAK8I,EAAWzJ,MACrByJ,EAAaA,EAAWP,OAE5B,OAAO5D,EAGIsE,M,WAnEX,WAAYC,GAAuB,yBAHzBC,aAAuB,GAGC,KAFxBD,eAEwB,EAC9B/N,KAAK+N,UAAYA,E,gDAGrB,SAAaA,GACT/N,KAAK+N,UAAYA,I,0BAGrB,WACI,OAAO/N,KAAK+N,Y,4BAGhB,WACI,OAAO/N,KAAKgO,aAAajE,S,+BAG7B,WACI/J,KAAKgO,aAAe,K,uBAGxB,SAAUC,GACNjO,KAAKgO,aAAanJ,KAAKoJ,K,iCAgB3B,SAAoBC,GAAsC,IAAD,gBACrClO,KAAKgO,cADgC,IACrD,IAAI,EAAJ,qBAAmC,CAC/BE,EAD+B,UADkB,mC,KC7ChDC,EAAb,WAMI,WAAYjK,GAAa,yBAJzBkJ,OAAsB,KAIE,KAHfjN,SAAmB,GAGJ,KAFf+D,UAEe,EACpBlE,KAAKkE,KAAOA,EAPpB,4CAUI,SAASqJ,GACLA,EAAMH,OAASpN,KACfA,KAAKG,SAAS0E,KAAK0I,OAZ3B,KAmBaa,EAAb,kDAKI,WAAYlK,EAAYmK,EAAWC,GAAiB,IAAD,8BAC/C,cAAMpK,IAJDmK,OAG0C,IAF1CC,YAE0C,EAE/C,EAAKD,EAAIA,EACT,EAAKC,OAASA,EAHiC,EALvD,qCAWI,WACI,OAAOtO,KAAKsO,WAZpB,GAA+BH,GCkDhBI,E,kDA9DX,WAAYR,EAAsBS,GAAuB,IAAD,8BACpD,cAAMT,IAHOU,UAA2B,SAACjD,EAAUC,GAAX,OAAwBI,EAAUL,EAAEC,SAIhE/F,IAAT8I,IACC,EAAKC,UAAYD,GAH+B,E,4CAaxD,SAAS9F,EAAgBC,GACrB3I,KAAK0O,oBACL,IAAM5F,EAAO9I,KAAK+N,UAAUY,UACtBC,EAAU,IAAIlC,GAChB,SAAClB,EAAGC,GAAJ,OAAUD,EAAEqD,IAAMpD,EAAEoD,OAElBC,EAAY,IAAIrC,EAChBsC,EAAO,IAAIX,EACbtF,EAAK3C,IAAIuC,GAAU,EAAG,GAI1B,IAFAkG,EAAQ/J,KAAKkK,GACbD,EAAUE,IAAI9I,EAAUwC,GAAUqG,EAAKF,MAC/BD,EAAQK,WAAW,CACvB,IAAMC,EAAcN,EAAQ3B,MAC5BjN,KAAKmP,UAAUD,GACf,IAAME,EAAeF,EAAYhL,KAAKD,MACtC,GAAIjE,KAAK+N,UAAUsB,OAAOD,EAAczG,GACpC,OAAO+E,EAAgBwB,GALJ,oBAOAlP,KAAK+N,UAAUuB,UAAUF,IAPzB,IAOvB,2BAA+D,CAAC,IAArDG,EAAoD,QACrDC,EAAgBD,EAAStL,MACzBwL,EAAcvJ,EAAUsJ,GACxBnB,EAAIa,EAAYb,EAAIrO,KAAK0P,SAASN,EAAcI,GAChDX,EAAIR,EAAIrO,KAAKyO,UAAUe,EAAe7G,GAC5C,IAAKmG,EAAUa,IAAIF,IAAgBZ,EAAIC,EAAU3I,IAAIsJ,GAAe,CAChE,IAAMG,EAAe,IAAIxB,EACrBmB,EAAUlB,EAAGQ,GAEjBK,EAAYW,SAASD,GACrBhB,EAAQ/J,KAAK+K,GACbd,EAAUE,IAAIS,EAAaG,EAAaf,OAlBzB,+BAsB3B,MAAO,K,sBAUX,SAASO,EAAqBI,GAC1B,OAAOxP,KAAK+N,UAAU+B,KAAKV,EAAcI,O,GA9DnB1B,GCkCfiC,E,8JA7BX,SAASrH,EAAgBC,GACrB3I,KAAK0O,oBACL,IAAM5F,EAAO9I,KAAK+N,UAAUY,UACtBqB,EAAgB,GAChBC,EAAU,IAAI1D,EACdwC,EAAO,IAAIZ,EAAKrF,EAAK3C,IAAIuC,IAG/B,IAFAsH,EAAMnL,KAAKkK,GACXkB,EAAQjB,IAAI9I,EAAUwC,IACC,IAAjBsH,EAAMjG,QAAc,CACtB,IAAMmF,EAAcc,EAAME,QAC1BlQ,KAAKmP,UAAUD,GACf,IAAME,EAAeF,EAAYhL,KAAKD,MACtC,GAAGjE,KAAK+N,UAAUsB,OAAOD,EAAczG,GACnC,OAAO+E,EAAgBwB,GALL,oBAOAlP,KAAK+N,UAAUuB,UAAUF,IAPzB,IAOtB,IAAI,EAAJ,qBAA8D,CAAC,IAArDG,EAAoD,QACpDE,EAAcvJ,EAAUqJ,EAAStL,OACvC,IAAIgM,EAAQN,IAAIF,GAAc,CAC1B,IAAMG,EAAe,IAAIzB,EAAKoB,GAC9BL,EAAYW,SAASD,GACrBI,EAAMnL,KAAK+K,GACXK,EAAQjB,IAAIS,KAbE,+BAiB1B,MAAO,O,GAjCa3B,GCFtBK,EAKF,WAAYvI,GAAU,yBAHtBuK,KAAuB,KAGF,KAFrBvK,UAEqB,EACjB5F,KAAK4F,KAAOA,GAyCLwK,E,iDAhCHvN,IAAsB,K,KACtB8D,KAAe,E,wCAEvB,WACI,OAAmB,MAAZ3G,KAAK6C,IAAc7C,KAAK6C,IAAI+C,UAAOF,I,kBAG9C,SAAKpD,GACD,IAAI2L,EAAO,IAAIE,EAAK7L,GACpB2L,EAAKkC,KAAOnQ,KAAK6C,IACjB7C,KAAK6C,IAAMoL,EACXjO,KAAK2G,S,iBAGT,WACI,IAAI9D,EAAM7C,KAAK+M,OAKf,OAJe,MAAZ/M,KAAK6C,MACJ7C,KAAK6C,IAAM7C,KAAK6C,IAAIsN,KACpBnQ,KAAK2G,QAEF9D,I,qBAGX,WACI,OAAqB,IAAd7C,KAAK2G,O,qBAGhB,WACI,OAAO3G,KAAK2G,S,KCDL0J,E,8JA9BX,SAAS3H,EAAgBC,GACrB3I,KAAK0O,oBACL,IAAI5F,EAAO9I,KAAK+N,UAAUY,UACtBI,EAAO,IAAIZ,EAAKrF,EAAK3C,IAAIuC,IACvB4H,EAAQ,IAAIF,EAClBE,EAAMzL,KAAKkK,GACX,IAAMkB,EAAU,IAAI1D,EAEpB,IADA0D,EAAQjB,IAAI9I,EAAUwC,KACf4H,EAAMrB,WAAW,CACpB,IAAMC,EAAcoB,EAAMrD,MAC1BjN,KAAKmP,UAAUD,GACf,IAAME,EAAeF,EAAYhL,KAAKD,MACtC,GAAGjE,KAAK+N,UAAUsB,OAAOD,EAAczG,GACnC,OAAO+E,EAAgBwB,GAE3B,IAPoB,EAOhBI,EAAYtP,KAAK+N,UAAUuB,UAAUF,GAAcvB,UAPnC,cAQEyB,GARF,IAQpB,IAAI,EAAJ,qBAAgC,CAAC,IAAvBC,EAAsB,QACxBE,EAAcvJ,EAAUqJ,EAAStL,OACrC,IAAIgM,EAAQN,IAAIF,GAAc,CAC1B,IAAMG,EAAe,IAAIzB,EAAKoB,GAC9BL,EAAYW,SAASD,GACrBU,EAAMzL,KAAK+K,GACXK,EAAQjB,IAAIS,KAdA,+BAkBxB,MAAO,O,GAnCa3B,GC0HbyC,E,kDApHX,WAAYxC,EAAsBS,GAAuB,IAAD,8BACpD,cAAMT,IAHOU,UAA2B,SAACjD,EAAUC,GAAX,OAAwBI,EAAUL,EAAEC,SAIhE/F,IAAT8I,IACC,EAAKC,UAAYD,GAH+B,E,4CAaxD,SAAS9F,EAAgBC,GACrB3I,KAAK0O,oBACL,IAAM5F,EAAO9I,KAAK+N,UAAUY,UACtB6B,EAAe,IAAI9D,GACrB,SAAClB,EAAGC,GAAJ,OAAUD,EAAEqD,IAAMpD,EAAEoD,OAElB4B,EAAiB,IAAIhE,EACrBiE,EAAa,IAAIhE,GACnB,SAAClB,EAAGC,GAAJ,OAAUD,EAAEqD,IAAMpD,EAAEoD,OAElB8B,EAAe,IAAIlE,EACnBmE,EAAc,IAAIxC,EACpBtF,EAAK3C,IAAIuC,GAAU,EAAG,GAE1B8H,EAAa3L,KAAK+L,GAClBH,EAAezB,IAAI9I,EAAUwC,GAAUkI,GACvC,IAAMC,EAAW,IAAIzC,EACjBtF,EAAK3C,IAAIwC,GAAO,EAAG,GAIvB,IAFA+H,EAAW7L,KAAKgM,GAChBF,EAAa3B,IAAI9I,EAAUyC,GAAOkI,IAC1BL,EAAavB,YAAcyB,EAAWzB,WAAW,CAErD,IAAM6B,EAAmBN,EAAavD,MACtCjN,KAAKmP,UAAU2B,GACf,IAAMC,EAAoBD,EAAiB5M,KAAKD,MAC1C+M,EAAuB9K,EAAU6K,GACvC,GAAGJ,EAAahB,IAAIqB,GAChB,OAA8B,MAA3BF,EAAiB1D,OACTM,EACHoD,EAAiB1D,QACnB6D,OAAOrD,EACL+C,EAAaxK,IAAI6K,KAClBC,OACCnI,EAAK3C,IAAIwC,IAGN,CAACG,EAAK3C,IAAIwC,IAhB4B,oBAmB9B3I,KAAK+N,UAAUuB,UAAUyB,IAnBK,IAmBrD,2BAAoE,CAAC,IAA1DxB,EAAyD,QAC1DC,EAAgBD,EAAStL,MACzBwL,EAAcvJ,EAAUsJ,GACxBnB,EAAIyC,EAAiBzC,EAAIrO,KAAK0P,SAASqB,EAAmBvB,GAC1DX,EAAIR,EAAIrO,KAAKyO,UAAUe,EAAe7G,GAC5C,IAAK8H,EAAed,IAAIF,IAAgBZ,EAAI4B,EAAetK,IAAIsJ,GAAcZ,IAAK,CAC9E,IAAMe,EAAe,IAAIxB,EACrBmB,EAAUlB,EAAGQ,GAEjBiC,EAAiBjB,SAASD,GAC1BY,EAAa3L,KAAK+K,GAClBa,EAAezB,IAAIS,EAAaG,KA9Ba,8BAkCrD,IAAMsB,EAAiBR,EAAWzD,MAClCjN,KAAKmP,UAAU+B,GACf,IAAMC,EAAkBD,EAAehN,KAAKD,MACtCmN,EAAqBlL,EAAUiL,GACrC,GAAGV,EAAed,IAAIyB,GAClB,OAA4B,MAAzBF,EAAe9D,OACPM,EACH+C,EAAetK,IAAIiL,IACrBH,OAAOrD,EACLsD,EAAe9D,SAChB6D,OACCnI,EAAK3C,IAAIwC,IAGN,CAACG,EAAK3C,IAAIwC,IAhD4B,oBAoD9B3I,KAAK+N,UAAUuB,UAAU6B,IApDK,IAoDrD,2BAAkE,CAAC,IAAxD5B,EAAuD,QACxDC,EAAgBD,EAAStL,MACzBwL,EAAcvJ,EAAUsJ,GACxBnB,EAAI6C,EAAe7C,EAAIrO,KAAK0P,SAASyB,EAAiB3B,GACtDX,EAAIR,EAAIrO,KAAKyO,UAAUe,EAAe9G,GAC5C,IAAKiI,EAAahB,IAAIF,IAAgBZ,EAAI8B,EAAaxK,IAAIsJ,GAAcZ,IAAK,CAC1E,IAAMe,EAAe,IAAIxB,EACrBmB,EAAUlB,EAAGQ,GAEjBqC,EAAerB,SAASD,GACxBc,EAAW7L,KAAK+K,GAChBe,EAAa3B,IAAIS,EAAaG,KA/De,+BAmEzD,MAAO,K,sBAUX,SAASR,EAAqBI,GAC1B,OAAOxP,KAAK+N,UAAU+B,KAAKV,EAAcI,O,GApHjB1B,GC8EjBuD,E,8JAzEX,SAAS3I,EAAgBC,GACrB3I,KAAK0O,oBACL,IAAM5F,EAAO9I,KAAK+N,UAAUY,UACtB2C,EAAe,IAAI7E,EACnB8E,EAAa,IAAI9E,EACjB+E,EAAqB,GACrBC,EAAmB,GACnBb,EAAc,IAAIzC,EAAKrF,EAAK3C,IAAIuC,IACtC8I,EAAW3M,KAAK+L,GAChBU,EAAatC,IAAI9I,EAAUwC,GAAUkI,GACrC,IAAMC,EAAW,IAAI1C,EAAKrF,EAAK3C,IAAIwC,IAGnC,IAFA8I,EAAS5M,KAAKgM,GACdU,EAAWvC,IAAI9I,EAAUyC,GAAOkI,GACJ,IAAtBW,EAAWzH,QAAoC,IAApB0H,EAAS1H,QAAc,CAEpD,IAAM+G,EAAmBU,EAAWtB,QACpClQ,KAAKmP,UAAU2B,GACf,IAAMC,EAAoBD,EAAiB5M,KAAKD,MAC1C+M,EAAuB9K,EAAU6K,GACvC,GAAGQ,EAAW5B,IAAIqB,GACd,OAA8B,MAA3BF,EAAiB1D,OACTM,EACHoD,EAAiB1D,QACnB6D,OAAOrD,EACL2D,EAAWpL,IAAI6K,KAChBC,OACCnI,EAAK3C,IAAIwC,IAGN,CAACG,EAAK3C,IAAIwC,IAhB2B,oBAmB9B3I,KAAK+N,UAAUuB,UAAUyB,IAnBK,IAmBpD,IAAI,EAAJ,qBAAmE,CAAC,IAA1DxB,EAAyD,QACzDE,EAAcvJ,EAAUqJ,EAAStL,OACvC,IAAIqN,EAAa3B,IAAIF,GAAc,CAC/B,IAAMG,EAAe,IAAIzB,EAAKoB,GAC9BuB,EAAiBjB,SAASD,GAC1B4B,EAAW3M,KAAK+K,GAChB0B,EAAatC,IAAIS,EAAaG,KAzBc,8BA6BpD,IAAMsB,EAAiBO,EAASvB,QAChClQ,KAAKmP,UAAU+B,GACf,IAAMC,EAAkBD,EAAehN,KAAKD,MACtCmN,EAAqBlL,EAAUiL,GACrC,GAAGG,EAAa3B,IAAIyB,GAChB,OAA4B,MAAzBF,EAAe9D,OACPM,EACH4D,EAAanL,IAAIiL,IACnBH,OAAOrD,EACLsD,EAAe9D,SAChB6D,OACCnI,EAAK3C,IAAIwC,IAGN,CAACG,EAAK3C,IAAIwC,IA3C2B,oBA8C9B3I,KAAK+N,UAAUuB,UAAU6B,IA9CK,IA8CpD,IAAI,EAAJ,qBAAiE,CAAC,IAAxD5B,EAAuD,QACvDE,EAAcvJ,EAAUqJ,EAAStL,OACvC,IAAIsN,EAAW5B,IAAIF,GAAc,CAC7B,IAAMG,EAAe,IAAIzB,EAAKoB,GAC9B2B,EAAerB,SAASD,GACxB6B,EAAS5M,KAAK+K,GACd2B,EAAWvC,IAAIS,EAAaG,KApDgB,+BAwDxD,MAAO,O,GA7Ee9B,GCQxB4D,EAAiE,CACnE,KAAQ,SAAC5I,GAAD,OAAgB,IAAI4C,EAAc5C,IAC1C,SAAY,SAACA,GAAD,OAAgB,IAAIoD,EAAkBpD,KAGhD6I,EAA2D,CAC7D,UAAa,kBAAM,SAACnG,EAAEC,GAAH,OZfhB,SAAmBD,EAAUC,GAGhC,OAFS9B,KAAKoC,IAAIP,EAAEpH,EAAIqH,EAAErH,GACjBuF,KAAKoC,IAAIP,EAAErH,EAAIsH,EAAEtH,GYaEyN,CAAUpG,EAAEC,KACxC,UAAa,kBAAM,SAACD,EAAEC,GAAH,OAASI,EAAUL,EAAEC,KACxC,UAAa,kBAAM,SAACD,EAAEC,GAAH,OZChB,SAAmBD,EAAUC,GAChC,IAAIK,EAAKnC,KAAKoC,IAAIP,EAAEpH,EAAIqH,EAAErH,GACtB4H,EAAKrC,KAAKoC,IAAIP,EAAErH,EAAIsH,EAAEtH,GAC1B,OAAOwF,KAAKkI,IAAI/F,EAAIE,GYJQ8F,CAAUtG,EAAEC,KACxC,OAAU,kBAAM,SAACD,EAAEC,GAAH,OZNb,SAAgBD,EAAUC,GAC7B,IAAIK,EAAKnC,KAAKoC,IAAIP,EAAEpH,EAAIqH,EAAErH,GACtB4H,EAAKrC,KAAKoC,IAAIP,EAAErH,EAAIsH,EAAEtH,GAC1B,OAAOwF,KAAKoI,MAAQpI,KAAKqI,IAAIlG,EAAIE,GAAMrC,KAAKoC,IAAID,EAAKE,GYG5BiG,CAAOzG,EAAEC,KAClC,KAAQ,kBAAM,SAACD,EAAEC,GAAH,OZMP,KYHLyG,EAAuG,CACzG,SAAY,SAACnE,GACT,OAAO,IAAIQ,EAAgBR,GAAW,SAACvC,EAAEC,GAAH,OZCnC,MYCP,aAAc,SAACsC,EAAWU,GACtB,OAAO,kKACH,SAASW,EAAqBI,GAC1B,OAAO,MAFR,GAA6BjB,GAA7B,CAIJR,EAAWU,IAElB,KAAM,SAACV,EAAWU,GACd,OAAO,IAAIF,EAAgBR,EAAWU,IAE1C,IAAO,SAACV,GACJ,OAAO,IAAIgC,EAAchC,IAE7B,IAAO,SAACA,GACJ,OAAO,IAAIsC,EAActC,IAE7B,QAAS,SAACA,EAAWU,GACjB,OAAO,IAAI8B,EAAkBxC,EAAWU,IAE5C,cAAe,SAACV,GACZ,OAAO,IAAIwC,EAAkBxC,GAAW,SAACvC,EAAEC,GAAH,OZrBrC,MYuBP,SAAU,SAACsC,GACP,OAAO,IAAIsD,EAAgBtD,KAoDpBoE,E,kGA9CX,SAAqBC,GACjB,MAAqB,OAAdA,GAAoC,UAAdA,GACX,eAAdA,I,8BAGR,SAAwBA,GACpB,OAA+C,MAAxCF,EAAkB,MAAQE,K,8BAGrC,SAAwBA,GACpB,MAAO,MAAQA,I,2BASnB,SAAqBrE,EAAsBqE,EAAmB3D,GAC1D,IACM4D,EAAkBV,QADWjM,IAAd+I,EAA0BA,EAAY,QACL6D,eACtD,GAAsB,MAAnBD,EACC,MAAM,IAAIE,MAAM,qCAEpB,IAAMC,EAAmBN,EAAkBE,EAAUE,eACrD,GAAuB,MAApBE,EACC,MAAM,IAAID,MAAM,wCAEpB,OAAOC,EAAiBzE,EAAWsE,O,0BAQvC,SAAoBvJ,EAAYzH,GAC5B,IAAMoR,EAAkBf,EAAiBrQ,EAAIiR,eAC7C,GAAsB,MAAnBG,EACC,MAAM,IAAIF,MAAM,oCAEpB,OAAOE,EAAgB3J,O,KC0K/B,SAAS4J,EAAYV,EAAaH,GAC9B,IAAMc,EAAQd,EAAMG,EACpB,GAAGW,GAAS,GACR,OAASX,EAAIH,GAAK,GAAM,EACrB,GAAGc,EAAQ,EAAG,CACjB,IAAMC,GAAQZ,EAAIH,GAAK,GAAM,EACvBgB,EAAS,CAACD,EAAKA,EAAI,GACzB,OAAOC,EAAOC,EAAQ,EAAED,EAAO9I,OAAO,IAEtC,OAAO+I,EAAQd,EAAI,EAAEH,EAAI,GAqBjC,SAASiB,EAAQd,EAAaH,GAC1B,OAAOlI,KAAKC,MAAMD,KAAKoJ,UAAYlB,EAAI,EAAEG,GAAOA,GAGrCgB,M,WAjSX,WAAYjO,EAAeG,GAAiB,yBAH3BH,WAG0B,OAF1BG,YAE0B,EACvClF,KAAK+E,MAAQA,EACb/E,KAAKkF,OAASA,E,gDAYlB,SAAa+N,EAAiBC,GAC1B,IAAMpK,EAAO,IAAIxD,EAAWtF,KAAK+E,MAAO/E,KAAKkF,aAC9BQ,IAAZuN,IACCA,EAAU,CACN7O,EAAG,EAAGD,EAAG,SAGEuB,IAAhBwN,IACCA,EAAc,CACV9O,EAAG0E,EAAK6C,WAAW,EACnBxH,EAAG2E,EAAK8C,YAAY,IAG5B,IAAI,IAAIxH,EAAI6O,EAAQ7O,EAAI,EAAGA,GAAK8O,EAAY9O,EAAI,EAAGA,IAC/C4O,EAAcG,KAAKrK,EAAK,CACpB7E,MAAO,CACHG,EAAGA,EAAGD,EAAG8O,EAAQ9O,EAAI,GAEzByB,KAAMT,GAAW,KAErB6N,EAAcG,KAAKrK,EAAK,CACpB7E,MAAO,CACHG,EAAGA,EAAGD,EAAG+O,EAAY/O,EAAI,GAE7ByB,KAAMT,GAAW,KAGzB,IAAI,IAAIhB,EAAI8O,EAAQ9O,EAAI,EAAGA,GAAK+O,EAAY/O,EAAI,EAAGA,IAC/C6O,EAAcG,KAAKrK,EAAK,CACpB7E,MAAO,CACHG,EAAG6O,EAAQ7O,EAAI,EAAGD,EAAGA,GAEzByB,KAAMT,GAAW,KAErB6N,EAAcG,KAAKrK,EAAK,CACpB7E,MAAO,CACHG,EAAG8O,EAAY9O,EAAI,EAAGD,EAAGA,GAE7ByB,KAAMT,GAAW,KAOzB,OAJAnF,KAAKoT,OAAOtK,EAAK,CACbmK,QAASA,EACTC,YAAaA,IAEVpK,I,oBA8BX,SAAOA,EAAYuK,GACf,IAAMtO,EAwJd,SAAiBsO,GACb,OAAOA,EAAQH,YAAY9O,EAAIiP,EAAQJ,QAAQ7O,EAAI,EAzJjCkP,CAAQD,GAChBnO,EA2Jd,SAAkBmO,GACd,OAAOA,EAAQH,YAAY/O,EAAIkP,EAAQJ,QAAQ9O,EAAI,EA5JhCoP,CAASF,GAClBrB,EAAMqB,EAAQJ,QACdpB,EAAMwB,EAAQH,YACpB,GAgJR,SAAqBnO,EAAeG,GAChC,OAAOH,GAASG,EAjJTsO,CAAYzO,EAAMG,IACjB,GAAGH,EA5GD,EA4GgB,CAUd,IARA,IAAM0O,EAAQX,EACVd,EAAI7N,EAAG0N,EAAI1N,GAETuP,EAAQhB,EACVV,EAAI5N,EAAGyN,EAAIzN,GAGTuP,EAAiB,GACfxP,EAAI6N,EAAI7N,EAAGA,GAAK0N,EAAI1N,EAAGA,IAC3BwP,EAAO9O,KAAK,CACRZ,MAAO,CACHG,EAAGsP,EAAOvP,EAAGA,GAEjByB,KAAMT,GAAW,KAIzB,IAAIyO,GAAc,EACd9K,EAAK3C,IAAI,CACT/B,EAAGsP,EAAOvP,EAAG6N,EAAI7N,EAAE,IACpByB,KAAKR,UACJuO,EAAO9O,KAAK,CACRZ,MAAO,CACHG,EAAGsP,EAAOvP,EAAG6N,EAAI7N,GAErByB,KAAMT,GAAW,KAErByO,GAAc,GAEd9K,EAAK3C,IAAI,CACT/B,EAAGsP,EAAOvP,EAAG0N,EAAI1N,EAAE,IACpByB,KAAKR,UACJuO,EAAO9O,KAAK,CACRZ,MAAO,CACHG,EAAGsP,EAAOvP,EAAG0N,EAAI1N,GAErByB,KAAMT,GAAW,KAErByO,GAAc,GAEdA,GACAD,EAAO9O,KAAK,CACRZ,MAAO,CACHG,EAAGsP,EAAOvP,EAAGsP,GAEjB7N,KAAMT,GAAW,KAGzB6N,EAAca,QAAQ/K,EAAM6K,GAE5B,IAAMG,EAAc,CAChBb,QAASI,EAAQJ,QACjBC,YAAa,CACT9O,EAAGsP,EAAM,EACTvP,EAAGkP,EAAQH,YAAY/O,IAGzB4P,EAAe,CACjBd,QAAS,CACL7O,EAAGsP,EAAM,EACTvP,EAAGkP,EAAQJ,QAAQ9O,GAEvB+O,YAAaG,EAAQH,aAEzBlT,KAAKoT,OAAOtK,EAAMgL,GAClB9T,KAAKoT,OAAOtK,EAAMiL,SAGtB,GAAG7O,EAlLD,EAkLiB,CAUf,IARA,IAAMwO,EAAQZ,EACVd,EAAI5N,EAAGyN,EAAIzN,GAETqP,EAAQf,EACVV,EAAI7N,EAAG0N,EAAI1N,GAGTwP,EAAiB,GACfvP,EAAI4N,EAAI5N,EAAGA,GAAKyN,EAAIzN,EAAGA,IAC3BuP,EAAO9O,KAAK,CACRZ,MAAO,CACHG,EAAGA,EAAGD,EAAGsP,GAEb7N,KAAMT,GAAW,KAIzB,IAAIyO,GAAc,EACd9K,EAAK3C,IAAI,CACT/B,EAAG4N,EAAI5N,EAAE,EAAGD,EAAGsP,IAChB7N,KAAKR,UACJuO,EAAO9O,KAAK,CACRZ,MAAO,CACHG,EAAG4N,EAAI5N,EAAGD,EAAGsP,GAEjB7N,KAAMT,GAAW,KAErByO,GAAc,GAEd9K,EAAK3C,IAAI,CACT/B,EAAGyN,EAAIzN,EAAE,EAAGD,EAAGsP,IAChB7N,KAAKR,UACJuO,EAAO9O,KAAK,CACRZ,MAAO,CACHG,EAAGyN,EAAIzN,EAAGD,EAAGsP,GAEjB7N,KAAMT,GAAW,KAErByO,GAAc,GAEdA,GACAD,EAAO9O,KAAK,CACRZ,MAAO,CACHG,EAAGsP,EAAOvP,EAAGsP,GAEjB7N,KAAMT,GAAW,KAGzB6N,EAAca,QAAQ/K,EAAM6K,GAE5B,IAAMK,EAAa,CACff,QAASI,EAAQJ,QACjBC,YAAa,CACT9O,EAAGiP,EAAQH,YAAY9O,EACvBD,EAAGsP,EAAM,IAGXQ,EAAgB,CAClBhB,QAAS,CACL7O,EAAGiP,EAAQJ,QAAQ7O,EACnBD,EAAGsP,EAAM,GAEbP,YAAaG,EAAQH,aAEzBlT,KAAKoT,OAAOtK,EAAMkL,GAClBhU,KAAKoT,OAAOtK,EAAMmL,O,sBArK9B,SAAuBnL,EAAYrE,GAAgB,IAAD,gBAC9BA,GAD8B,IAC9C,IAAI,EAAJ,qBAAuB,CAAC,IAAhBP,EAAe,QACnB8O,EAAcG,KAAKrK,EAAM5E,IAFiB,iC,kBAWlD,SAAoB4E,EAAY5E,GAC5B4E,EAAKoL,WAAWhQ,O,KCqKxB,SAASiQ,EAAW3K,GAEhB,IADA,IAAI4K,EAAM,EACD5N,EAAI,EAAGA,EAAIgD,EAAKO,OAAS,EAAGvD,IACjC4N,GAAOvI,EAAUrC,EAAKhD,GAAGvC,MAAOuF,EAAKhD,EAAI,GAAGvC,OAEhD,OAASmQ,EAAKC,QAAQ,GAQXC,O,kDA9OX,WAAY1U,GAAgB,IAAD,uBACvB,cAAMA,IARF2U,WAAwC/U,IAAMC,YAO3B,EANnB+U,WAAwChV,IAAMC,YAM3B,EAJnBgV,YAAa,EAIM,EAHnBC,aAAc,EAGK,EAFnBC,eAAoC,GAEjB,EAe3BC,cAAgB,WACZ,IAAMC,EAAW,EAAKjV,MAAMiV,SACtBC,EAAa,EAAKC,cAAcF,GAChCrL,EAAO,EAAKwL,SAASF,GAC3B,GAAGD,EAASI,aAAc,CACtB,IAAMtP,EAAgB,GACtBmP,EAAWI,qBAAoB,SAACjH,GAC5BtI,EAAMd,KAAKoJ,MAEf,EAAK3J,qBAAqBqB,GAE9B,EAAK4D,SAASC,IA1BS,EAiC3B2L,qBAAuB,WACnB,EAAKC,qBACL,EAAKC,YACL,IAAMR,EAAW,EAAKjV,MAAMiV,SAC5B,EAAKJ,YAAa,EAClB,IAAMD,EAAa,EAAKA,WAAW1U,QAEnC,GADA0U,EAAWc,gBACP,EAAKZ,YAgCF,CACH,IAAK,IAAIlO,EAAI,EAAGA,EAAI,EAAKmO,eAAe5K,OAAQvD,IAC5C+O,aAAa,EAAKZ,eAAenO,IAErC,EAAKkO,aAAc,EACnB,EAAK9U,MAAM4V,oBAAoB,EAAKd,iBArClB,CAClB,EAAKA,aAAc,EACnB,EAAK9U,MAAM4V,oBAAoB,EAAKd,aACpC,IAAMI,EAAa,EAAKC,cAAcF,GAChCrL,EAAO,EAAKwL,SAASF,GACrBW,EAAYZ,EAASa,SACrBC,EAAsC,GAC5C,EAAKhB,eAAiB,GACtB,IAAIiB,EAAQ,EACTf,EAASI,cAERH,EAAWI,qBAAoB,SAACjH,GAC5B,IAAM4H,EAAU,IAAIC,SAAwB,SAACC,GAEzC,IAAMC,EAAUvP,YAAW,WACvB,EAAKpC,oBAAoB4J,GACzB8H,EAAQC,KACTJ,GACH,EAAKjB,eAAe9P,KAAKmR,GACzBJ,GAASH,KAEbE,EAAS9Q,KAAKgR,MAItBC,QAAQG,IAAIN,GAAUO,MAAK,WACvB,EAAK3M,SAASC,GACdgL,EAAWc,gBACX,EAAKZ,aAAc,EACnB,EAAKD,YAAa,EAClB,EAAK7U,MAAM4V,oBAAoB,EAAKd,kBAtErB,EAqFnBK,cAAgB,SAACF,GACrB,IAAMsB,EAAetB,EAASzC,UACxBA,EAAYyC,EAASuB,eAAiBjE,EAAkBkE,iBAAiBF,GAC3EhE,EAAkBmE,iBAAiBH,GAAgBA,EACjDpI,EAAYoE,EAAkBoE,aAAa,EAAK/B,WAAW1U,QAASoB,MAAM4H,KAAM+L,EAAS2B,cAC/F,OAAOrE,EAAkB4C,cAAchH,EAAWqE,EAAWyC,EAAS4B,eA1F/C,EAiGnBzB,SAAW,SAACF,GAChB,IAAMN,EAAa,EAAKA,WAAW1U,QAC7B4W,EAAKC,YAAYC,MACjBpN,EAAOsL,EAAWE,SAASR,EAAWtT,MAAMwH,QAAS8L,EAAWtT,MAAMyH,MAEtEkO,IADKF,YAAYC,MACLF,GAAIrC,QAAQ,GAI9B,OAHA,EAAKzT,SAAS,CACVkW,KAAMD,IAEHrN,GA1GgB,EAiHnBD,SAAW,SAACC,GAChB,IAAMgL,EAAa,EAAKA,WAAW1U,QACnC0J,EAAKuN,QAAQ,EAAKvC,WAAW1U,QAASoB,MAAM4H,KAAK3C,IAAIqO,EAAWtT,MAAMwH,UACtE,EAAK8L,WAAW1U,QAASyJ,SAASC,GAClC,EAAK5I,SAAS,CACVmJ,OAAQoK,EAAW3K,MAtHA,EA6HnBR,eAAiB,WAClB,EAAKyL,aACJ,EAAKW,qBACL,EAAKR,gBACL,EAAKH,YAAa,IAjIC,EAwI3BuC,WAAa,WACT,IAAG,EAAKtC,YAAR,CAGA,EAAKrL,aACL,EAAKgM,YACL,EAAKD,qBACL,IAAM6B,EAAW,EAAKzC,WAAW1U,QAASoB,MAAM4H,KAC1CoO,EAAY,IAAIlE,EAAciE,EAAStL,WAAYsL,EAASrL,aAC5DlB,EAAM,EAAKC,qBAIXuI,EAAc,CAChB9O,EAAGsG,EAAItG,EAAE,EAAGD,EAAGuG,EAAIvG,EAAE,GAEnB2E,EAAOoO,EAAUC,aANP,CACZ/S,EAAG,EAAGD,EAAG,GAKgC+O,GAC7C,EAAKsB,WAAW1U,QAASoJ,SAASJ,GAClC,EAAKsO,aAAa,CACdhT,EAAGsG,EAAItG,EAAE,EACTD,EAAGuG,EAAIvG,EAAE,MA5JU,EAmLnBiT,aAAe,SAACC,GACpB,EAAK7C,WAAW1U,QAASiJ,YAAY,CACjC3E,EAAG,EAAGD,EAAE,IAEZ,EAAKqQ,WAAW1U,QAASmJ,SAASoO,IAvLX,EA0L3BhC,UAAY,WACR,EAAKb,WAAW1U,QAAS4J,aA3LF,EA8L3BL,WAAa,WACT,EAAKmL,WAAW1U,QAASuJ,cA/LF,EAkM3B+L,mBAAqB,WACjB,EAAKX,YAAa,EAClB,EAAKF,WAAWzU,QAAS+D,SApMF,EAuMnBS,qBAAuB,SAACC,GAC5B,EAAKgQ,WAAWzU,QAASwE,qBAAqBC,GAC9C,EAAKkQ,YAAa,GAzMK,EA4MnBpQ,oBAAsB,SAACL,GAC3B,EAAKuQ,WAAWzU,QAASuE,oBAAoBL,IA3M7C,IAAMY,EAAS+E,KAAKC,MAAMlK,OAAO4X,OAAOC,WAAa,EAAK3X,MAAMoF,WAAa,EACvEN,EAASiF,KAAKC,OAAOlK,OAAO4X,OAAOE,YAAc,GAAK,IAAM,EAAK5X,MAAMoF,WAAa,EAHnE,OAIvB,EAAK9D,MAAQ,CACT0D,OAAQA,EACRF,OAAQA,EACRoS,KAAM,EACN/M,OAAQ,GARW,E,sDAmK3B,WACI,IAAM0N,EAAO/X,OAAOyD,WAAanD,KAAKJ,MAAMoF,UACtC0S,GAAQhY,OAAOwD,YAAclD,KAAKJ,MAAMiL,UAAY,IAAM7K,KAAKJ,MAAMoF,UACrE2S,EAAShO,KAAKC,MAAM6N,GACpBG,EAASjO,KAAKC,MAAM8N,GAEpBG,EAAWH,EAAOE,EACxB,MAAO,CACHxT,EAHaqT,EAAOE,EAGN,IAAOhO,KAAKmO,KAAKL,GAAQE,EACvCxT,EAAG0T,EAAW,IAAOlO,KAAKmO,KAAKJ,GAAQE,K,oBAoC/C,WACI,OACI,gCACI,sBAAKG,GAAG,cAAc7X,UAAU,cAAhC,UACI,sBAAKA,UAAU,YAAf,qBAAoCF,KAAKkB,MAAM6I,UAC/C,sBAAK7J,UAAU,YAAf,mBAAkCF,KAAKkB,MAAM4V,KAA7C,YAEJ,cAAC,EAAD,CAAgB7W,IAAKD,KAAKuU,WAAYvP,UAAWhF,KAAKJ,MAAMoF,UAC5CJ,OAAQ5E,KAAKkB,MAAM0D,OAAQF,OAAQ1E,KAAKkB,MAAMwD,SAC9D,cAAC,EAAD,CAAgBzE,IAAKD,KAAKwU,WAAY3J,UAAW7K,KAAKJ,MAAMiL,UAC5C7B,eAAgBhJ,KAAKgJ,eAAgBhE,UAAWhF,KAAKJ,MAAMoF,UAC3DJ,OAAQ5E,KAAKkB,MAAM0D,OAAQF,OAAQ1E,KAAKkB,MAAMwD,gB,GArO1ClF,IAAMY,WCZpC4X,G,kDAMF,WAAYpY,GAAgB,IAAD,8BACvB,cAAMA,IASVwB,SAAW,WACP,EAAKR,UAAS,SAAAqX,GAAS,MAAK,CACxBC,SAAUD,EAAUC,YACpB,kBAAM,EAAKtY,MAAMwB,SAAS,EAAKF,MAAMgX,aAXzC,EAAKhX,MAAQ,CACTgX,QAAS,EAAKtY,MAAMuY,gBAHD,E,0CAgB3B,WACI,OACI,gCACI,uBAAOD,QAASlY,KAAKkB,MAAMgX,QAASE,KAAK,WAAWC,SAAUrY,KAAKJ,MAAMyY,SAClEnY,UAAWF,KAAKJ,MAAM0Y,SAAUlX,SAAUpB,KAAKoB,WAGrDpB,KAAKJ,MAAMO,gB,GA7BLX,IAAMY,WAAvB4X,GAEYO,aAAe,CACzBF,UAAU,GAgCHL,UCdAQ,G,4MAjBXpX,SAAW,SAACkB,GACR,EAAK1C,MAAMwB,SAASqX,OAAOnW,EAAEoW,cAAcC,S,4CAG/C,WACI,OACI,uBAAOP,KAAK,QAAQQ,KAAK,YAClBC,aAAc7Y,KAAKJ,MAAMkZ,QACzB9G,IAAKhS,KAAKJ,MAAMoS,IAAKH,IAAK7R,KAAKJ,MAAMiS,IACrCkH,KAAM/Y,KAAKJ,MAAMmZ,KAAM7Y,UAAWF,KAAKJ,MAAMoZ,YAC7C5X,SAAUpB,KAAKoB,e,GAhBD5B,IAAMY,WCEjC6Y,G,kDAMF,WAAYrZ,GAAgB,IAAD,uBACvB,cAAMA,IAgBFwB,SAAW,SAAC8X,GAEhB,IADA,IAAMhB,EAAqB,GACnB1R,EAAI,EAAGA,EAAI,EAAK5G,MAAMwB,SAAS2I,OAAQvD,IAC3C0R,EAAQrT,KAAK2B,IAAM0S,GAEvB,EAAKtY,SAAS,CACVsX,QAASA,IACV,kBAAM,EAAKtY,MAAMwB,SAAS8X,SArB7B,IADA,IAAMhB,EAAqB,GACnB1R,EAAI,EAAGA,EAAI,EAAK5G,MAAMwB,SAAS2I,OAAQvD,IAC3C0R,EAAQrT,KAAK2B,IAAM,EAAK5G,MAAMuY,gBAJX,OAMvB,EAAKjX,MAAQ,CACTgX,QAASA,GAPU,E,0CA2B3B,WAGI,IAHM,IAAD,OACC/X,EAAWX,IAAM2Z,SAASC,QAAQpZ,KAAKJ,MAAMO,UAC7CkZ,EAA8B,GAF/B,WAGG7S,GACJ6S,EAAaxU,KACT,gCACI,uBAAOqT,QAAS,EAAKhX,MAAMgX,QAAQ1R,GAAI4R,KAAK,QAAQC,SAAU,EAAKzY,MAAMyY,SAClEnY,UAAW,EAAKN,MAAM0Y,SAAUlX,SAAU,kBAAM,EAAKA,SAASoF,MAGpErG,EAASqG,KALJA,KAFVA,EAAI,EAAGA,EAAIxG,KAAKJ,MAAMwB,SAAS2I,OAAQvD,IAAM,EAA7CA,GAWR,OAAO6S,M,GA/CgB7Z,IAAMY,WAA/B6Y,GAEYV,aAAe,CACzBF,UAAU,GAgDHY,UCvDFK,GAAb,4JAEI,WACI,OACI,gCACI,qBAAKpZ,UAAU,0BAAf,qCACA,cAAC,GAAD,CAAUiY,gBAAgB,EAAMG,SAAS,MAC/BlX,SAAUpB,KAAKJ,MAAM2Z,YAD/B,uCANhB,GAAoC/Z,IAAMY,WAuB7BoZ,GAAb,kDAEI,WAAY5Z,GAAoB,IAAD,8BAC3B,cAAMA,IAWV6Z,cAAgB,SAACd,GAEb,EAAK/X,SAAS,CACV8Y,UAFe,CAAC,UAAW,SAAU,SAAU,SAAU,WAEnCf,EAAM,KAEhC,EAAK/Y,MAAMwB,SAASuX,IAfpB,EAAKzX,MAAQ,CACTwY,UAAW,UAHY,EAFnC,0CAsBI,WACI,OACI,sBAAKxZ,UAAU,mBAAf,UACI,sBAAKA,UAAU,cAAf,oBACW,sBAAKA,UAAU,aAAf,cAA8BF,KAAKkB,MAAMwY,UAAzC,UAEX,cAAC,GAAD,CAAoB1H,IAAK,EAAGH,IAAK,EAAGkH,KAAM,EAAGD,QAAS,EAClCE,YAAY,sBACZ5X,SAAUpB,KAAKyZ,gBAEnC,2BAAU1B,GAAG,YAAb,UACI,uCACA,uCACA,uCACA,uCACA,iDArCpB,GAAmCvY,IAAMY,WAkD5BuZ,GAAb,kDAEI,WAAY/Z,GAAwB,IAAD,8BAC/B,cAAMA,IACDsB,MAAQ,CACTmX,UAAU,GAHiB,EAFvC,0CASI,WACI,OACI,gCACI,qBAAKnY,UAAU,0BAAf,uBACA,cAAC,GAAD,CAAUiY,gBAAgB,EAAMG,SAAS,MAC/BlX,SAAUpB,KAAKJ,MAAMga,kBAD/B,6BAIA,cAAC,GAAD,CAAUzB,gBAAgB,EAAOG,SAAS,MAChCD,SAAUrY,KAAKJ,MAAMyY,SACrBjX,SAAUpB,KAAKJ,MAAMia,sBAF/B,kCAjBhB,GAAuCra,IAAMY,WAmChC0Z,GAAb,kDAEI,WAAYla,GAAwB,IAAD,8BAC/B,cAAMA,IAMV6H,QAAU,WACN,EAAK7G,SAAS,CACVyX,UAAU,KATiB,EAanC0B,OAAS,WACL,EAAKnZ,SAAS,CACVyX,UAAU,KAbd,EAAKnX,MAAQ,CACTmX,UAAU,GAHiB,EAFvC,0CAqBI,WACI,OACI,gCACI,qBAAKnY,UAAU,0BAAf,uBACA,cAAC,GAAD,CAAkBoY,SAAS,MACTH,eAAgB,EAChBE,SAAUrY,KAAKJ,MAAMyY,SACrBjX,SAAU,CACNpB,KAAKJ,MAAMoa,iBAAkBha,KAAKJ,MAAMqa,iBACxCja,KAAKJ,MAAMsa,iBAAkBla,KAAKJ,MAAMua,eAL9D,SAQK,CAAC,4CAAU,aAA8B,4CAAU,aAChD,4CAAU,aAA8B,yCAAU,qBAlC1E,GAAuC3a,IAAMY,W,ICzE9Bga,G,iDAxCXvF,SCaO,CACHI,cAAc,EACdS,SAjBc,EAkBdtD,UAAW,KACXqE,aAAc,YACdD,aAAc,WACdJ,eAAe,G,KDjBnBiE,WAAa,SAACC,GACV,EAAKzF,SAASzC,UAAYkI,G,KAG9BC,gBAAkB,WACd,EAAK1F,SAASI,cAAgB,EAAKJ,SAASI,c,KAGhDuF,oBAAsB,WAClB,EAAK3F,SAASuB,eAAiB,EAAKvB,SAASuB,e,KAGjDqE,gBAAkB,SAACvC,GACf,EAAKrD,SAAS2B,aAAe0B,EAAU,WAAa,Q,KAGxDwC,YAAc,SAAC/B,GACX,IAAMgC,EAAS,CCvBA,GACD,GACA,EACA,EACC,GDoBf,EAAK9F,SAASa,SAAWiF,EAAOhC,EAAM,I,KAG1CiC,gBAAkB,WACd,EAAK/F,SAAS4B,aAAe,a,KAGjCoE,gBAAkB,WACd,EAAKhG,SAAS4B,aAAe,a,KAGjCqE,gBAAkB,WACd,EAAKjG,SAAS4B,aAAe,a,KAGjCsE,aAAe,WACX,EAAKlG,SAAS4B,aAAe,WE0GtBuE,O,kDApHX,WAAYpb,GAAgB,IAAD,8BACvB,cAAMA,IALFkJ,KAAyCtJ,IAAMC,YAI5B,EAFnBwb,gBAAmC,IAAIb,GAEpB,EAa3Bc,mBAAqB,SAACxG,GAClB,IAAMpU,EAAQoU,EAAc,aAAe,eAC3C,EAAK9T,SAAS,CACVua,aAAc7a,KAhBK,EAoB3B8a,eAAiB,WACb,EAAKxa,UAAS,SAAAqX,GAAS,MAAK,CACxBoD,WAAYpD,EAAUoD,eAtBH,EA0B3BC,aAAe,WACX,EAAK1a,SAAS,CACVya,WAAW,KA5BQ,EAgC3BhB,WAAa,SAACjI,GACV,EAAKxR,SAAS,CACV2a,WAAYpJ,EAAkBqJ,cAAcpJ,GAC5CqJ,WAAYtJ,EAAkBkE,iBAAiBjE,KAEnD,EAAK6I,gBAAgBZ,WAAWjI,IArCT,EAwC3BwC,cAAgB,WACZ,EAAK9L,KAAKhJ,QAASqV,wBAzCI,EA4C3BE,UAAY,WACR,EAAKvM,KAAKhJ,QAASuV,YACnB,EAAKvM,KAAKhJ,QAASsV,sBA9CI,EAiD3B/L,WAAa,WACT,EAAKgM,YACL,EAAKvM,KAAKhJ,QAASuJ,cAnDI,EAsD3B2N,WAAa,WACT,EAAKlO,KAAKhJ,QAASkX,cAvDI,EA0D3B0E,UAAY,SAACtH,GACT,EAAKxT,SAAS,CACVmJ,OAAQqK,KA5DW,EAgE3BuH,QAAU,SAAC7E,GACP,EAAKlW,SAAS,CACVkW,KAAMA,KAlEa,EAsE3BjX,eAAiB,SAACqF,GACd,EAAKtE,SAAS,CACViK,UAAW3F,KAtEf,EAAKhE,MAAQ,CACT6I,OAAQ,EACR+M,KAAM,EACNyE,WAAW,EACXE,WAAW,EACXJ,WAAW,EACXxQ,UAAW,GACXsQ,aAAc,gBATK,E,0CA4E3B,WACI,IAAMnW,EAoCH,+EAA+E4W,KAAK7N,UAAU8N,WApClE,GAAK,GACpC,OACI,gCACI,eAAC,EAAD,CAAgBlb,KAAMX,KAAKkB,MAAMma,UAAW5X,eAAgBzD,KAAKsb,aAAjE,UACI,cAAC,GAAD,CAAgB/B,YAAavZ,KAAKib,gBAAgBV,kBAClD,cAAC,GAAD,CAAenZ,SAAUpB,KAAKib,gBAAgBP,cAC9C,cAAC,GAAD,CAAmBrC,SAAUrY,KAAKkB,MAAMua,UACrB5B,sBAAuB7Z,KAAKib,gBAAgBT,oBAC5CZ,kBAAmB5Z,KAAKib,gBAAgBR,kBAC3D,cAAC,GAAD,CAAmBpC,SAAUrY,KAAKkB,MAAMqa,UACrBvB,iBAAkBha,KAAKib,gBAAgBL,gBACvCX,iBAAkBja,KAAKib,gBAAgBJ,gBACvCX,iBAAkBla,KAAKib,gBAAgBH,gBACvCX,cAAena,KAAKib,gBAAgBF,kBAE3D,eAAC,EAAD,CAAQlb,eAAgBG,KAAKH,eAA7B,UACI,mBAAGic,KAAK,oDAAoD5b,UAAU,QAAtE,oCAGA,sBAAKA,UAAU,gBAAf,UACI,cAAC,EAAD,CAAmBkB,SAAUpB,KAAKqa,aAClC,cAAC,EAAD,CAAiB/Z,MAAON,KAAKkB,MAAMia,aAAc5a,QAASP,KAAK4U,gBAC/D,cAAC,EAAD,CAAe/S,aAAc7B,KAAKqJ,WACnBzH,YAAa5B,KAAKqV,YACjC,cAAC,EAAD,CAAgB9U,QAASP,KAAKob,iBAC9B,cAAC,EAAD,CAAY7a,QAASP,KAAKgX,mBAGlC,cAAC,GAAD,CAAuB/W,IAAKD,KAAK8I,KAAM0M,oBAAqBxV,KAAKkb,mBAAoBrQ,UAAW7K,KAAKkB,MAAM2J,UACpFgK,SAAU7U,KAAKib,gBAAgBpG,SAAU7P,UAAWA,W,GAjH9DxF,IAAMY,WCXpB2b,G,4JAPX,WACI,OACI,cAAC,GAAD,Q,GAJMvc,IAAMY,WCWT4b,GAZS,SAACC,GACnBA,GACF,6BAAqB/F,MAAK,YAAkD,IAA/CgG,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOD,GACPE,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAQL,OCHdM,IAASC,OACL,cAAC,IAAMC,WAAP,UACI,cAAC,GAAD,MAEJ/Y,SAASgZ,eAAe,SAG5BV,O","file":"static/js/main.3c910202.chunk.js","sourcesContent":["import React, {RefObject} from 'react';\r\n\r\ninterface IProps {\r\n    onChangeHeight: (height: number) => void\r\n}\r\n\r\nclass TopBar extends React.Component<IProps>\r\n{\r\n    private bar: RefObject<HTMLDivElement> = React.createRef();\r\n\r\n    componentDidMount() {\r\n        window.addEventListener('resize', () => this.props.onChangeHeight(this.bar.current!.offsetHeight));\r\n        this.props.onChangeHeight(this.bar.current!.offsetHeight);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div ref={this.bar} className='top-navbar navbar-expand-sm top-navbar'>\r\n                {this.props.children}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default TopBar;","import React from 'react';\r\n\r\ninterface IProps {\r\n    onClick: ()  => void\r\n}\r\n\r\ninterface VProps {\r\n    color: string\r\n    onClick: ()  => void\r\n}\r\n\r\nexport class VisualizeButton extends React.Component<VProps>\r\n{\r\n    render() {\r\n        return (\r\n            <button className={'button ' + this.props.color} onClick={this.props.onClick}>\r\n                Visualize!\r\n            </button>\r\n        );\r\n    }\r\n}\r\n\r\nexport class SettingsButton extends React.Component<IProps>\r\n{\r\n    render() {\r\n        return (\r\n            <button className='button settings-button' onClick={this.props.onClick}>\r\n                Settings\r\n            </button>\r\n        );\r\n    }\r\n}\r\n\r\nexport class MazeButton extends React.Component<IProps>\r\n{\r\n    render() {\r\n        return (\r\n            <button className='button maze-button' onClick={this.props.onClick}>\r\n                Maze\r\n            </button>\r\n        );\r\n    }\r\n}\r\n","import React from 'react';\r\n\r\ninterface AlgProps {\r\n    onChange: (alg: string) => void\r\n}\r\n\r\ninterface AlgState {\r\n    up: boolean,\r\n    display: string,\r\n    algText: string;\r\n}\r\n\r\nexport class AlgorithmDropDown extends React.Component<AlgProps, AlgState>\r\n{\r\n    constructor(props: AlgProps) {\r\n        super(props);\r\n        this.state = {\r\n            up: true,\r\n            display: 'none',\r\n            algText: 'A* Search'\r\n        };\r\n    }\r\n\r\n    show = () => {\r\n        this.setState({\r\n            up: false,\r\n            display: 'block'\r\n        });\r\n    }\r\n\r\n    hide = () => {\r\n        this.setState({\r\n            up: true,\r\n            display: 'none'\r\n        });\r\n    }\r\n\r\n    toggle = () => {\r\n        if(this.isHidden()) {\r\n            this.show();\r\n        } else {\r\n            this.hide();\r\n        }\r\n    }\r\n\r\n    isHidden = () => {\r\n        return this.state.display === 'none';\r\n    }\r\n\r\n    contentStyle = () => {\r\n        return {\r\n            display: this.state.display\r\n        }\r\n    }\r\n\r\n    onChange = (key: string, algText: string) => {\r\n        this.props.onChange(key);\r\n        this.setState({\r\n            algText: algText\r\n        });\r\n    }\r\n\r\n    arrowClass = () => {\r\n        return this.state.up ? 'arrowUp' : 'arrowDown';\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className='alg-drop-down drop-down' onMouseOver={this.show} onMouseLeave={this.hide}>\r\n                <div className='alg-drop-down-button drop-down-button'>\r\n                    <span className='alg-drop-down-text drop-down-text'>{this.state.algText}</span>\r\n                    <span className={'alg-arr ' + this.arrowClass()}/>\r\n                </div>\r\n                <div style={this.contentStyle()} className='alg-drop-down-content drop-down-content'>\r\n                    <div onClick={() => this.onChange('a*', 'A* Search')}>A* Search</div>\r\n                    <div onClick={() => this.onChange('dijkstra', 'Dijkstra')}>Dijkstra's Algorithm</div>\r\n                    <div onClick={() => this.onChange('best-first', 'Best First')}>Best First Search</div>\r\n                    <div onClick={() => this.onChange('bfs', 'Breadth First')}>Breadth First Search</div>\r\n                    <div onClick={() => this.onChange('dfs', 'Depth First')}>Depth First Search</div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\ninterface ClrProps {\r\n    onClickPath: () => void,\r\n    onClickTiles: () => void\r\n}\r\n\r\ninterface ClrState {\r\n    up: boolean,\r\n    display: string\r\n}\r\n\r\nexport class ClearDropDown extends React.Component<ClrProps, ClrState>\r\n{\r\n    constructor(props: ClrProps) {\r\n        super(props);\r\n        this.state = {\r\n            up: true,\r\n            display: 'none'\r\n        };\r\n    }\r\n\r\n    show = () => {\r\n        this.setState({\r\n            up: false,\r\n            display: 'block'\r\n        });\r\n    }\r\n\r\n    hide = () => {\r\n        this.setState({\r\n            up: true,\r\n            display: 'none'\r\n        });\r\n    }\r\n\r\n    toggle = () => {\r\n        if(this.isHidden()) {\r\n            this.show();\r\n        } else {\r\n            this.hide();\r\n        }\r\n    }\r\n\r\n    isHidden = () => {\r\n        return this.state.display === 'none';\r\n    }\r\n\r\n    contentStyle = () => {\r\n        return {\r\n            display: this.state.display\r\n        }\r\n    }\r\n\r\n    arrowClass = () => {\r\n        return this.state.up ? 'arrowUpW' : 'arrowDownW';\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className='clr-drop-down drop-down' onMouseOver={this.show} onMouseLeave={this.hide}>\r\n                <div className='clr-drop-down-button drop-down-button'>\r\n                    <span className='clr-drop-down-text drop-down-text'>Clear Grid</span>\r\n                    <span className={'clr-arr ' + this.arrowClass()}/>\r\n                </div>\r\n                <div style={this.contentStyle()} className='clr-drop-down-content drop-down-content'>\r\n                    <div onClick={this.props.onClickPath}>Clear Path</div>\r\n                    <div onClick={this.props.onClickTiles}>Clear Tiles</div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}","import React, {RefObject} from 'react';\r\n\r\ninterface IProps {\r\n    show: boolean,\r\n    onClickXButton: () => void\r\n}\r\n\r\ninterface IState {\r\n    top: number,\r\n    left: number,\r\n}\r\n\r\nclass DraggablePanel extends React.Component<IProps, IState>\r\n{\r\n    //refs are used to access native DOM\r\n    private draggable: RefObject<HTMLDivElement> = React.createRef();\r\n    private draggableContainer: RefObject<HTMLDivElement> = React.createRef();\r\n    private draggableContent: RefObject<HTMLDivElement> = React.createRef();\r\n\r\n    //stores previous mouse location and drag\r\n    private dragging = false;\r\n    private prevX = 0;\r\n    private prevY = 0;\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.state = {\r\n            top: -1,\r\n            left: -1,\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        document.addEventListener('mouseup', e => {\r\n            this.mouseUp(e);\r\n        });\r\n        document.addEventListener('mousemove', e => {\r\n            this.mouseMove(e);\r\n        });\r\n        window.addEventListener('mouseleave', e => {\r\n            this.mouseUp(e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Start drag and init prev mouse location when mouse is clicked on draggable\r\n     * @param e\r\n     */\r\n    private mouseDown = (e: MouseEvent) => {\r\n        e.preventDefault();\r\n        this.prevY = e.clientY;\r\n        this.prevX = e.clientX;\r\n        this.dragging = true;\r\n    }\r\n\r\n    /**\r\n     * Called when mouse is risen on document stop drag\r\n     * @param e\r\n     */\r\n    private mouseUp = (e: MouseEvent) => {\r\n        e.preventDefault();\r\n        this.dragging = false;\r\n    }\r\n\r\n    /**\r\n     * Called when the mouse is moved over the document to calculate the new position of\r\n     * the draggable canvas\r\n     * @param e\r\n     */\r\n    private mouseMove = (e: MouseEvent) => {\r\n        if(this.dragging) {\r\n            const container = this.draggableContainer.current!;\r\n            let top = (container.offsetTop - (this.prevY - e.clientY))\r\n            let left = (container.offsetLeft - (this.prevX - e.clientX));\r\n            const content = this.draggableContent.current!;\r\n            const draggable = this.draggable.current!;\r\n            //stop drag if mouse goes out of bounds\r\n            if(e.clientY < 0 || e.clientY > window.innerHeight\r\n                    || e.clientX < 0 || e.clientX > window.innerWidth) {\r\n                this.dragging = false;\r\n            }\r\n            //check if position is out of bounds and prevent the panel from being dragged there\r\n            if(top < 0) {\r\n                top = 0;\r\n            } else if (top > window.innerHeight - draggable.offsetHeight) {\r\n                top = window.innerHeight - draggable.offsetHeight;\r\n            }\r\n            if(left < -content.offsetWidth/2) {\r\n                left = -content.offsetWidth/2;\r\n            } else if(left > window.innerWidth - content.offsetWidth/2) {\r\n                left = window.innerWidth - content.offsetWidth/2;\r\n            }\r\n            //set new position\r\n            this.setState({\r\n                top: top\r\n            });\r\n            this.setState({\r\n                left: left\r\n            });\r\n            //update previous pos\r\n            this.prevY = e.clientY;\r\n            this.prevX = e.clientX;\r\n        }\r\n    }\r\n\r\n    getPosition = () => {\r\n        const left = this.state.left;\r\n        const top = this.state.top;\r\n        if(left === -1 || top === -1) {\r\n            return {};\r\n        }\r\n        return {\r\n            left: left + 'px',\r\n            top: top + 'px',\r\n        };\r\n    }\r\n\r\n    contentStyle = () => {\r\n        return {\r\n            display: this.props.show ? 'block' : 'none'\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div ref={this.draggableContainer} className='draggable-container' style={this.getPosition()}>\r\n                {this.renderDraggable()}\r\n                <div ref={this.draggableContent} style={this.contentStyle()} className='draggable-content'>\r\n                    <div className='settings-general'>\r\n                        {this.props.children}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    private renderDraggable = () => {\r\n        return (\r\n            <div style={this.contentStyle()} className='draggable'\r\n                 ref={this.draggable}\r\n                 onMouseDown={e => this.mouseDown(e.nativeEvent)}\r\n            >\r\n                <div className='draggable-title'>Grid Settings</div>\r\n                <div className='x-button' onClick={this.props.onClickXButton}>X</div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default DraggablePanel;","import React from 'react';\r\nimport {Node} from '../../pathfinding/algorithms/Node';\r\nimport {Point} from '../../pathfinding/core/Components';\r\n\r\ninterface IProps {\r\n    tileWidth: number,\r\n    tilesX: number,\r\n    tilesY: number\r\n}\r\n\r\nconst CLOSED_NODE = 'rgb(198, 237, 238)';\r\nconst OPEN_NODE = 'rgb(191, 248, 159)';\r\nconst EMPTY_NODE = 'white';\r\n\r\nclass GridBackground extends React.Component<IProps>\r\n{\r\n    /**\r\n     * Represents the state of the component\r\n     * Stored outside of State to prevent copies, allowing\r\n     * updates with forceUpdate to improve App performance\r\n     */\r\n    private visualization: string[][];\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.visualization = this.createEmptyBg();\r\n    }\r\n\r\n    /**\r\n     * Create a new empty visualization canvas\r\n     */\r\n    createEmptyBg() {\r\n        const visualization = [];\r\n        for(let y = 0; y < this.props.tilesY; y++) {\r\n            let row: string[] = [];\r\n            for(let x = 0; x < this.props.tilesX; x++) {\r\n                row.push(EMPTY_NODE);\r\n            }\r\n            visualization.push(row);\r\n        }\r\n        return visualization;\r\n    }\r\n\r\n    /**\r\n     * Clear the visualization canvas and update UI\r\n     */\r\n    clear = () => {\r\n        this.visualization = this.createEmptyBg();\r\n        this.setState({});\r\n    }\r\n\r\n    /**\r\n     * Perform a generation on a visualization array\r\n     * @param generation\r\n     * @param visualization\r\n     */\r\n    private doGeneration = (generation: Node, visualization: string[][]) => {\r\n        for(const node of generation.children) {\r\n            const point = node.tile.point;\r\n            visualization[point.y][point.x] = OPEN_NODE;\r\n        }\r\n        const point = generation.tile.point;\r\n        visualization[point.y][point.x] = CLOSED_NODE;\r\n        return visualization;\r\n    }\r\n\r\n    /**\r\n     * Visualize generation and update UI\r\n     * @param generation\r\n     */\r\n    visualizeGeneration = (generation: Node) => {\r\n        this.doGeneration(generation, this.visualization); //modify state directly to improve performance\r\n        this.setState({});\r\n    }\r\n\r\n    /**\r\n     * Visualize generation array and update UI\r\n     * @param generations\r\n     */\r\n    visualizeGenerations = (generations: Node[]) => {\r\n        const visualization = this.createEmptyBg();\r\n        for(const generation of generations) {\r\n            this.doGeneration(generation, visualization);\r\n        }\r\n        this.visualization = visualization;\r\n        this.setState({});\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className='bg'>\r\n                {this.renderTiles()}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    private renderTiles = () => {\r\n        const tiles: JSX.Element[][] = [];\r\n        for(let y = 0; y < this.props.tilesY; y++) {\r\n            let row: JSX.Element[] = [];\r\n            for(let x = 0; x < this.props.tilesX; x++) {\r\n                const point = {\r\n                    x: x, y: y\r\n                };\r\n                row.push(\r\n                    this.renderTile(point, this.visualization[point.y][point.x])\r\n                );\r\n            }\r\n            tiles.push(row);\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    private renderTile = (point: Point, color: string) => {\r\n        const width = this.props.tileWidth;\r\n        const top = point.y * this.props.tileWidth;\r\n        const left = point.x * this.props.tileWidth;\r\n        const style = {\r\n            backgroundColor: color,\r\n            width: width + 'px',\r\n            height: width + 'px',\r\n            top: top,\r\n            left: left\r\n        };\r\n        return (\r\n            <div key={point.x + ',' + point.y} style={style} className='tile'/>\r\n        );\r\n    }\r\n}\r\n\r\nexport default GridBackground;","/**\r\n * Represents a point in 2d space\r\n */\r\nexport interface Point\r\n{\r\n    readonly x: number;\r\n    readonly y: number;\r\n}\r\n\r\n/**\r\n * Represents the data inside a tile\r\n * Solid tiles cannot be passed while non solid ones can\r\n * pathCost stores how expensive it is to travel to the tile if it isn't solid\r\n */\r\nexport interface TileData\r\n{\r\n    readonly pathCost: number;\r\n    readonly isSolid: boolean;\r\n}\r\n\r\n/**\r\n * Represents a tile on the Grid\r\n */\r\nexport interface Tile\r\n{\r\n    data: TileData;\r\n    readonly point: Point;\r\n}\r\n\r\n/**\r\n * Simple function to create a solid tile with path cost of 1\r\n * @param isSolid\r\n */\r\nexport function createTile(isSolid: boolean) {\r\n    return {\r\n        pathCost: 1,\r\n        isSolid: isSolid\r\n    }\r\n}\r\n\r\n","import {createTile, Point, Tile, TileData} from './Components';\r\n\r\nexport interface Grid\r\n{\r\n    getWidth(): number;\r\n    getHeight(): number;\r\n    inBounds(point: Point): boolean;\r\n    get(point: Point): Tile;\r\n    isSolid(point: Point): boolean;\r\n    mutate(point: Point, data: TileData): void;\r\n    mutateTile(tile: Tile): void;\r\n    mutateDefault(point: Point, solid: boolean): void;\r\n    output(console: Console): void;\r\n    getJson(): string;\r\n    walkable(point: Point): boolean;\r\n    clone(): Grid;\r\n}\r\n\r\n/**\r\n * A square grid system that stores nodes in a matrix\r\n * Uses an x,y system where x corresponds to column of the matrix,\r\n * and y corresponds to the row of the matrix\r\n * TileData.ts should be treated like graph nodes\r\n */\r\nclass SquareGrid implements Grid\r\n{\r\n    private readonly tiles: Tile[][];\r\n    private readonly width: number;\r\n    private readonly height: number;\r\n\r\n    /**\r\n     * Constructs a grid either with empty or predefined tiles\r\n     * @param width of the grid\r\n     * @param height of grid\r\n     * @param tiles, optional parameter for predefined tiles,\r\n     * will perform a defensive copy to the grid\r\n     */\r\n    constructor(width: number, height: number, tiles?: Tile[][]) {\r\n        this.width = width;\r\n        this.height = height;\r\n        if(tiles === undefined) {\r\n            this.tiles = createEmptyGrid(width, height);\r\n        } else {\r\n            this.tiles = [];\r\n            for(let y = 0; y < height; y++) {\r\n                const row: Tile[] = [];\r\n                for(let x = 0; x < width; x++) {\r\n                    row.push({\r\n                        data: {\r\n                            pathCost: tiles[y][x].data.pathCost,\r\n                            isSolid: tiles[y][x].data.isSolid\r\n                        },\r\n                        point: {\r\n                            x: x, y: y\r\n                        }\r\n                    });\r\n                }\r\n               this.tiles.push(row);\r\n            }\r\n        }\r\n    }\r\n\r\n    getWidth() {\r\n        return this.width;\r\n    }\r\n\r\n    getHeight() {\r\n        return this.height;\r\n    }\r\n\r\n    /**\r\n     * Checks if a given point is in bounds\r\n     * Other functions assume arguments are in bounds, this should be used\r\n     * if there is reasonable doubt about whether a point is in bounds\r\n     * @param point, to check\r\n     */\r\n    inBounds(point: Point) {\r\n        return point.x >= 0 && point.x < this.width && point.y >= 0 && point.y < this.height;\r\n    }\r\n\r\n    /**\r\n     * Retrieves a defensive tile for a position\r\n     * Defensive copy prevents this object from being mutated without calling\r\n     * a mutate function\r\n     * @param point, point to get\r\n     */\r\n    get(point: Point) {\r\n        return {\r\n            point: this.tiles[point.y][point.x].point,\r\n            data: this.tiles[point.y][point.x].data\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Mutates a position's tile to solid or non solid\r\n     * @param point, point to mutate\r\n     * @param data to mutate to\r\n     */\r\n    mutate(point: Point, data: TileData) {\r\n        this.tiles[point.y][point.x].data = data;\r\n    }\r\n\r\n    /**\r\n     * Mutates a a tile by point\r\n     * @param tile to mutate\r\n     */\r\n    mutateTile(tile: Tile) {\r\n        this.tiles[tile.point.y][tile.point.x].data = tile.data;\r\n    }\r\n\r\n    /**\r\n     * Mutate tile at point\r\n     * @param point to mutate at\r\n     * @param solid to determine what default tile to create\r\n     */\r\n    mutateDefault = (point: Point, solid: boolean) => {\r\n        this.mutate(\r\n            point, createTile(solid)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Outputs the grid to a console\r\n     * @param console\r\n     */\r\n    output(console: Console) {\r\n        for(let y = 0; y < this.height; y++) {\r\n            let str = '';\r\n            for(let x = 0; x < this.width; x++) {\r\n                str += this.tiles[y][x].data.isSolid + ', ';\r\n            }\r\n            console.log(str);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns json of tiles\r\n     */\r\n    getJson() {\r\n        return JSON.stringify(this.tiles);\r\n    }\r\n\r\n    /**\r\n     * Determines if a tile can be walked on\r\n     * @param point\r\n     */\r\n    walkable(point: Point) {\r\n        return !this.get(point).data.isSolid;\r\n    }\r\n\r\n    isSolid(point: Point): boolean {\r\n        return this.get(point).data.isSolid;\r\n    }\r\n\r\n    clone(): Grid {\r\n        return new SquareGrid(this.width, this.height, this.tiles);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a 2d matrix of empty nodes\r\n */\r\nfunction createEmptyGrid(width: number, height: number) {\r\n    const nodes: Tile[][] = [];\r\n    for(let y = 0; y < height; y++) {\r\n        const row: Tile[] = [];\r\n        for(let x = 0; x < width; x++) {\r\n            row.push({\r\n                point: {\r\n                    x: x, y: y\r\n                },\r\n                data: createTile(false)\r\n            });\r\n        }\r\n        nodes.push(row);\r\n    }\r\n    return nodes;\r\n}\r\n\r\nexport default SquareGrid;","import React from 'react';\r\nimport {Point} from '../../pathfinding/core/Components';\r\n\r\ninterface IProps {\r\n    tileWidth: number,\r\n    point: Point,\r\n    color: string,\r\n    doAnimation: boolean\r\n}\r\n\r\ninterface IState {\r\n    tileSize: number\r\n}\r\n\r\nclass TileFg extends React.Component<IProps, IState>\r\n{\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        const size = this.props.doAnimation ?  0 : this.props.tileWidth;\r\n        this.state = {\r\n            tileSize: size,\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n        if(this.props.doAnimation) {\r\n            this.applyExpandAnimation();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Animation to expand element from half size to full size over a few milliseconds\r\n     * Can be slow to execute so animations should be enabled with caution\r\n     */\r\n    applyExpandAnimation = () => {\r\n        const total = 5\r\n        const original = this.state.tileSize;\r\n        for(let i = 1; i <= total; i++) {\r\n            const expand = () => this.setState({\r\n                tileSize: original + i * (this.props.tileWidth/(total))\r\n            });\r\n            setTimeout(expand, i*10);\r\n        }\r\n    }\r\n\r\n    applyShrinkAnimation = () => {\r\n        const total = 5\r\n        const original = this.state.tileSize;\r\n        for(let i = 1; i <= total; i++) {\r\n            const expand = () => this.setState({\r\n                tileSize: original - i * (this.props.tileWidth/(total))\r\n            });\r\n            setTimeout(expand, i*10);\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const width = this.state.tileSize;\r\n        const top = this.props.point.y * this.props.tileWidth + (this.props.tileWidth - width)/2;\r\n        const left = this.props.point.x * this.props.tileWidth + (this.props.tileWidth - width)/2;\r\n        const style = {\r\n            fill: this.props.color,\r\n            stroke: 'none',\r\n            display: 'block'\r\n        };\r\n        return (\r\n            <rect x={left} y={top}\r\n                  shapeRendering='crispEdges'\r\n                  width={width} height={width}\r\n                  style={style} className={'tile svg-tile'}\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nexport default TileFg;","import React, {RefObject} from 'react';\r\nimport {Point, Tile} from '../../pathfinding/core/Components';\r\nimport SquareGrid, {Grid} from '../../pathfinding/core/Grid';\r\nimport TileFg from './TileFg';\r\n\r\ninterface IProps {\r\n    tileWidth: number,\r\n    tilesX: number,\r\n    tilesY: number,\r\n    onTilesDragged: () => void;\r\n    topMargin: number\r\n}\r\n\r\ninterface IState {\r\n    grid: Grid,\r\n    initial: Point,\r\n    goal: Point,\r\n    path: Tile[]\r\n}\r\n\r\nconst SOLID_COLOR = 'rgb(45, 48, 54)';\r\nconst INITIAL_COLOR = 'rgb(131, 217, 52)';\r\nconst GOAL_COLOR = 'rgb(203, 75, 14)';\r\n\r\nclass GridForeground extends React.Component<IProps,IState>\r\n{\r\n    private svg: RefObject<SVGSVGElement> = React.createRef();\r\n\r\n    private mouseDown0: boolean = false;\r\n    private mouseDown2: boolean = false;\r\n    private draggingInitial: boolean = false;\r\n    private draggingGoal: boolean = false;\r\n    private disable: boolean = false;\r\n\r\n    private doTileAnimation: boolean = true;\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        const end = this.calcEndPointInView();\r\n        this.state = {\r\n            grid: new SquareGrid(this.props.tilesX, this.props.tilesY),\r\n            path: [],\r\n            initial: {\r\n                x: ((end.x)/3) >> 0,\r\n                y: ((end.y)/3) >> 0\r\n            },\r\n            goal: {\r\n                x: ((2*(end.x)/3) >> 0) - 1,\r\n                y: ((2*(end.y)/3) >> 0) - 1\r\n            }\r\n        }\r\n    }\r\n\r\n    calcEndPointInView() {\r\n        const xEnd = Math.round(window.innerWidth / this.props.tileWidth);\r\n        const yEnd = Math.round((window.innerHeight - this.props.topMargin - 30) / this.props.tileWidth);\r\n        return {\r\n            x: xEnd, y: yEnd\r\n        }\r\n    }\r\n\r\n    toggleDisable() {\r\n        this.disable = !this.disable;\r\n    }\r\n\r\n    getBoundingRect() {\r\n        return this.svg.current!.getBoundingClientRect();\r\n    }\r\n\r\n    private mouseDown = (e: MouseEvent) => {\r\n        e.preventDefault();\r\n        const bounds = this.getBoundingRect();\r\n        this.onPress(e.clientX - bounds.left, e.clientY - bounds.top, e.button);\r\n    }\r\n\r\n    private mouseUp = (e: MouseEvent) => {\r\n        e.preventDefault();\r\n        if(e.button === 0) {\r\n            this.draggingGoal = false;\r\n            this.draggingInitial = false;\r\n            this.mouseDown0 = false;\r\n        } else if(e.button === 2) {\r\n            this.mouseDown2 = false;\r\n        }\r\n    }\r\n\r\n    private mouseMove = (e: MouseEvent) => {\r\n        const bounds = this.getBoundingRect();\r\n        this.onDrag(e.clientX - bounds.left, e.clientY - bounds.top);\r\n    }\r\n\r\n    private touchStart = (e: TouchEvent) => {\r\n        const touch = e.touches[0] || e.changedTouches[0];\r\n        const bounds = this.getBoundingRect();\r\n        this.onTouch(touch.clientX - bounds.left, touch.clientY - bounds.top);\r\n    }\r\n\r\n    private touchMove = (e: TouchEvent) => {\r\n        const touch = e.touches[0] || e.changedTouches[0];\r\n        const bounds = this.getBoundingRect();\r\n        this.onDrag(touch.clientX - bounds.left, touch.clientY - bounds.top);\r\n    }\r\n\r\n    private onEndingEvent = (e: Event) => {\r\n        e.preventDefault();\r\n        this.draggingGoal = false;\r\n        this.draggingInitial = false;\r\n        this.mouseDown0 = false;\r\n        this.mouseDown2 = false;\r\n    }\r\n\r\n    /**\r\n     * Responds to the event thrown at screen coordinates on press\r\n     * @param xCoordinate\r\n     * @param yCoordinate\r\n     * @param button\r\n     */\r\n    private onPress = (xCoordinate: number, yCoordinate: number, button: number) => {\r\n        const point = this.calculatePoint(xCoordinate,yCoordinate);\r\n        if(button === 0) {\r\n            this.mouseDown0 = true;\r\n            if(pointsEqual(point, this.state.initial)) {\r\n                this.draggingInitial = true;\r\n            } else if(pointsEqual(point, this.state.goal)) {\r\n                this.draggingGoal = true;\r\n            } else if(!this.disable) {\r\n                this.drawTile(point);\r\n            }\r\n        } else if(button === 2) {\r\n            this.mouseDown2 = true;\r\n            if(!pointsEqual(point,this.state.initial) && !pointsEqual(point, this.state.goal) && !this.disable) {\r\n                this.eraseTile(point);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Responds to the event thrown at screen coordinates on touch\r\n     * @param xCoordinate\r\n     * @param yCoordinate\r\n     */\r\n    private onTouch = (xCoordinate: number, yCoordinate: number) => {\r\n        const point = this.calculatePoint(xCoordinate,yCoordinate);\r\n        if(pointsEqual(point, this.state.initial)) {\r\n            this.mouseDown0 = true;\r\n            this.draggingInitial = true;\r\n        } else if(pointsEqual(point, this.state.goal)) {\r\n            this.mouseDown0 = true;\r\n            this.draggingGoal = true;\r\n        } else if(!this.state.grid.isSolid(point)) {\r\n            this.mouseDown0 = true;\r\n            if(!this.disable) {\r\n                this.drawTile(point);\r\n            }\r\n        } else {\r\n            this.mouseDown2 = true;\r\n            if(!pointsEqual(point, this.state.initial) && !pointsEqual(point, this.state.goal) && !this.disable) {\r\n                this.eraseTile(point);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Responds to the event thrown at screen coordinates on drag/move\r\n     * @param xCoordinate\r\n     * @param yCoordinate\r\n     */\r\n    private onDrag = (xCoordinate: number, yCoordinate: number) => {\r\n        const point = this.calculatePoint(xCoordinate,yCoordinate);\r\n        if(this.mouseDown0) {\r\n            if(this.draggingInitial) {\r\n                this.moveInitial(point);\r\n                this.props.onTilesDragged();\r\n            } else if(this.draggingGoal) {\r\n                this.moveGoal(point);\r\n                this.props.onTilesDragged();\r\n            } else if(!pointsEqual(point,this.state.initial) && !pointsEqual(point, this.state.goal) && !this.disable) {\r\n                this.drawTile(point);\r\n            }\r\n        } else if(this.mouseDown2) {\r\n            if(!pointsEqual(point, this.state.initial) && !pointsEqual(point, this.state.goal) && !this.disable) {\r\n                this.eraseTile(point);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw an entire new grid on the foreground with disabled animations\r\n     * @param grid\r\n     */\r\n    drawGrid = (grid: Grid) => {\r\n        this.doTileAnimation = false;\r\n        this.setState({\r\n            grid: grid\r\n        }, () => this.doTileAnimation = true)\r\n    }\r\n\r\n    /**\r\n     * Draw tile at point\r\n     * @param point\r\n     */\r\n    drawTile = (point: Point) => {\r\n        const grid = this.state.grid.clone();\r\n        if(grid.inBounds(point)) {\r\n            grid.mutateDefault(point, true);\r\n        }\r\n        this.setState({\r\n            grid: grid\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Checks if a node is visualized, then changes the tile to empty if it isn't\r\n     * @param point\r\n     */\r\n    eraseTile = (point: Point) => {\r\n        const grid = this.state.grid.clone();\r\n        if(grid.inBounds(point)) {\r\n            grid.mutateDefault(point, false);\r\n        }\r\n        this.setState({\r\n            grid: grid\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Clear grid in state\r\n     */\r\n    clearTiles = () => {\r\n        const grid = this.state.grid.clone();\r\n        for(let y = 0; y < this.props.tilesY; y++) {\r\n            for(let x = 0; x < this.props.tilesX; x++) {\r\n                const point = {\r\n                    x: x, y: y\r\n                }\r\n                grid.mutateDefault(point, false);\r\n            }\r\n        }\r\n        this.setState({\r\n            grid: grid\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Moves initial to a new point\r\n     * @param point\r\n     */\r\n    moveInitial = (point: Point) => {\r\n        const revealed = this.state.grid.isSolid(point);\r\n        if(this.state.grid.inBounds(point) && !revealed &&\r\n            !pointsEqual(this.state.goal, point)  && !this.disable) {\r\n            this.setState({\r\n                initial: point\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves goal to a new point\r\n     * @param point\r\n     */\r\n    moveGoal = (point: Point) => {\r\n        const revealed = this.state.grid.isSolid(point);\r\n        if(this.state.grid.inBounds(point) && !revealed &&\r\n            !pointsEqual(this.state.initial, point) && !this.disable) {\r\n            this.setState({\r\n                goal: point\r\n            });\r\n        }\r\n    }\r\n\r\n    drawPath = (path: Tile[]) => {\r\n        this.setState({\r\n            path: path.slice()\r\n        });\r\n    }\r\n\r\n    erasePath = () => {\r\n        this.setState({\r\n            path: []\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts real screen x,y coordinates into\r\n     * a 2d point position on the grid\r\n     * @param xCoordinate\r\n     * @param yCoordinate\r\n     */\r\n    calculatePoint = (xCoordinate: number, yCoordinate: number) => {\r\n        return {\r\n            x: Math.floor(xCoordinate/this.props.tileWidth),\r\n            y: Math.floor(yCoordinate/this.props.tileWidth)\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <svg ref={this.svg} xmlns='http://www.w3.org/2000/svg' className='grid'\r\n                 onContextMenu={e => e.preventDefault()}\r\n                 onMouseDown={e => this.mouseDown(e.nativeEvent)}\r\n                 onMouseUp={e => this.mouseUp(e.nativeEvent)}\r\n                 onMouseMove={e => this.mouseMove(e.nativeEvent)}\r\n                 onMouseLeave={e => this.onEndingEvent(e.nativeEvent)}\r\n                 onTouchStart={e => this.touchStart(e.nativeEvent)}\r\n                 onTouchMoveCapture={e => this.touchMove(e.nativeEvent)}\r\n                 onTouchEnd={e => this.onEndingEvent(e.nativeEvent)}\r\n                 onTouchCancel={e => this.onEndingEvent(e.nativeEvent)}\r\n            >\r\n                {this.renderEndTile(this.state.initial, INITIAL_COLOR,'initial')}\r\n                {this.renderEndTile(this.state.goal, GOAL_COLOR,'goal')}\r\n                {this.renderLines()}\r\n                {this.renderTiles()}\r\n            </svg>\r\n        );\r\n    }\r\n\r\n    private renderLines = () => {\r\n        const lines: JSX.Element[] = [];\r\n        for(let i = 0; i < this.state.path.length-1; i++) {\r\n            const first = this.state.path[i].point;\r\n            const second = this.state.path[i+1].point;\r\n            lines.push(this.renderLine(first, second));\r\n        }\r\n        return lines;\r\n    }\r\n\r\n    private renderLine = (first: Point, second: Point) => {\r\n        const width = this.props.tileWidth;\r\n        const offset = width/2;\r\n        return (\r\n            <line key={second.x + ',' + second.y}\r\n                  x1={first.x * width + offset} y1={first.y * width + offset}\r\n                  x2={second.x * width + offset} y2={second.y * width + offset}\r\n                  stroke='black' strokeWidth='2' className='line'/>\r\n        );\r\n    }\r\n\r\n    private renderTiles = () => {\r\n        const tiles: JSX.Element[] = [];\r\n        for(let y = 0; y < this.props.tilesY; y++) {\r\n            for(let x = 0; x < this.props.tilesX; x++) {\r\n                const point = {\r\n                    x: x, y: y\r\n                }\r\n                if(this.state.grid.isSolid(point)) {\r\n                    tiles.push(\r\n                        <TileFg key={point.x + ',' + point.y} point={point}\r\n                                doAnimation={this.doTileAnimation}\r\n                                tileWidth={this.props.tileWidth}\r\n                                color={SOLID_COLOR}\r\n                        />\r\n                    );\r\n                }\r\n            }\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    private renderEndTile = (point: Point, color: string, key: string) => {\r\n        return <TileFg key={key} point={point} doAnimation={false}\r\n                       tileWidth={this.props.tileWidth}\r\n                       color={color}/>\r\n    }\r\n}\r\n\r\nfunction pointsEqual(point1: Point, point2: Point) {\r\n    return point1.x === point2.x && point1.y === point2.y;\r\n}\r\n\r\nexport default GridForeground;","import {Grid} from './Grid';\r\nimport {Point, Tile} from './Components';\r\n\r\nexport const UNIT = 1; //number of tiles we can move at once\r\n\r\n/**\r\n * Describes an abstract navigator for a grid\r\n * Provides graph-like traversal for the grid\r\n * Determines where we can travel to from a certain point,\r\n * whether we have reached a destination, and the cost to\r\n * travel to a certain point\r\n */\r\nabstract class Navigator\r\n{\r\n    protected readonly grid: Grid;\r\n\r\n    constructor(grid: Grid) {\r\n        this.grid = grid;\r\n    }\r\n\r\n    getGrid() {\r\n        return this.grid;\r\n    }\r\n\r\n    /**\r\n     * Goal check function: Checks if two points are equal\r\n     * @param a\r\n     * @param b\r\n     */\r\n    equals(a: Point, b: Point) {\r\n        return a.x === b.x && a.y === b.y;\r\n    }\r\n\r\n    /**\r\n     * Step cost function from a to b\r\n     * @param a\r\n     * @param b to point to travel to\r\n     */\r\n    abstract cost(a: Point, b: Point): number;\r\n\r\n    /**\r\n     * Neighbors function: Gets the available neighbors for a point in a grid we can make\r\n     * in a given move\r\n     * @param point\r\n     */\r\n    abstract neighbors(point: Point): Tile[];\r\n}\r\n\r\nexport default Navigator;","import {Point, Tile} from './Components';\r\nimport Navigator, {UNIT} from './Navigator';\r\n\r\n/**\r\n * Concretion of a Plus Navigator for a grid\r\n * Allows movement akin to a 'plus' symbol\r\n */\r\nclass PlusNavigator extends Navigator\r\n{\r\n    /**\r\n     * Adds the neighbors of a point to the left, right, top and down\r\n     * @param point\r\n     */\r\n    neighbors(point: Point): Tile[] {\r\n        const tiles: Tile[] = [];\r\n        if(point.x + UNIT < this.grid.getWidth()) {\r\n            const tile = this.grid.get({\r\n                x: point.x + UNIT,\r\n                y: point.y\r\n            })\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.y + UNIT < this.grid.getHeight()) {\r\n            const tile = this.grid.get({\r\n                x: point.x,\r\n                y: point.y + UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.x - UNIT >= 0) {\r\n            const tile = this.grid.get({\r\n                x: point.x - UNIT,\r\n                y: point.y\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.y - UNIT >= 0) {\r\n            const tile = this.grid.get({\r\n                x: point.x,\r\n                y: point.y - UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    /**\r\n     * Step cost function that works by getting the pathCost stored in the grid\r\n     * from one point a to b\r\n     * @param a\r\n     * @param b to point to travel to\r\n     */\r\n    cost(a: Point, b: Point) {\r\n        return this.grid.get(b).data.pathCost;\r\n    }\r\n}\r\n\r\nexport default PlusNavigator;","import {Point} from '../core/Components';\r\n\r\nexport type HeuristicFunc = (a: Point, b: Point) => number;\r\n\r\nexport function manhattan(a: Point, b: Point): number {\r\n    let dx = Math.abs(a.x - b.x) ;\r\n    let dy = Math.abs(a.y - b.y);\r\n    return dx + dy;\r\n}\r\n\r\nexport function euclidean(a: Point, b: Point): number {\r\n    let dx = Math.abs(a.x - b.x);\r\n    let dy = Math.abs(a.y - b.y);\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\r\n\r\nexport function octile(a: Point, b: Point): number {\r\n    let dx = Math.abs(a.x - b.x);\r\n    let dy = Math.abs(a.y - b.y);\r\n    return Math.SQRT2 * Math.min(dx, dy) + Math.abs(dx - dy);\r\n}\r\n\r\nexport function chebyshev(a: Point, b: Point): number {\r\n    let dx = Math.abs(a.x - b.x);\r\n    let dy = Math.abs(a.y - b.y);\r\n    return Math.max(dx, dy);\r\n}\r\n\r\nexport function nullHeuristic(a: Point, b: Point): number {\r\n    return 0;\r\n}","import {Point, Tile} from './Components';\r\nimport Navigator, {UNIT} from './Navigator';\r\nimport {euclidean} from '../algorithms/Heuristics';\r\n\r\n/**\r\n * Concretion of a Plus Navigator for a grid\r\n * Allows movement akin to a 'asterisk' symbol\r\n */\r\nclass AsteriskNavigator extends Navigator\r\n{\r\n    /**\r\n     * Adds the neighbors of a point to the left, right, top and down\r\n     * @param point\r\n     */\r\n    neighbors(point: Point): Tile[] {\r\n        //keep track of double squares that block diagonals\r\n        let walkBottomRight = false;\r\n        let walkTopRight = false;\r\n        let walkBottomLeft = false;\r\n        let walkTopLeft = false;\r\n        //plus\r\n        const tiles: Tile[] = [];\r\n        if(point.x + UNIT < this.grid.getWidth()) {\r\n            const tile = this.grid.get({\r\n                x: point.x + UNIT,\r\n                y: point.y\r\n            })\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n                walkBottomRight = true;\r\n                walkTopRight = true;\r\n            }\r\n        }\r\n        if(point.y + UNIT < this.grid.getHeight()) {\r\n            const tile = this.grid.get({\r\n                x: point.x,\r\n                y: point.y + UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n                walkBottomRight = true;\r\n                walkBottomLeft = true;\r\n            }\r\n        }\r\n        if(point.x - UNIT >= 0) {\r\n            const tile = this.grid.get({\r\n                x: point.x - UNIT,\r\n                y: point.y\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n                walkBottomLeft = true;\r\n                walkTopLeft = true;\r\n            }\r\n        }\r\n        if(point.y - UNIT >= 0) {\r\n            const tile = this.grid.get({\r\n                x: point.x,\r\n                y: point.y - UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n                walkTopRight = true;\r\n                walkTopLeft = true;\r\n            }\r\n        }\r\n        //diagonals\r\n        if(point.x + UNIT < this.grid.getWidth() &&\r\n            point.y + UNIT < this.grid.getHeight() &&\r\n            walkBottomRight) {\r\n            const tile = this.grid.get({\r\n                x: point.x + UNIT,\r\n                y: point.y + UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.x - UNIT >= 0 &&\r\n            point.y + UNIT < this.grid.getHeight() &&\r\n            walkBottomLeft) {\r\n            const tile = this.grid.get({\r\n                x: point.x - UNIT,\r\n                y: point.y + UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.x + UNIT < this.grid.getWidth() &&\r\n            point.y - UNIT >= 0 &&\r\n            walkTopRight) {\r\n            const tile =  this.grid.get({\r\n                x: point.x + UNIT,\r\n                y: point.y - UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.x - UNIT >= 0 &&\r\n            point.y - UNIT >= 0 &&\r\n            walkTopLeft) {\r\n            const tile =  this.grid.get({\r\n                x: point.x - UNIT,\r\n                y: point.y - UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    /**\r\n     * Step cost function that works by getting the pathCost stored in the grid\r\n     * from one point a to b\r\n     * Returns the exact distance multiplied by the cost to travel there\r\n     * @param a\r\n     * @param b to point to travel to\r\n     */\r\n    cost(a: Point, b: Point) {\r\n        return euclidean(a,b) * this.grid.get(b).data.pathCost;\r\n    }\r\n\r\n}\r\n\r\nexport default AsteriskNavigator;","import {Point} from '../core/Components';\r\n\r\n/**\r\n * A simple data structure that keeps track of whether keys have been added to it\r\n */\r\nexport class HashSet\r\n{\r\n    private map: {[key: string]: boolean} = {};\r\n\r\n    add(key: string) {\r\n        this.map[key] = true;\r\n    }\r\n\r\n    remove(key: string) {\r\n        this.map[key] = false;\r\n    }\r\n\r\n    has(key: string) {\r\n        return this.map[key];\r\n    }\r\n\r\n    clear() {\r\n        this.map = {};\r\n    }\r\n}\r\n\r\n/**\r\n * A simple data structure that stores a type at a key\r\n */\r\nexport class HashTable<Value>\r\n{\r\n    private map: {[key: string]: Value | undefined} = {};\r\n\r\n    add(key: string, data: Value) {\r\n        this.map[key] = data;\r\n    }\r\n\r\n    remove(key: string) {\r\n        this.map[key] = undefined;\r\n    }\r\n\r\n    get(key: string) {\r\n        return this.map[key];\r\n    }\r\n\r\n    has(key: string) {\r\n        return this.map[key] !== undefined;\r\n    }\r\n\r\n    clear() {\r\n        this.map = {};\r\n    }\r\n}\r\n\r\n/**\r\n * Serialize point into a unique string\r\n * @param point\r\n */\r\nexport function stringify(point: Point) {\r\n    return 'x' + point.x + 'y' + point.y;\r\n}","/**\r\n * A compare function to determine if a is 'better' (deserves a higher position) than b\r\n */\r\nexport type Comparator<E> = (a: E, b: E) => boolean\r\n\r\n/**\r\n * Minimalist Implementation of the heap data structure as an array\r\n */\r\nclass Heap<E>\r\n{\r\n    private elements: E[] = [];\r\n    readonly compare: Comparator<E>;\r\n\r\n    constructor(compare: Comparator<E>) {\r\n        this.compare = compare;\r\n    }\r\n\r\n    /**\r\n     * Returns the size of the heap\r\n     */\r\n    getSize() {\r\n        return this.elements.length;\r\n    }\r\n\r\n    /**\r\n     * Checks if heap is empty\r\n     */\r\n    isEmpty() {\r\n        return this.elements.length === 0;\r\n    }\r\n\r\n    /**\r\n     * Add a new element to the heap\r\n     * @param e\r\n     */\r\n    push(e: E) {\r\n        this.elements.push(e);\r\n        this.siftUp(this.elements.length-1); //last element\r\n    }\r\n\r\n    /**\r\n     * Returns the top of the heap without removing it\r\n     * Fails if heap is empty\r\n     */\r\n    peek() {\r\n        return this.elements[0];\r\n    }\r\n\r\n    /**\r\n     * Returns the top of the heap and removes it\r\n     * Fails if heap is empty\r\n     */\r\n    pop() {\r\n        let val = this.peek();\r\n        this.move(this.elements.length - 1, 0);\r\n        this.elements.pop();\r\n        this.siftDown(0);\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Clear the heap\r\n     */\r\n    clear() {\r\n        this.elements = [];\r\n    }\r\n\r\n    /**\r\n     * Sifts a new element that is out of order up to the right position\r\n     * @param pos of new element\r\n     */\r\n    private siftUp(pos: number) {\r\n        let parent = ((pos - 1) / 2) >> 0; //integer division\r\n        while(parent >= 0) {\r\n            //if the current position is better than parent\r\n            if(this.compare(this.elements[pos], this.elements[parent])) {\r\n                //then current position with parent and move to next\r\n                this.swap(pos, parent);\r\n                pos = parent;\r\n                parent = ((pos - 1) / 2) >> 0;\r\n            } else {\r\n                //otherwise stop\r\n                parent = -1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sifts a new element that is out of order down to the right position\r\n     * @param pos of new element\r\n     */\r\n    private siftDown(pos: number) {\r\n        let left = 2 * pos + 1;\r\n        let right = 2 * pos + 2;\r\n        //stop if the children are out of bounds\r\n        if(left >= this.elements.length) {\r\n            return;\r\n        }\r\n        //find the better child\r\n        let child = (right >= this.elements.length || this.compare(this.elements[left], this.elements[right]))\r\n            ? left : right;\r\n        //continues to sift down if the child is better than the current position\r\n        if(this.compare(this.elements[child], this.elements[pos])) {\r\n            this.swap(child, pos);\r\n            this.siftDown(child);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal move function\r\n     * @param from\r\n     * @param to\r\n     */\r\n    private move(from: number, to: number) {\r\n        this.elements[to] = this.elements[from];\r\n    }\r\n\r\n    /**\r\n     * Internal swap function\r\n     * @param a\r\n     * @param b\r\n     */\r\n    private swap(a: number, b: number) {\r\n        let val = this.elements[a];\r\n        this.elements[a] = this.elements[b];\r\n        this.elements[b] = val;\r\n    }\r\n}\r\n\r\nexport default Heap;","import {Point, Tile} from '../core/Components';\r\nimport Navigator from '../core/Navigator';\r\nimport {Node} from './Node';\r\n\r\n/**\r\n * Pathfinder performs algorithms operations on the grid\r\n * Uses the navigator rank and expand nodes\r\n */\r\nabstract class Pathfinder\r\n{\r\n    protected recentSearch: Node[] = [];\r\n    protected navigator: Navigator;\r\n\r\n    constructor(navigator: Navigator) {\r\n        this.navigator = navigator;\r\n    }\r\n\r\n    setNavigator(navigator: Navigator) {\r\n        this.navigator = navigator;\r\n    }\r\n\r\n    getNavigator() {\r\n        return this.navigator;\r\n    }\r\n\r\n    getRecentNodes() {\r\n        return this.recentSearch.length;\r\n    }\r\n\r\n    clearRecentSearch() {\r\n        this.recentSearch = [];\r\n    }\r\n\r\n    addRecent(node: Node) {\r\n        this.recentSearch.push(node);\r\n    }\r\n\r\n    /**\r\n     * Finds the best path between initial and goal on the grid\r\n     * and returns it in an array\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    abstract findPath(initial: Point, goal: Point): Tile[];\r\n\r\n    /**\r\n     * Reconstructs the solution using the recent search array and calls a\r\n     * function for every generation and for every expansion\r\n     * @param onGeneration to determine what to do when a node's generation is expanded\r\n     */\r\n    reconstructSolution(onGeneration: (nodes: Node) => void) {\r\n        for(let node of this.recentSearch) {\r\n            onGeneration(node);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Reconstructs the path from a tree, given the bottomLeaf, and\r\n * returns the shortest path in an array\r\n * @param bottomLeaf bottom of the tree to start from\r\n */\r\nexport function reconstructPath(bottomLeaf: Node): Tile[] {\r\n    return reconstructPathReversed(bottomLeaf).reverse();\r\n}\r\n\r\n/**\r\n * Reconstructs the path from a tree, given the bottomLeaf, and\r\n * returns the shortest path in an array\r\n * @param bottomLeaf bottom of the tree to start from\r\n */\r\nexport function reconstructPathReversed(bottomLeaf: Node): Tile[] {\r\n    let path: Tile[] = [];\r\n    while(bottomLeaf.parent !== null) {\r\n        path.push(bottomLeaf.tile);\r\n        bottomLeaf = bottomLeaf.parent;\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default Pathfinder;","import {Tile} from '../core/Components';\r\n\r\n/**\r\n * Represents a search Tree Node\r\n */\r\nexport class Node\r\n{\r\n    parent: Node | null = null; //parent node\r\n    readonly children: Node[] = [];\r\n    readonly tile: Tile; //stores a graph node\r\n\r\n    constructor(tile: Tile) {\r\n        this.tile = tile;\r\n    }\r\n\r\n    addChild(child: Node) {\r\n        child.parent = this;\r\n        this.children.push(child);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents an heuristic weighted aStar search tree node\r\n */\r\nexport class AStarNode extends Node\r\n{\r\n    readonly g: number; //path cost\r\n    readonly fScore: number; //heuristic\r\n\r\n    constructor(tile: Tile, g: number, fScore: number) {\r\n        super(tile);\r\n        this.g = g;\r\n        this.fScore = fScore;\r\n    }\r\n\r\n    f() {\r\n        return this.fScore;\r\n    }\r\n}\r\n","import {HashTable, stringify} from '../structures/Hash';\r\nimport Heap from '../structures/Heap';\r\nimport Pathfinder, {reconstructPath} from './Pathfinder';\r\nimport {Point, Tile} from '../core/Components';\r\nimport {AStarNode} from './Node';\r\nimport Navigator from '../core/Navigator';\r\nimport {euclidean, HeuristicFunc} from './Heuristics';\r\n\r\nclass AStarPathfinder extends Pathfinder\r\n{\r\n    private readonly heuristic: HeuristicFunc = (a: Point, b: Point) => euclidean(a,b);\r\n\r\n    constructor(navigator: Navigator, func?: HeuristicFunc) {\r\n        super(navigator);\r\n        if(func !== undefined) {\r\n            this.heuristic = func;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Performs aStar algorithm on the grid given an initial and goal point\r\n     * Always returns the shortest path, and performs well on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point): Tile[] {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const openSet = new Heap<AStarNode>(\r\n            (a, b) => a.f() < b.f()\r\n        );\r\n        const closedSet = new HashTable<number>();\r\n        const root = new AStarNode(\r\n            grid.get(initial), 0, 0\r\n        );\r\n        openSet.push(root);\r\n        closedSet.add(stringify(initial), root.f());\r\n        while (!openSet.isEmpty()) {\r\n            const currentNode = openSet.pop();\r\n            this.addRecent(currentNode);\r\n            const currentPoint = currentNode.tile.point;\r\n            if (this.navigator.equals(currentPoint, goal)) {\r\n                return reconstructPath(currentNode);\r\n            }\r\n            for (const neighbor of this.navigator.neighbors(currentPoint)) {\r\n                const neighborPoint = neighbor.point;\r\n                const neighborKey = stringify(neighborPoint);\r\n                const g = currentNode.g + this.stepCost(currentPoint, neighborPoint);\r\n                const f = g + this.heuristic(neighborPoint, goal);\r\n                if (!closedSet.has(neighborKey) || f < closedSet.get(neighborKey)!) {\r\n                    const neighborNode = new AStarNode(\r\n                        neighbor, g, f\r\n                    );\r\n                    currentNode.addChild(neighborNode);\r\n                    openSet.push(neighborNode);\r\n                    closedSet.add(neighborKey, neighborNode.f());\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * The step-cost function to be used, calculating the cost from\r\n     * currentPoint to neighborPoint. Uses the stepCost function provided by the\r\n     * navigator by default but can be overridden\r\n     * @param currentPoint\r\n     * @param neighborPoint\r\n     */\r\n    stepCost(currentPoint: Point, neighborPoint: Point) {\r\n        return this.navigator.cost(currentPoint, neighborPoint);\r\n    }\r\n}\r\n\r\nexport default AStarPathfinder;","import Pathfinder, {reconstructPath} from './Pathfinder';\r\nimport {Point, Tile} from '../core/Components';\r\nimport {HashSet, stringify} from '../structures/Hash';\r\nimport {Node} from './Node';\r\n\r\nclass BFSPathfinder extends Pathfinder\r\n{\r\n    /**\r\n     * Implementation of BFS to find the shortest path from initial to point\r\n     * Always returns the shortest path, but performs poorly on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point): Tile[] {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const queue: Node[] = []; //fifo, stores nodes on the frontier\r\n        const visited = new HashSet();\r\n        const root = new Node(grid.get(initial));\r\n        queue.push(root); //enqueue\r\n        visited.add(stringify(initial));\r\n        while(queue.length !== 0) { //not empty\r\n            const currentNode = queue.shift()!; //dequeue\r\n            this.addRecent(currentNode);\r\n            const currentPoint = currentNode.tile.point;\r\n            if(this.navigator.equals(currentPoint, goal)) {\r\n                return reconstructPath(currentNode);\r\n            }\r\n            for(const neighbor of this.navigator.neighbors(currentPoint)) {\r\n                const neighborKey = stringify(neighbor.point);\r\n                if(!visited.has(neighborKey)) {\r\n                    const neighborNode = new Node(neighbor);\r\n                    currentNode.addChild(neighborNode);\r\n                    queue.push(neighborNode); //enqueue\r\n                    visited.add(neighborKey);\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\nexport default BFSPathfinder;","/**\r\n * Stack node\r\n */\r\nclass Node<E>\r\n{\r\n    next: Node<E> | null = null;\r\n    data: E;\r\n\r\n    constructor(data: E) {\r\n        this.data = data;\r\n    }\r\n}\r\n\r\n/**\r\n * Minimalist Implementation of the stack data structure\r\n */\r\nclass Stack<E>\r\n{\r\n    private top: Node<E> | null = null;\r\n    private size: number = 0;\r\n\r\n    peek() {\r\n        return this.top != null ? this.top.data : undefined;\r\n    }\r\n\r\n    push(e: E) {\r\n        let node = new Node(e);\r\n        node.next = this.top;\r\n        this.top = node;\r\n        this.size++;\r\n    }\r\n\r\n    pop() {\r\n        let top = this.peek();\r\n        if(this.top != null) {\r\n            this.top = this.top.next;\r\n            this.size--;\r\n        }\r\n        return top;\r\n    }\r\n\r\n    isEmpty() {\r\n        return this.size === 0;\r\n    }\r\n\r\n    getSize() {\r\n        return this.size;\r\n    }\r\n}\r\n\r\nexport default Stack;","import Pathfinder, {reconstructPath} from './Pathfinder';\r\nimport {Point, Tile} from '../core/Components';\r\nimport {HashSet, stringify} from '../structures/Hash';\r\nimport {Node} from './Node';\r\nimport Stack from '../structures/Stack';\r\n\r\nclass DFSPathfinder extends Pathfinder\r\n{\r\n    /**\r\n     * Calls DFS between a start and goal point, will typically not find the 'Best' path,\r\n     * and will instead find the best path capable for the algorithm\r\n     * As this algorithm is non optimal it should only be used for educational purposes\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point): Tile[] {\r\n        this.clearRecentSearch();\r\n        let grid = this.navigator.getGrid();\r\n        let root = new Node(grid.get(initial));\r\n        const stack = new Stack<Node>();\r\n        stack.push(root);\r\n        const visited = new HashSet();\r\n        visited.add(stringify(initial));\r\n        while(!stack.isEmpty()) {\r\n            const currentNode = stack.pop()!;\r\n            this.addRecent(currentNode);\r\n            const currentPoint = currentNode.tile.point;\r\n            if(this.navigator.equals(currentPoint, goal)) {\r\n                return reconstructPath(currentNode);\r\n            }\r\n            let neighbors = this.navigator.neighbors(currentPoint).reverse();\r\n            for(const neighbor of neighbors){\r\n                let neighborKey = stringify(neighbor.point);\r\n                if(!visited.has(neighborKey)) {\r\n                    const neighborNode = new Node(neighbor);\r\n                    currentNode.addChild(neighborNode);\r\n                    stack.push(neighborNode);\r\n                    visited.add(neighborKey);\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\nexport default DFSPathfinder;\r\n","import {HashTable, stringify} from '../structures/Hash';\r\nimport Heap from '../structures/Heap';\r\nimport Pathfinder, {reconstructPath, reconstructPathReversed} from './Pathfinder';\r\nimport {Point, Tile} from '../core/Components';\r\nimport {AStarNode} from './Node';\r\nimport Navigator from '../core/Navigator';\r\nimport {euclidean, HeuristicFunc} from './Heuristics';\r\n\r\nclass BiAStarPathfinder extends Pathfinder\r\n{\r\n    private readonly heuristic: HeuristicFunc = (a: Point, b: Point) => euclidean(a,b);\r\n\r\n    constructor(navigator: Navigator, func?: HeuristicFunc) {\r\n        super(navigator);\r\n        if(func !== undefined) {\r\n            this.heuristic = func;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Performs aStar algorithm on the grid given an initial and goal point\r\n     * Always returns the shortest path, and performs well on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point): Tile[] {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const startOpenSet = new Heap<AStarNode>(\r\n            (a, b) => a.f() < b.f()\r\n        );\r\n        const startClosedSet = new HashTable<AStarNode>();\r\n        const endOpenSet = new Heap<AStarNode>(\r\n            (a, b) => a.f() < b.f()\r\n        );\r\n        const endClosedSet = new HashTable<AStarNode>();\r\n        const initialRoot = new AStarNode(\r\n            grid.get(initial), 0, 0\r\n        );\r\n        startOpenSet.push(initialRoot);\r\n        startClosedSet.add(stringify(initial), initialRoot);\r\n        const goalRoot = new AStarNode(\r\n            grid.get(goal), 0, 0\r\n        );\r\n        endOpenSet.push(goalRoot);\r\n        endClosedSet.add(stringify(goal), goalRoot);\r\n        while (!startOpenSet.isEmpty() && !endOpenSet.isEmpty()) {\r\n            //expand startOpenSet\r\n            const startCurrentNode = startOpenSet.pop();\r\n            this.addRecent(startCurrentNode);\r\n            const startCurrentPoint = startCurrentNode.tile.point;\r\n            const startCurrentPointKey = stringify(startCurrentPoint);\r\n            if(endClosedSet.has(startCurrentPointKey)) {\r\n                if(startCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startCurrentNode.parent\r\n                    ).concat(reconstructPathReversed(\r\n                        endClosedSet.get(startCurrentPointKey)!\r\n                    )).concat(\r\n                        grid.get(goal)\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n            }\r\n            for (const neighbor of this.navigator.neighbors(startCurrentPoint)) {\r\n                const neighborPoint = neighbor.point;\r\n                const neighborKey = stringify(neighborPoint);\r\n                const g = startCurrentNode.g + this.stepCost(startCurrentPoint, neighborPoint);\r\n                const f = g + this.heuristic(neighborPoint, goal);\r\n                if (!startClosedSet.has(neighborKey) || f < startClosedSet.get(neighborKey)!.f()) {\r\n                    const neighborNode = new AStarNode(\r\n                        neighbor, g, f\r\n                    );\r\n                    startCurrentNode.addChild(neighborNode);\r\n                    startOpenSet.push(neighborNode);\r\n                    startClosedSet.add(neighborKey, neighborNode);\r\n                }\r\n            }\r\n            //expand closedOpenSet\r\n            const endCurrentNode = endOpenSet.pop();\r\n            this.addRecent(endCurrentNode);\r\n            const endCurrentPoint = endCurrentNode.tile.point;\r\n            const endCurrentPointKey = stringify(endCurrentPoint);\r\n            if(startClosedSet.has(endCurrentPointKey)) {\r\n                if(endCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startClosedSet.get(endCurrentPointKey)!\r\n                    ).concat(reconstructPathReversed(\r\n                        endCurrentNode.parent!\r\n                    )).concat(\r\n                        grid.get(goal)\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n\r\n            }\r\n            for (const neighbor of this.navigator.neighbors(endCurrentPoint)) {\r\n                const neighborPoint = neighbor.point;\r\n                const neighborKey = stringify(neighborPoint);\r\n                const g = endCurrentNode.g + this.stepCost(endCurrentPoint, neighborPoint);\r\n                const f = g + this.heuristic(neighborPoint, initial);\r\n                if (!endClosedSet.has(neighborKey) || f < endClosedSet.get(neighborKey)!.f()) {\r\n                    const neighborNode = new AStarNode(\r\n                        neighbor, g, f\r\n                    );\r\n                    endCurrentNode.addChild(neighborNode);\r\n                    endOpenSet.push(neighborNode);\r\n                    endClosedSet.add(neighborKey, neighborNode);\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * The step-cost function to be used, calculating the cost from\r\n     * currentPoint to neighborPoint. Uses the stepCost function provided by the\r\n     * navigator by default but can be overridden\r\n     * @param currentPoint\r\n     * @param neighborPoint\r\n     */\r\n    stepCost(currentPoint: Point, neighborPoint: Point) {\r\n        return this.navigator.cost(currentPoint, neighborPoint);\r\n    }\r\n}\r\n\r\nexport default BiAStarPathfinder;","import Pathfinder, {reconstructPath, reconstructPathReversed} from './Pathfinder';\r\nimport {Point, Tile} from '../core/Components';\r\nimport {HashTable, stringify} from '../structures/Hash';\r\nimport {Node} from './Node';\r\n\r\nclass BiBFSPathfinder extends Pathfinder\r\n{\r\n    /**\r\n     * Implementation of BFS to find the shortest path from initial to point\r\n     * Always returns the shortest path, but performs poorly on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point): Tile[] {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const startVisited = new HashTable<Node>();\r\n        const endVisited = new HashTable<Node>();\r\n        const startQueue: Node[] = [];\r\n        const endQueue: Node[] = [];\r\n        const initialRoot = new Node(grid.get(initial));\r\n        startQueue.push(initialRoot);\r\n        startVisited.add(stringify(initial), initialRoot);\r\n        const goalRoot = new Node(grid.get(goal));\r\n        endQueue.push(goalRoot);\r\n        endVisited.add(stringify(goal), goalRoot);\r\n        while(startQueue.length !== 0 && endQueue.length !== 0) {\r\n            //expand startQueue\r\n            const startCurrentNode = startQueue.shift()!;\r\n            this.addRecent(startCurrentNode);\r\n            const startCurrentPoint = startCurrentNode.tile.point;\r\n            const startCurrentPointKey = stringify(startCurrentPoint);\r\n            if(endVisited.has(startCurrentPointKey)) {\r\n                if(startCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startCurrentNode.parent\r\n                    ).concat(reconstructPathReversed(\r\n                        endVisited.get(startCurrentPointKey)!\r\n                    )).concat(\r\n                        grid.get(goal)\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n            }\r\n            for(const neighbor of this.navigator.neighbors(startCurrentPoint)) {\r\n                const neighborKey = stringify(neighbor.point);\r\n                if(!startVisited.has(neighborKey)) {\r\n                    const neighborNode = new Node(neighbor);\r\n                    startCurrentNode.addChild(neighborNode);\r\n                    startQueue.push(neighborNode);\r\n                    startVisited.add(neighborKey, neighborNode);\r\n                }\r\n            }\r\n            //expand endQueue\r\n            const endCurrentNode = endQueue.shift()!;\r\n            this.addRecent(endCurrentNode);\r\n            const endCurrentPoint = endCurrentNode.tile.point;\r\n            const endCurrentPointKey = stringify(endCurrentPoint);\r\n            if(startVisited.has(endCurrentPointKey)) {\r\n                if(endCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startVisited.get(endCurrentPointKey)!\r\n                    ).concat(reconstructPathReversed(\r\n                        endCurrentNode.parent\r\n                    )).concat(\r\n                        grid.get(goal)\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n            }\r\n            for(const neighbor of this.navigator.neighbors(endCurrentPoint)) {\r\n                const neighborKey = stringify(neighbor.point);\r\n                if(!endVisited.has(neighborKey)) {\r\n                    const neighborNode = new Node(neighbor);\r\n                    endCurrentNode.addChild(neighborNode);\r\n                    endQueue.push(neighborNode);\r\n                    endVisited.add(neighborKey, neighborNode);\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\nexport default BiBFSPathfinder;","import Navigator from '../core/Navigator';\r\nimport PlusNavigator from '../core/PlusNavigator';\r\nimport AsteriskNavigator from '../core/AsteriskNavigator';\r\nimport {Point} from '../core/Components';\r\nimport {Grid} from '../core/Grid';\r\nimport {chebyshev, euclidean, HeuristicFunc, manhattan, nullHeuristic, octile} from './Heuristics';\r\nimport Pathfinder from './Pathfinder';\r\nimport AStarPathfinder from './AStar';\r\nimport BFSPathfinder from './BFS';\r\nimport DFSPathfinder from './DFS';\r\nimport BiAStarPathfinder from './BidirectionalAStar';\r\nimport BiBFSPathfinder from \"./BidirectionalBFS\";\r\n\r\nconst CREATE_NAVIGATOR: {[key: string]: ((grid: Grid) => Navigator)} = {\r\n    'plus': (grid: Grid) => new PlusNavigator(grid),\r\n    'asterisk': (grid: Grid) => new AsteriskNavigator(grid)\r\n}\r\n\r\nconst CREATE_HEURISTIC: {[key: string]: (() => HeuristicFunc)} = {\r\n    'manhattan': () => (a,b) => manhattan(a,b),\r\n    'euclidean': () => (a,b) => euclidean(a,b),\r\n    'chebyshev': () => (a,b) => chebyshev(a,b),\r\n    'octile': () => (a,b) => octile(a,b),\r\n    'null': () => (a,b) => nullHeuristic(a,b)\r\n}\r\n\r\nconst CREATE_PATHFINDER: {[key: string]: ((navigator: Navigator, heuristic: HeuristicFunc) => Pathfinder)} = {\r\n    'dijkstra': (navigator) => {\r\n        return new AStarPathfinder(navigator, (a,b) => nullHeuristic(a,b));\r\n    },\r\n    'best-first': (navigator, heuristic) => {\r\n        return new (class BestFirst extends AStarPathfinder {\r\n            stepCost(currentPoint: Point, neighborPoint: Point) {\r\n                return 0;\r\n            }\r\n        })(navigator, heuristic);\r\n    },\r\n    'a*': (navigator, heuristic) => {\r\n        return new AStarPathfinder(navigator, heuristic);\r\n    },\r\n    'bfs': (navigator) => {\r\n        return new BFSPathfinder(navigator);\r\n    },\r\n    'dfs': (navigator) => {\r\n        return new DFSPathfinder(navigator);\r\n    },\r\n    'bi-a*': (navigator, heuristic) => {\r\n        return new BiAStarPathfinder(navigator, heuristic);\r\n    },\r\n    'bi-dijkstra': (navigator) => {\r\n        return new BiAStarPathfinder(navigator, (a,b) => nullHeuristic(a,b));\r\n    },\r\n    'bi-bfs': (navigator) => {\r\n        return new BiBFSPathfinder(navigator);\r\n    }\r\n}\r\n\r\nclass PathfinderFactory\r\n{\r\n    static usesHeuristic(algorithm: string) {\r\n        return algorithm === 'a*' || algorithm === 'bi-a*' ||\r\n            algorithm === 'best-first';\r\n    }\r\n\r\n    static hasBidirectional(algorithm: string) {\r\n        return CREATE_PATHFINDER['bi-' + algorithm] != null;\r\n    }\r\n\r\n    static getBidirectional(algorithm: string) {\r\n        return 'bi-' + algorithm;\r\n    }\r\n\r\n    /**\r\n     * Creates a pathfinder with a navigator with the right algorithm and heuristic\r\n     * @param navigator\r\n     * @param algorithm\r\n     * @param heuristic\r\n     */\r\n    static getPathfinder(navigator: Navigator, algorithm: string, heuristic?: string) {\r\n        const heuristicKey = heuristic !== undefined ? heuristic : 'null';\r\n        const createHeuristic = CREATE_HEURISTIC[heuristicKey.toLowerCase()];\r\n        if(createHeuristic == null) {\r\n            throw new Error('No such heuristic function exists')\r\n        }\r\n        const createPathfinder = CREATE_PATHFINDER[algorithm.toLowerCase()];\r\n        if(createPathfinder == null) {\r\n            throw new Error('No such pathfinding algorithm exists')\r\n        }\r\n        return createPathfinder(navigator, createHeuristic());\r\n    }\r\n\r\n    /**\r\n     * Creates a navigator from grid and navigator key\r\n     * @param grid\r\n     * @param key\r\n     */\r\n    static getNavigator(grid: Grid, key: string) {\r\n        const createNavigator = CREATE_NAVIGATOR[key.toLowerCase()];\r\n        if(createNavigator == null) {\r\n            throw new Error('No such navigator pattern exists')\r\n        }\r\n        return createNavigator(grid);\r\n    }\r\n}\r\n\r\nexport default PathfinderFactory;\r\n\r\n","import SquareGrid, {Grid} from '../core/Grid';\r\nimport {Point, Tile, createTile} from '../core/Components';\r\n\r\nconst LIMIT = 2;\r\n\r\ninterface Chamber\r\n{\r\n    topLeft: Point; //min\r\n    bottomRight: Point; //max\r\n}\r\n\r\nclass MazeGenerator\r\n{\r\n    private readonly width: number;\r\n    private readonly height: number;\r\n\r\n    constructor(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    /**\r\n     * Performs the recursive division maze generation algorithm on a new empty grid\r\n     * by bisecting parts until the maze can no longer be bisected\r\n     * Params must be within bounds and create a chamber\r\n     * @param topLeft optional parameter to specify what point the maze should start from\r\n     *  This should not be further up/left than (1,1)\r\n     * @param bottomRight optional parameter to specify how far down and right the maze will go\r\n     *  This should not be further right/down than (width-2,height-2)\r\n     */\r\n    generateMaze(topLeft?: Point, bottomRight?: Point) {\r\n        const grid = new SquareGrid(this.width, this.height);\r\n        if(topLeft === undefined) {\r\n            topLeft = {\r\n                x: 1, y: 1\r\n            }\r\n        }\r\n        if(bottomRight === undefined) {\r\n            bottomRight = {\r\n                x: grid.getWidth()-2,\r\n                y: grid.getHeight()-2\r\n            }\r\n        }\r\n        for(let x = topLeft.x - 1; x <= bottomRight.x + 1; x++) {\r\n            MazeGenerator.draw(grid,{\r\n                point: {\r\n                    x: x, y: topLeft.y - 1\r\n                },\r\n                data: createTile(true)\r\n            });\r\n            MazeGenerator.draw(grid,{\r\n                point: {\r\n                    x: x, y: bottomRight.y + 1\r\n                },\r\n                data: createTile(true)\r\n            });\r\n        }\r\n        for(let y = topLeft.y - 1; y <= bottomRight.y + 1; y++) {\r\n            MazeGenerator.draw(grid,{\r\n                point: {\r\n                    x: topLeft.x - 1, y: y\r\n                },\r\n                data: createTile(true)\r\n            });\r\n            MazeGenerator.draw(grid,{\r\n                point: {\r\n                    x: bottomRight.x + 1, y: y\r\n                },\r\n                data: createTile(true)\r\n            });\r\n        }\r\n        this.divide(grid,{\r\n            topLeft: topLeft,\r\n            bottomRight: bottomRight,\r\n        });\r\n        return grid;\r\n    }\r\n\r\n    /**\r\n     * Draws a list of tiles to the grid\r\n     * @param grid\r\n     * @param tiles\r\n     */\r\n    private static drawArr(grid: Grid, tiles: Tile[]) {\r\n        for(let tile of tiles) {\r\n            MazeGenerator.draw(grid, tile);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws a tile to the grid\r\n     * @param grid\r\n     * @param tile\r\n     */\r\n    private static draw(grid: Grid, tile: Tile) {\r\n        grid.mutateTile(tile);\r\n    }\r\n\r\n    /**\r\n     * Create a line between a region, with an open hole, in a chamber,\r\n     * and call bisection algorithm on it, and call division algorithms on\r\n     * its split chambers until no chambers can be bisected\r\n     * @param grid\r\n     * @param chamber\r\n     */\r\n    divide(grid: Grid, chamber: Chamber) {\r\n        const width = widthOf(chamber);\r\n        const height = heightOf(chamber);\r\n        const min = chamber.topLeft;\r\n        const max = chamber.bottomRight;\r\n        if(divideWidth(width,height)) {\r\n            if(width > LIMIT) {\r\n                //calculate axis\r\n                const randY = getRand(\r\n                    min.y, max.y,\r\n                );\r\n                const randX = getMidPoint(\r\n                    min.x, max.x\r\n                );\r\n                //create axis wall\r\n                const toDraw: Tile[] = [];\r\n                for(let y = min.y; y <= max.y; y++) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: y\r\n                        },\r\n                        data: createTile(true)\r\n                    });\r\n                }\r\n                //create holes in axis wall\r\n                let edgeBlocked = false;\r\n                if(!grid.get({\r\n                    x: randX, y: min.y-1\r\n                }).data.isSolid) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: min.y\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                    edgeBlocked = true;\r\n                }\r\n                if(!grid.get({\r\n                    x: randX, y: max.y+1\r\n                }).data.isSolid) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: max.y\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                    edgeBlocked = true;\r\n                }\r\n                if(!edgeBlocked) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: randY\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                }\r\n                MazeGenerator.drawArr(grid, toDraw);\r\n                //create children chambers and recurse\r\n                const leftChamber = {\r\n                    topLeft: chamber.topLeft,\r\n                    bottomRight: {\r\n                        x: randX-1,\r\n                        y: chamber.bottomRight.y\r\n                    },\r\n                };\r\n                const rightChamber = {\r\n                    topLeft: {\r\n                        x: randX+1,\r\n                        y: chamber.topLeft.y\r\n                    },\r\n                    bottomRight: chamber.bottomRight,\r\n                };\r\n                this.divide(grid, leftChamber);\r\n                this.divide(grid, rightChamber);\r\n            }\r\n        } else {\r\n            if(height > LIMIT) {\r\n                //calculate axis\r\n                const randX = getRand(\r\n                    min.x, max.x,\r\n                );\r\n                const randY = getMidPoint(\r\n                    min.y, max.y\r\n                );\r\n                //draw axis wall\r\n                const toDraw: Tile[] = [];\r\n                for(let x = min.x; x <= max.x; x++) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: x, y: randY\r\n                        },\r\n                        data: createTile(true)\r\n                    });\r\n                }\r\n                //create holes in axis wall\r\n                let edgeBlocked = false;\r\n                if(!grid.get({\r\n                    x: min.x-1, y: randY\r\n                }).data.isSolid) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: min.x, y: randY\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                    edgeBlocked = true;\r\n                }\r\n                if(!grid.get({\r\n                    x: max.x+1, y: randY\r\n                }).data.isSolid) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: max.x, y: randY\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                    edgeBlocked = true;\r\n                }\r\n                if(!edgeBlocked) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: randY\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                }\r\n                MazeGenerator.drawArr(grid, toDraw);\r\n                //create children chambers and recurse\r\n                const topChamber = {\r\n                    topLeft: chamber.topLeft,\r\n                    bottomRight: {\r\n                        x: chamber.bottomRight.x,\r\n                        y: randY-1\r\n                    },\r\n                };\r\n                const bottomChamber = {\r\n                    topLeft: {\r\n                        x: chamber.topLeft.x,\r\n                        y: randY+1\r\n                    },\r\n                    bottomRight: chamber.bottomRight,\r\n                };\r\n                this.divide(grid, topChamber);\r\n                this.divide(grid, bottomChamber);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction divideWidth(width: number, height: number) {\r\n    return width >= height;\r\n}\r\n\r\nfunction widthOf(chamber: Chamber) {\r\n    return chamber.bottomRight.x - chamber.topLeft.x + 1;\r\n}\r\n\r\nfunction heightOf(chamber: Chamber) {\r\n    return chamber.bottomRight.y - chamber.topLeft.y + 1;\r\n}\r\n\r\n/**\r\n * Returns the 'midpoint' to be used\r\n * @param min\r\n * @param max\r\n */\r\nfunction getMidPoint(min: number, max: number) {\r\n    const range = max - min;\r\n    if(range >= 20) {\r\n        return ((min+max)/2) >> 0;\r\n    } else if(range > 5) {\r\n        const mid = ((min+max)/2) >> 0;\r\n        const points = [mid, mid+1];\r\n        return points[getRand(0,points.length-1)];\r\n    } else {\r\n        return getRand(min+1,max-1);\r\n    }\r\n}\r\n\r\n/**\r\n * Generate a random number between min and max-1 then increment the number\r\n * if it is larger than or equal to excluded, inclusive for min and max\r\n * @param min\r\n * @param max\r\n * @param excluded\r\n */\r\nfunction getRandEx(min: number, max: number, excluded: number) {\r\n    let rand = getRand(min, max-1);\r\n    return rand >= excluded ? ++rand : rand;\r\n}\r\n\r\n/**\r\n * Generate a random number between min and max, inclusive for min and max\r\n * @param min\r\n * @param max\r\n */\r\nfunction getRand(min: number, max: number) {\r\n    return Math.floor(Math.random() * (max+1-min) + min);\r\n}\r\n\r\nexport default MazeGenerator;","import React, {RefObject} from 'react';\r\nimport GridBackground from './GridBackground';\r\nimport GridForeground from './GridForeground';\r\nimport {Node} from '../../pathfinding/algorithms/Node';\r\nimport PathfindingSettings from '../PathfindingSettings';\r\nimport PathfinderFactory from '../../pathfinding/algorithms/PathfinderFactory';\r\nimport Pathfinder from '../../pathfinding/algorithms/Pathfinder';\r\nimport MazeGenerator from '../../pathfinding/algorithms/MazeGenerator';\r\nimport {Point, Tile} from '../../pathfinding/core/Components';\r\nimport {euclidean} from '../../pathfinding/algorithms/Heuristics';\r\n\r\ninterface IProps {\r\n    tileWidth: number,\r\n    settings: Readonly<PathfindingSettings>,\r\n    topMargin: number,\r\n    onChangeVisualizing: (visualizing: boolean) => void;\r\n}\r\n\r\ninterface IState {\r\n    tilesX: number,\r\n    tilesY: number,\r\n    time: number,\r\n    length: number\r\n}\r\n\r\nclass PathfindingVisualizer extends React.Component<IProps,IState>\r\n{\r\n    //references to expose background and foreground grids to parent\r\n    private background: RefObject<GridBackground> = React.createRef();\r\n    private foreground: RefObject<GridForeground> = React.createRef();\r\n\r\n    private visualized = false;\r\n    private visualizing = false;\r\n    private visualTimeouts: NodeJS.Timeout[]  = [];\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        const tilesX = Math.floor(window.screen.availWidth / this.props.tileWidth) + 1;\r\n        const tilesY = Math.floor((window.screen.availHeight - 75 - 30) / this.props.tileWidth) + 1;\r\n        this.state = {\r\n            tilesX: tilesX,\r\n            tilesY: tilesY,\r\n            time: 0,\r\n            length: 0\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Performs the pathfinding algorithm on the grid and visualizes it\r\n     */\r\n    doPathfinding = () => {\r\n        const settings = this.props.settings;\r\n        const pathfinder = this.getPathfinder(settings);\r\n        const path = this.findPath(pathfinder);\r\n        if(settings.visualizeAlg) {\r\n            const nodes: Node[] = [];\r\n            pathfinder.reconstructSolution((node) => {\r\n                nodes.push(node);\r\n            });\r\n            this.visualizeGenerations(nodes);\r\n        }\r\n        this.drawPath(path);\r\n    }\r\n\r\n    /**\r\n     * Performs the pathfinding algorithm on the grid and visualizes it with delays between successive\r\n     * node generations\r\n     */\r\n    doDelayedPathfinding = () => {\r\n        this.clearVisualization();\r\n        this.clearPath();\r\n        const settings = this.props.settings;\r\n        this.visualized = false;\r\n        const foreground = this.foreground.current!;\r\n        foreground.toggleDisable();\r\n        if(!this.visualizing) {\r\n            this.visualizing = true;\r\n            this.props.onChangeVisualizing(this.visualizing);\r\n            const pathfinder = this.getPathfinder(settings);\r\n            const path = this.findPath(pathfinder);\r\n            const increment = settings.delayInc;\r\n            const promises: Promise<NodeJS.Timeout>[] = []; //to call function when timeouts finish\r\n            this.visualTimeouts = [];\r\n            let delay = 0;\r\n            if(settings.visualizeAlg) {\r\n                //reconstruct solution by visualizing each generation\r\n                pathfinder.reconstructSolution((node) => {\r\n                    const promise = new Promise<NodeJS.Timeout>((resolve) => {\r\n                        //each generation gets a higher timeout\r\n                        const timeout = setTimeout(() => {\r\n                            this.visualizeGeneration(node);\r\n                            resolve(timeout);\r\n                        }, delay);\r\n                        this.visualTimeouts.push(timeout);\r\n                        delay += increment;\r\n                    });\r\n                    promises.push(promise);\r\n                });\r\n            }\r\n            //call functions when timeouts finish\r\n            Promise.all(promises).then(() => {\r\n                this.drawPath(path);\r\n                foreground.toggleDisable();\r\n                this.visualizing = false;\r\n                this.visualized = true;\r\n                this.props.onChangeVisualizing(this.visualizing);\r\n            });\r\n        } else {\r\n            for (let i = 0; i < this.visualTimeouts.length; i++) {\r\n                clearTimeout(this.visualTimeouts[i]);\r\n            }\r\n            this.visualizing = false;\r\n            this.props.onChangeVisualizing(this.visualizing);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the pathfinder for the settings\r\n     * @param settings\r\n     */\r\n    private getPathfinder = (settings: PathfindingSettings) => {\r\n        const algorithmKey = settings.algorithm;\r\n        const algorithm = settings.bidirectional && PathfinderFactory.hasBidirectional(algorithmKey) ?\r\n            PathfinderFactory.getBidirectional(algorithmKey) : algorithmKey;\r\n        const navigator = PathfinderFactory.getNavigator(this.foreground.current!.state.grid, settings.navigatorKey);\r\n        return PathfinderFactory.getPathfinder(navigator, algorithm, settings.heuristicKey);\r\n    }\r\n\r\n    /**\r\n     * Find path with a given pathfinder, includes benchmarking\r\n     * @param pathfinder\r\n     */\r\n    private findPath = (pathfinder: Pathfinder) => {\r\n        const foreground = this.foreground.current!;\r\n        const t0 = performance.now();\r\n        const path = pathfinder.findPath(foreground.state.initial, foreground.state.goal);\r\n        const t1 = performance.now();\r\n        const t2 = +(t1 - t0).toFixed(3);\r\n        this.setState({\r\n            time: t2\r\n        });\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Draw path on the grid and change length on ui\r\n     * @param path\r\n     */\r\n    private drawPath = (path: Tile[]) => {\r\n        const foreground = this.foreground.current!\r\n        path.unshift(this.foreground.current!.state.grid.get(foreground.state.initial));\r\n        this.foreground.current!.drawPath(path);\r\n        this.setState({\r\n            length: calcLength(path)\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called when child foreground moves a tile\r\n     */\r\n    private onTilesDragged = () => {\r\n        if(this.visualized) {\r\n            this.clearVisualization();\r\n            this.doPathfinding();\r\n            this.visualized = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a maze on the grid foreground\r\n     */\r\n    createMaze = () => {\r\n        if(this.visualizing) {\r\n            return;\r\n        }\r\n        this.clearTiles();\r\n        this.clearPath();\r\n        this.clearVisualization();\r\n        const prevGrid = this.foreground.current!.state.grid;\r\n        const generator = new MazeGenerator(prevGrid.getWidth(), prevGrid.getHeight());\r\n        const end = this.calcEndPointInView();\r\n        const topLeft = {\r\n            x: 1, y: 1\r\n        };\r\n        const bottomRight = {\r\n            x: end.x-2, y: end.y-2\r\n        };\r\n        const grid = generator.generateMaze(topLeft, bottomRight);\r\n        this.foreground.current!.drawGrid(grid);\r\n        this.setPositions({\r\n            x: end.x-2,\r\n            y: end.y-2\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Calculate the end/goal point in view of the screen\r\n     */\r\n    calcEndPointInView() {\r\n        const xEnd = window.innerWidth / this.props.tileWidth;\r\n        const yEnd = (window.innerHeight - this.props.topMargin - 30) / this.props.tileWidth;\r\n        const xFloor = Math.floor(xEnd);\r\n        const yFloor = Math.floor(yEnd);\r\n        const xDecimal = xEnd - xFloor;\r\n        const yDecimal = yEnd - yFloor\r\n        return {\r\n            x: xDecimal > 0.05 ? Math.ceil(xEnd) : xFloor,\r\n            y: yDecimal > 0.05 ? Math.ceil(yEnd) : yFloor\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the positions in the grid foreground\r\n     */\r\n    private setPositions = (endPoint: Point) => {\r\n        this.foreground.current!.moveInitial({\r\n            x: 1, y:1\r\n        });\r\n        this.foreground.current!.moveGoal(endPoint);\r\n    }\r\n\r\n    clearPath = () => {\r\n        this.foreground.current!.erasePath();\r\n    }\r\n\r\n    clearTiles = () => {\r\n        this.foreground.current!.clearTiles();\r\n    }\r\n\r\n    clearVisualization = () => {\r\n        this.visualized = false;\r\n        this.background.current!.clear();\r\n    }\r\n\r\n    private visualizeGenerations = (generations: Node[]) => {\r\n        this.background.current!.visualizeGenerations(generations);\r\n        this.visualized = true;\r\n    }\r\n\r\n    private visualizeGeneration = (generation: Node) => {\r\n        this.background.current!.visualizeGeneration(generation);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <div id='info-margin' className='info-margin'>\r\n                    <div className='info-text'>Length: {this.state.length}</div>\r\n                    <div className='info-text'>Time: {this.state.time} ms</div>\r\n                </div>\r\n                <GridBackground ref={this.background} tileWidth={this.props.tileWidth}\r\n                                tilesX={this.state.tilesX} tilesY={this.state.tilesY}/>\r\n                <GridForeground ref={this.foreground} topMargin={this.props.topMargin}\r\n                                onTilesDragged={this.onTilesDragged} tileWidth={this.props.tileWidth}\r\n                                tilesX={this.state.tilesX} tilesY={this.state.tilesY}/>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction calcLength(path: Tile[]) {\r\n    let len = 0;\r\n    for (let i = 0; i < path.length - 1; i++) {\r\n        len += euclidean(path[i].point, path[i + 1].point);\r\n    }\r\n    return +(len).toFixed(3);\r\n}\r\n\r\nfunction isMobile() {\r\n    return /Android|webOS|iPhone|iPad|Mac|Macintosh|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\r\n}\r\n\r\n\r\nexport default PathfindingVisualizer;","import React from 'react';\r\n\r\ninterface IProps {\r\n    boxStyle: string,\r\n    defaultChecked: boolean,\r\n    disabled?: boolean,\r\n    onChange: (checked: boolean) => void\r\n}\r\n\r\ninterface IState {\r\n    checked: boolean\r\n}\r\n\r\nclass Checkbox extends React.Component<IProps,IState>\r\n{\r\n    public static defaultProps = {\r\n        disabled: false\r\n    };\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.state = {\r\n            checked: this.props.defaultChecked\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger callback and change checkbox state\r\n     */\r\n    onChange = () => {\r\n        this.setState(prevState => ({\r\n            checked: !prevState.checked\r\n        }), () => this.props.onChange(this.state.checked));\r\n    }\r\n\r\n    render() {\r\n        return(\r\n            <div>\r\n                <input checked={this.state.checked} type='checkbox' disabled={this.props.disabled}\r\n                       className={this.props.boxStyle} onChange={this.onChange}\r\n                >\r\n                </input>\r\n                {this.props.children}\r\n            </div>\r\n        );\r\n    };\r\n}\r\n\r\nexport default Checkbox;","import React from 'react';\r\n\r\ninterface IProps {\r\n    min: number,\r\n    max: number,\r\n    default: number,\r\n    step: number,\r\n    sliderStyle: string,\r\n    onChange: (val: number) => void\r\n}\r\n\r\nclass SteppedRangeSlider extends React.Component<IProps>\r\n{\r\n    /**\r\n     * Trigger callback when slider value is changed\r\n     * @param e\r\n     */\r\n    onChange = (e: React.FormEvent<HTMLInputElement>) => {\r\n        this.props.onChange(Number(e.currentTarget.value));\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <input type='range' list='step-list'\r\n                   defaultValue={this.props.default}\r\n                   min={this.props.min} max={this.props.max}\r\n                   step={this.props.step} className={this.props.sliderStyle}\r\n                   onChange={this.onChange}\r\n            >\r\n            </input>\r\n        );\r\n    }\r\n}\r\n\r\nexport default SteppedRangeSlider;","import React from 'react';\r\n\r\ninterface IProps {\r\n    boxStyle: string,\r\n    defaultChecked: number,\r\n    disabled: boolean,\r\n    onChange: (() => void)[]\r\n}\r\n\r\ninterface IState {\r\n    checked: boolean[];\r\n}\r\n\r\nclass RadioButtonGroup extends React.Component<IProps, IState>\r\n{\r\n    public static defaultProps = {\r\n        disabled: false\r\n    };\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        const checked: boolean[] = [];\r\n        for(let i = 0; i < this.props.onChange.length; i++) {\r\n            checked.push(i === this.props.defaultChecked);\r\n        }\r\n        this.state = {\r\n            checked: checked\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set all radio buttons to checked aside from the index\r\n     * of the one that was changed\r\n     * Trigger callback\r\n     * @param index\r\n     */\r\n    private onChange = (index: number) => {\r\n        const checked: boolean[] = [];\r\n        for(let i = 0; i < this.props.onChange.length; i++) {\r\n            checked.push(i === index);\r\n        }\r\n        this.setState({\r\n            checked: checked\r\n        }, () => this.props.onChange[index]());\r\n    }\r\n\r\n    render() {\r\n        const children = React.Children.toArray(this.props.children);\r\n        const radioButtons: JSX.Element[] = [];\r\n        for(let i = 0; i < this.props.onChange.length; i++) {\r\n            radioButtons.push(\r\n                <div key={i}>\r\n                    <input checked={this.state.checked[i]} type='radio' disabled={this.props.disabled}\r\n                           className={this.props.boxStyle} onChange={() => this.onChange(i)}\r\n                    >\r\n                    </input>\r\n                    {children[i]}\r\n                </div>\r\n            );\r\n        }\r\n        return radioButtons;\r\n    };\r\n}\r\n\r\nexport default RadioButtonGroup;","import React from 'react';\r\nimport Checkbox from '../elements/Checkbox';\r\nimport SteppedRangeSlider from '../elements/SteppedRangeSlider';\r\nimport RadioButtonGroup from '../elements/RadioButtonGroup';\r\n\r\ninterface VisualProps {\r\n    onChangeViz: () => void;\r\n}\r\n\r\nexport class VisualSettings extends React.Component<VisualProps>\r\n{\r\n    render() {\r\n        return (\r\n            <div>\r\n                <div className='draggable-content-title'>Algorithm Visualization</div>\r\n                <Checkbox defaultChecked={true} boxStyle='box'\r\n                          onChange={this.props.onChangeViz}>\r\n                    Show Visualization\r\n                </Checkbox>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\ninterface SpeedProps {\r\n    onChange: (value: number) => void\r\n}\r\n\r\ninterface SpeedState {\r\n    speedText: string\r\n}\r\n\r\nexport class SpeedSettings extends React.Component<SpeedProps, SpeedState>\r\n{\r\n    constructor(props: SpeedProps) {\r\n        super(props);\r\n        this.state = {\r\n            speedText: 'Medium'\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback function to be called when slider is changed\r\n     * Call another callback and change text\r\n     * @param value\r\n     */\r\n    onChangeSpeed = (value: number) => {\r\n        const speedTexts = ['Slowest', 'Slower', 'Medium', 'Faster', 'Fastest'];\r\n        this.setState({\r\n            speedText: speedTexts[value-1]\r\n        })\r\n        this.props.onChange(value);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className='slider-container'>\r\n                <div className='slider-text'>\r\n                    Speed: <div className='speed-text'> {this.state.speedText} </div>\r\n                </div>\r\n                <SteppedRangeSlider min={1} max={5} step={1} default={3}\r\n                                    sliderStyle='slider speed-slider'\r\n                                    onChange={this.onChangeSpeed}\r\n                />\r\n                <datalist id='step-list'>\r\n                    <option>1</option>\r\n                    <option>2</option>\r\n                    <option>3</option>\r\n                    <option>4</option>\r\n                    <option>5</option>\r\n                </datalist>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\ninterface AlgorithmProps {\r\n    onChangeDiagonals: (checked: boolean) => void,\r\n    onChangeBidirectional: (checked: boolean) => void\r\n    disabled: boolean\r\n}\r\n\r\nexport class AlgorithmSettings extends React.Component<AlgorithmProps>\r\n{\r\n    constructor(props: AlgorithmProps) {\r\n        super(props);\r\n        this.state = {\r\n            disabled: false\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <div className='draggable-content-title'>Algorithm</div>\r\n                <Checkbox defaultChecked={true} boxStyle='box'\r\n                          onChange={this.props.onChangeDiagonals}>\r\n                    Allow Diagonals\r\n                </Checkbox>\r\n                <Checkbox defaultChecked={false} boxStyle='box'\r\n                          disabled={this.props.disabled}\r\n                          onChange={this.props.onChangeBidirectional}>\r\n                    Bidirectional\r\n                </Checkbox>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\ninterface HeuristicProps {\r\n    onClickManhattan: () => void,\r\n    onClickEuclidean: () => void,\r\n    onClickChebyshev: () => void,\r\n    onClickOctile: () => void\r\n    disabled: boolean\r\n}\r\n\r\nexport class HeuristicSettings extends React.Component<HeuristicProps>\r\n{\r\n    constructor(props: HeuristicProps) {\r\n        super(props);\r\n        this.state = {\r\n            disabled: false\r\n        }\r\n    }\r\n\r\n    disable = () => {\r\n        this.setState({\r\n            disabled: true\r\n        })\r\n    }\r\n\r\n    enable = () => {\r\n        this.setState({\r\n            disabled: false\r\n        })\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <div className='draggable-content-title'>Heuristic</div>\r\n                <RadioButtonGroup boxStyle='box'\r\n                                  defaultChecked={1}\r\n                                  disabled={this.props.disabled}\r\n                                  onChange={[\r\n                                      this.props.onClickManhattan, this.props.onClickEuclidean,\r\n                                      this.props.onClickChebyshev, this.props.onClickOctile\r\n                                  ]}\r\n                >\r\n                    {[<span key='Manhattan'>Manhattan</span>, <span key='Euclidean'>Euclidean</span>,\r\n                        <span key='Chebyshev'>Chebyshev</span>, <span key='Octile<'>Octile</span>]}\r\n                </RadioButtonGroup>\r\n            </div>\r\n        )\r\n    }\r\n}","import PathfindingSettings, {FASTER, FASTEST, getDefaultSettings, MEDIUM, SLOWER, SLOWEST} from './PathfindingSettings';\r\n\r\nclass SettingsManager\r\n{\r\n    settings: PathfindingSettings = getDefaultSettings();\r\n\r\n    changeAlgo = (algo: string) => {\r\n        this.settings.algorithm = algo;\r\n    }\r\n\r\n    changeVisualize = () => {\r\n        this.settings.visualizeAlg = !this.settings.visualizeAlg;\r\n    }\r\n\r\n    changeBidirectional = () => {\r\n        this.settings.bidirectional = !this.settings.bidirectional;\r\n    }\r\n\r\n    changeDiagonals = (checked: boolean) => {\r\n        this.settings.navigatorKey = checked ? 'asterisk' : 'plus';\r\n    }\r\n\r\n    changeSpeed = (value: number) => {\r\n        const speeds = [SLOWEST, SLOWER, MEDIUM, FASTER, FASTEST];\r\n        this.settings.delayInc = speeds[value-1];\r\n    }\r\n\r\n    changeManhattan = () => {\r\n        this.settings.heuristicKey = 'manhattan';\r\n    }\r\n\r\n    changeEuclidean = () => {\r\n        this.settings.heuristicKey = 'euclidean';\r\n    }\r\n\r\n    changeChebyshev = () => {\r\n        this.settings.heuristicKey = 'chebyshev';\r\n    }\r\n\r\n    changeOctile = () => {\r\n        this.settings.heuristicKey = 'octile';\r\n    }\r\n}\r\n\r\nexport default SettingsManager;","export const SLOWEST = 16;\r\nexport const SLOWER = 12;\r\nexport const MEDIUM = 8;\r\nexport const FASTER = 4;\r\nexport const FASTEST = 2;\r\n\r\ninterface PathfindingSettings\r\n{\r\n    visualizeAlg: boolean,\r\n    delayInc: number\r\n    algorithm: string\r\n    heuristicKey: string\r\n    navigatorKey: string\r\n    bidirectional: boolean\r\n}\r\n\r\nexport function getDefaultSettings() {\r\n    return {\r\n        visualizeAlg: true,\r\n        delayInc: MEDIUM,\r\n        algorithm: 'a*',\r\n        heuristicKey: 'euclidean',\r\n        navigatorKey: 'asterisk',\r\n        bidirectional: false\r\n    }\r\n}\r\n\r\nexport default PathfindingSettings;","import React, {RefObject} from 'react';\r\nimport '../App.css';\r\nimport TopBar from './navbar/TopBar';\r\nimport {MazeButton, VisualizeButton, SettingsButton} from './navbar/Buttons';\r\nimport {AlgorithmDropDown, ClearDropDown} from './navbar/DropDown';\r\nimport DraggablePanel from './elements/DraggablePanel';\r\nimport PathfindingVisualizer from './grid/PathfindingVisualizer';\r\nimport {VisualSettings, SpeedSettings, AlgorithmSettings, HeuristicSettings} from './navbar/SettingPanels';\r\nimport SettingsManager from './SettingsManager';\r\nimport PathfinderFactory from '../pathfinding/algorithms/PathfinderFactory';\r\n\r\ninterface IProps {}\r\n\r\ninterface IState {\r\n    length: number,\r\n    time: number,\r\n    hDisabled: boolean,\r\n    aDisabled: boolean,\r\n    panelShow: boolean,\r\n    topMargin: number,\r\n    vButtonColor: string\r\n}\r\n\r\nclass PathfindingApp extends React.Component<IProps, IState>\r\n{\r\n    //expose grid to parent to connect to button siblings\r\n    private grid: RefObject<PathfindingVisualizer> = React.createRef();\r\n\r\n    private settingsManager: SettingsManager = new SettingsManager();\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.state = {\r\n            length: 0,\r\n            time: 0,\r\n            hDisabled: false,\r\n            aDisabled: false,\r\n            panelShow: false,\r\n            topMargin: 75,\r\n            vButtonColor: 'green-button'\r\n        }\r\n    }\r\n\r\n    changeVButtonColor = (visualizing: boolean) => {\r\n        const color = visualizing ? 'red-button' : 'green-button';\r\n        this.setState({\r\n            vButtonColor: color\r\n        })\r\n    }\r\n\r\n    toggleSettings = () => {\r\n        this.setState(prevState => ({\r\n            panelShow: !prevState.panelShow\r\n        }));\r\n    }\r\n\r\n    hideSettings = () => {\r\n        this.setState({\r\n            panelShow: false\r\n        });\r\n    }\r\n\r\n    changeAlgo = (algorithm: string) => {\r\n        this.setState({\r\n            hDisabled: !PathfinderFactory.usesHeuristic(algorithm),\r\n            aDisabled: !PathfinderFactory.hasBidirectional(algorithm)\r\n        });\r\n        this.settingsManager.changeAlgo(algorithm);\r\n    }\r\n\r\n    doPathfinding = () => {\r\n        this.grid.current!.doDelayedPathfinding();\r\n    }\r\n\r\n    clearPath = () => {\r\n        this.grid.current!.clearPath();\r\n        this.grid.current!.clearVisualization();\r\n    }\r\n\r\n    clearTiles = () => {\r\n        this.clearPath();\r\n        this.grid.current!.clearTiles();\r\n    }\r\n\r\n    createMaze = () => {\r\n        this.grid.current!.createMaze();\r\n    }\r\n\r\n    setLength = (len: number) => {\r\n        this.setState({\r\n            length: len\r\n        });\r\n    }\r\n\r\n    setTime = (time: number) => {\r\n        this.setState({\r\n            time: time\r\n        });\r\n    }\r\n\r\n    onChangeHeight = (height: number) => {\r\n        this.setState({\r\n            topMargin: height\r\n        })\r\n    }\r\n\r\n    render() {\r\n        const tileWidth = isMobile() ? 47 : 27;\r\n        return (\r\n            <div>\r\n                <DraggablePanel show={this.state.panelShow} onClickXButton={this.hideSettings}>\r\n                    <VisualSettings onChangeViz={this.settingsManager.changeVisualize}/>\r\n                    <SpeedSettings onChange={this.settingsManager.changeSpeed}/>\r\n                    <AlgorithmSettings disabled={this.state.aDisabled}\r\n                                       onChangeBidirectional={this.settingsManager.changeBidirectional}\r\n                                       onChangeDiagonals={this.settingsManager.changeDiagonals}/>\r\n                    <HeuristicSettings disabled={this.state.hDisabled}\r\n                                       onClickManhattan={this.settingsManager.changeManhattan}\r\n                                       onClickEuclidean={this.settingsManager.changeEuclidean}\r\n                                       onClickChebyshev={this.settingsManager.changeChebyshev}\r\n                                       onClickOctile={this.settingsManager.changeOctile}/>\r\n                </DraggablePanel>\r\n                <TopBar onChangeHeight={this.onChangeHeight}>\r\n                    <a href='https://github.com/JosephPrichard/PathfinderReact' className='title'>\r\n                        Pathfinding Visualizer\r\n                    </a>\r\n                    <div className='top-container'>\r\n                        <AlgorithmDropDown onChange={this.changeAlgo}/>\r\n                        <VisualizeButton color={this.state.vButtonColor} onClick={this.doPathfinding}/>\r\n                        <ClearDropDown onClickTiles={this.clearTiles}\r\n                                       onClickPath={this.clearPath}/>\r\n                        <SettingsButton onClick={this.toggleSettings}/>\r\n                        <MazeButton onClick={this.createMaze}/>\r\n                    </div>\r\n                </TopBar>\r\n                <PathfindingVisualizer ref={this.grid} onChangeVisualizing={this.changeVButtonColor} topMargin={this.state.topMargin}\r\n                                       settings={this.settingsManager.settings} tileWidth={tileWidth}/>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction isMobile() {\r\n    return /Android|webOS|iPhone|iPad|Mac|Macintosh|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\r\n}\r\n\r\nexport default PathfindingApp;","import React from 'react';\nimport PathfindingApp from './view/PathfindingApp';\n\nclass App extends React.Component\n{\n    render() {\n        return (\n            <PathfindingApp/>\n        );\n    }\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n    <React.StrictMode>\n        <App/>\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n\nreportWebVitals();\n"],"sourceRoot":""}
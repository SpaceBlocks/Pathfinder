{"version":3,"sources":["common/components/navbar/TopBar.tsx","common/components/navbar/Buttons.tsx","common/components/navbar/DropDown.tsx","common/components/navbar/DropDownComponents.tsx","common/components/panel/Checkbox.tsx","common/components/panel/SteppedRangeSlider.tsx","common/components/panel/RadioButtonGroup.tsx","common/components/navbar/SettingPanels.tsx","common/components/panel/DraggablePanel.tsx","common/pathfinding/core/PlusNavigator.ts","common/pathfinding/core/Navigator.ts","common/pathfinding/algorithms/Heuristics.ts","common/pathfinding/algorithms/Pathfinder.ts","common/pathfinding/algorithms/Node.ts","common/pathfinding/structures/Hash.ts","common/pathfinding/structures/Heap.ts","common/pathfinding/algorithms/AStarPathfinder.ts","common/pathfinding/algorithms/BFSPathfinder.ts","common/pathfinding/structures/Stack.ts","common/pathfinding/algorithms/DFSPathfinder.ts","common/pathfinding/algorithms/BiAStarPathfinder.ts","common/pathfinding/algorithms/BiBFSPathfinder.ts","common/pathfinding/algorithms/PathfinderBuilder.ts","common/components/grid/GridBackground.tsx","common/pathfinding/core/Components.ts","common/pathfinding/core/Grid.ts","common/components/grid/TileFg.tsx","common/components/grid/SolidFg.tsx","images/weight.svg","common/components/grid/WeightFg.tsx","common/components/grid/GridForeground.tsx","common/components/grid/StatsPanel.tsx","common/components/grid/GridStaticTiles.tsx","common/pathfinding/algorithms/TerrainGenerator.ts","common/pathfinding/algorithms/TerrainRandomGenerator.ts","common/pathfinding/algorithms/TerrainMazeGenerator.ts","common/pathfinding/algorithms/TerrainGeneratorBuilder.ts","common/utils/VirtualTimer.ts","common/components/grid/PathfindingVisualizer.tsx","images/react.png","common/components/PathfindingApp.tsx","common/utils/AppSettings.ts","App.tsx","index.tsx"],"names":["TopBar","bar","React","createRef","ref","this","style","width","window","screen","availWidth","className","props","children","Component","SYMBOL_COLOR","DIMENSION","VisualizeButton","height","rx","fill","points","x","active","onMouseDown","e","preventDefault","onClick","paused","onResume","onPause","xmlns","getResumeSymbol","getPauseSymbol","onStartStop","getStopSymbol","SettingsButton","DropDown","setState","up","display","stopPropagation","isHidden","show","hide","state","Clickable","tabIndex","onKeyPress","click","AlgorithmDropDown","text","fade","key","algText","onChange","toggle","nativeEvent","arrowClass","contentStyle","ClearDropDown","onClickPath","onClickTiles","onClickReset","MazeDropDown","onClickMaze","onClickMazeHorizontal","onClickMazeVertical","onClickRandomTerrain","TilesDropDown","cost","onClickTileType","Checkbox","checked","defaultChecked","prevState","type","disabled","boxStyle","defaultProps","SteppedRangeSlider","mouseUp","value","default","val","Number","currentTarget","list","min","max","step","sliderStyle","onInput","onMouseUp","onTouchEnd","onTouchStart","RadioButtonGroup","i","length","push","index","Children","toArray","radioButtons","VisualSettings","defaultViz","onChangeViz","defaultShowArrows","onChangeShowArrows","disabledTree","defaultShowScores","onChangeShowScores","disabledScore","SpeedSettings","speedText","String","initialSpeed","speed","options","onChangeSpeed","id","AlgorithmSettings","defaultAlg","onChangeBidirectional","HeuristicSettings","heuristic","getIndex","defaultHeuristic","onClickManhattan","onClickEuclidean","onClickChebyshev","onClickOctile","DraggablePanel","draggable","draggableContainer","draggableContent","dragging","prevX","prevY","mouseDown","clientY","clientX","touchStart","touch","touches","changedTouches","mouseMove","drag","touchMove","top","left","document","addEventListener","container","current","offsetTop","offsetLeft","content","innerHeight","innerWidth","offsetHeight","offsetWidth","visibleStyle","minHeight","getPosition","renderDraggable","draggableStyle","title","onClickXButton","PlusNavigator","point","tiles","grid","getWidth","tile","get","y","data","isSolid","getHeight","a","b","pathCost","manhattan","Math","abs","euclidean","dx","dy","sqrt","octile","SQRT2","chebyshev","nullHeuristic","reconstructPath","bottomLeaf","reconstructPathReversed","reverse","path","parent","Pathfinder","navigator","recentSearch","slice","node","Node","child","f","g","h","AStarNode","fScore","round","HashSet","map","undefined","HashTable","stringify","Heap","compare","elements","siftUp","peek","move","pop","siftDown","pos","swap","right","from","to","AStarPathfinder","func","heuristicFunc","p","getNavigator","getGrid","initial","goal","clearRecentSearch","openFrontier","closedSet","openSet","root","add","isEmpty","currentNode","currentPoint","currentKey","remove","has","addRecent","equals","neighbors","neighbor","neighborPoint","neighborKey","stepCost","neighborNode","addChild","BFSPathfinder","frontier","visited","shift","next","Stack","size","DFSPathfinder","BiAStarPathfinder","startOpenFrontier","startOpenSet","endOpenFrontier","endOpenSet","initialRoot","goalRoot","startCurrentNode","startCurrentPointKey","concat","doAStarExpansion","endCurrentNode","endCurrentPointKey","structures","endPoint","BiBFSPathfinder","startVisited","endVisited","startFrontier","endFrontier","doBFSExpansion","CREATE_NAVIGATOR","CREATE_HEURISTIC","CREATE_PATHFINDER","PathfinderBuilder","algorithm","toLowerCase","Error","createHeuristic","createNavigator","createPathfinder","ARROW_COLOR","TILE_CLASS","clone","array","arr","GridBackground","tileWidth","tileClass","lastAlgo","tilesX","tilesY","visualization","createEmptyViz","scores","createEmptyScores","arrows","row","generation","doVizGeneration","doScoreGeneration","generations","doArrowGeneration","settings","visualizeAlg","renderViz","markerWidth","markerHeight","refX","refY","orient","showArrows","usesBreadthTree","renderArrows","offset","arrow","first","second","firstX","firstY","secondX","secondY","offsetX","offsetY","x1","y1","x2","y2","stroke","strokeWidth","markerEnd","viz","score","renderTile","color","backgroundColor","fontSize","showScores","point1","point2","newArrow","indexOf","splice","createTileData","RectGrid","nodes","createEmptyGrid","solid","mutate","console","str","log","JSON","mutateTile","TileFg","position","borderColor","SolidFg","doTileAnimation","tileSize","WeightFg","backgroundImage","Weight","ARROW_PATH_COLOR","pointsEqual","isControlKey","button","GridForeground","svg","tilePointer","drawing","erasing","draggingInitial","draggingGoal","disable","initialKey","goalKey","end","calcEndPointInView","topMargin","getBoundingClientRect","bounds","getBoundingRect","onPress","onDrag","xCoordinate","yCoordinate","calculatePoint","drawTile","eraseTile","moveInitial","moveGoal","inBounds","mutateDefault","canMoveEndPoint","onTilesDragged","floor","renderEndTile","renderPath","onContextMenu","onMouseMove","onMouseLeave","onEndingEvent","onTouchMoveCapture","onTouchCancel","renderTilesTable","lines","renderPathArrow","renderWeightText","paddingTop","textAlign","cursor","StatsPanel","textLog","scrollTop","scrollHeight","time","toFixed","readOnly","unselectable","onDrop","GridStaticTiles","renderTiles","TerrainGenerator","ignore","shouldIgnore","TerrainRandomGenerator","tileData","topLeft","bottomRight","random","draw","getTerrain","divideWidthNoSkew","divideWidthHSkew","divideWidthVSkew","canDrawHole","getMidPoint","range","mid","getRand","TerrainMazeGenerator","slant","divideWidth","getSolid","divide","chamber","widthOf","heightOf","randX","toDraw","edgeBlocked","randY","drawArr","leftChamber","rightChamber","topChamber","bottomChamber","TerrainGeneratorBuilder","VirtualTimer","callback","countDown","timeout","timeStarted","timeRemaining","finished","Date","now","setTimeout","clearTimeout","calcLength","len","calcCost","PathfindingVisualizer","background","foreground","visualized","visualizing","visualTimeouts","wasPaused","mazeTile","clearPath","erasePath","w","outerWidth","availHeight","outerHeight","isPaused","pausePathfinding","resumePathfinding","nextProps","nextState","prevProps","changeTile","pause","resume","pathfinder","getPathfinder","findPath","getRecentGenerations","visualizeGenerations","addArrowGenerations","drawPath","setLastAlgo","enableAnimations","clearVisualization","toggleDisable","clear","onChangeVisualizing","promises","baseIncrement","delayInc","canShowVisualization","delay","generationSet","forEach","promise","Promise","resolve","visualizeGenerationAndArrows","all","then","disableAnimations","algorithmKey","bidirectional","hasBidirectional","makeBidirectional","setAlgorithm","setHeuristic","heuristicKey","setNavigator","navigatorKey","build","t0","performance","t2","getRecentNodes","getAlgorithmName","unshift","doPathfinding","mazeType","useMazeTile","clearTiles","newState","prevGrid","generator","setDimensions","setGeneratorType","setIgnorePoints","setTileData","generateTerrain","drawGrid","xEnd","yEnd","xFloor","yFloor","yDecimal","ceil","resetPoints","visualizeGeneration","addArrowGeneration","PathfindingApp","visualizer","algDropDown","clrDropDown","mazeDropDown","tilesDropDown","heuristicDisabled","bidirectionalDisabled","arrowsDisabled","scoreDisabled","panelShow","useIcon","mobile","test","userAgent","doDelayedPathfinding","clearVisualizationChecked","clearTilesChecked","createTerrain","usesHeuristic","usesWeights","icon","alt","src","Icon","hideSettings","changeVisualize","changeShowArrows","changeShowScores","changeSpeed","changeBidirectional","changeManhattan","changeEuclidean","changeChebyshev","changeOctile","href","onClickAlgDrop","alg","changeAlgo","onClickClrDrop","resetBoard","onClickTilesDrop","onClickMazeDrop","createMaze","createMazeHSkew","createMazeVSkew","createRandomTerrain","toggleSettings","changeVButtonColor","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.9b7f605d.chunk.js","sourcesContent":["import React, {RefObject} from 'react';\r\n\r\nclass TopBar extends React.Component\r\n{\r\n    private bar: RefObject<HTMLDivElement> = React.createRef();\r\n\r\n    render() {\r\n        return (\r\n            <div\r\n                ref={this.bar}\r\n                style={{\r\n                    width: window.screen.availWidth\r\n                }}\r\n                className='top-navbar'\r\n            >\r\n                {this.props.children}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default TopBar;","import React from 'react';\r\n\r\ninterface VProps {\r\n    active: boolean,\r\n    paused: boolean,\r\n    onStartStop: ()  => void,\r\n    onPause: ()  => void,\r\n    onResume: ()  => void,\r\n}\r\n\r\ninterface ButtonProps {\r\n    onClick: ()  => void\r\n}\r\n\r\nconst SYMBOL_COLOR = 'rgb(230,230,230)';\r\nconst OFFSET = 14;\r\nconst DIMENSION = 47 - 2 * OFFSET;\r\n\r\nexport class VisualizeButton extends React.Component<VProps>\r\n{\r\n    getStopSymbol() {\r\n        return (\r\n            <rect\r\n                width={DIMENSION}\r\n                height={DIMENSION}\r\n                rx={4}\r\n                fill={SYMBOL_COLOR}\r\n            />\r\n        );\r\n    }\r\n\r\n    getResumeSymbol() {\r\n        const midY = DIMENSION / 2;\r\n        return (\r\n            <polygon\r\n                points={`${0},${0} ${0},${DIMENSION} ${DIMENSION},${midY}`}\r\n                className={'track round'}\r\n                fill={SYMBOL_COLOR}\r\n            />\r\n        );\r\n    }\r\n\r\n    getPauseSymbol() {\r\n        return (\r\n            <svg>\r\n                <rect\r\n                    width={DIMENSION/2.5}\r\n                    height={DIMENSION}\r\n                    rx={3}\r\n                    fill={SYMBOL_COLOR}\r\n                />\r\n                <rect\r\n                    width={DIMENSION/2.5}\r\n                    height={DIMENSION}\r\n                    x={0.2*DIMENSION + DIMENSION/2.5}\r\n                    rx={3}\r\n                    fill={SYMBOL_COLOR}\r\n                />\r\n            </svg>\r\n        );\r\n    }\r\n\r\n    render() {\r\n        if(this.props.active) {\r\n            return (\r\n                <div className={'half-button-wrapper'}>\r\n                    <button\r\n                        onMouseDown={e => e.preventDefault()}\r\n                        className={'center half-button-left red-button half-viz-button'}\r\n                        onClick={this.props.paused ? this.props.onResume : this.props.onPause}\r\n                    >\r\n                        <svg\r\n                            xmlns='http://www.w3.org/2000/svg'\r\n                            className='svg-icon'\r\n                            width={DIMENSION}\r\n                            height={DIMENSION}\r\n                        >\r\n                            {this.props.paused ? this.getResumeSymbol() : this.getPauseSymbol()}\r\n                        </svg>\r\n                    </button>\r\n                    <button\r\n                        onMouseDown={e => e.preventDefault()}\r\n                        className={'center half-button-right red-button half-viz-button'}\r\n                        onClick={this.props.onStartStop}\r\n                    >\r\n                        <svg\r\n                            xmlns='http://www.w3.org/2000/svg'\r\n                            className='svg-icon'\r\n                            width={DIMENSION}\r\n                            height={DIMENSION}\r\n                        >\r\n                            {this.getStopSymbol()}\r\n                        </svg>\r\n                    </button>\r\n                </div>\r\n            );\r\n        } else {\r\n            return (\r\n                <button\r\n                    onMouseDown={e => e.preventDefault()}\r\n                    className={'button green-button viz-button'}\r\n                    onClick={this.props.onStartStop}\r\n                >\r\n                    Visualize!\r\n                </button>\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nexport class SettingsButton extends React.Component<ButtonProps>\r\n{\r\n    render() {\r\n        return (\r\n            <button\r\n                onMouseDown={e => e.preventDefault()}\r\n                className='button settings-button'\r\n                onClick={this.props.onClick}\r\n            >\r\n                Settings\r\n            </button>\r\n        );\r\n    }\r\n}","import React from 'react';\r\n\r\nexport interface DropDownProps {\r\n    onClick: () => void,\r\n}\r\n\r\nexport interface DropDownState {\r\n    up: boolean,\r\n    display: string,\r\n    fade: string\r\n}\r\n\r\nabstract class DropDown<IProps extends DropDownProps, IState extends DropDownState>\r\n    extends React.Component<IProps, IState>\r\n{\r\n    protected constructor(props: IProps) {\r\n        super(props);\r\n    }\r\n\r\n    show() {\r\n        this.setState({\r\n            up: false,\r\n            display: 'block',\r\n        });\r\n    }\r\n\r\n    hide() {\r\n        this.setState({\r\n            display: 'none',\r\n            up: true,\r\n        });\r\n    }\r\n\r\n    toggle(e: Event) {\r\n        e.stopPropagation();\r\n        this.props.onClick();\r\n        if(this.isHidden()) {\r\n            this.show();\r\n        } else {\r\n            this.hide();\r\n        }\r\n    }\r\n\r\n    isHidden() {\r\n        return this.state.display === 'none';\r\n    }\r\n\r\n    contentStyle() {\r\n        return {\r\n            display: this.state.display\r\n        }\r\n    }\r\n}\r\n\r\nexport default DropDown;","import React from 'react';\r\nimport DropDown, {DropDownProps, DropDownState} from './DropDown';\r\n\r\ninterface AlgProps extends DropDownProps {\r\n    onChange: (alg: string) => void\r\n}\r\n\r\ninterface DropDownTextState extends DropDownState {\r\n    text: string,\r\n}\r\n\r\ninterface ClrProps extends DropDownProps {\r\n    onClickPath: () => void,\r\n    onClickTiles: () => void,\r\n    onClickReset: () => void;\r\n}\r\n\r\ninterface MazeProps extends DropDownProps {\r\n    onClickMaze: () => void,\r\n    onClickMazeHorizontal: () => void,\r\n    onClickMazeVertical: () => void,\r\n    onClickRandomTerrain: () => void\r\n}\r\n\r\ninterface TileProps extends DropDownProps {\r\n    onClickTileType: (cost: number) => void\r\n}\r\n\r\ninterface ClickableProps {\r\n    click: () => void;\r\n}\r\n\r\nclass Clickable extends React.Component<ClickableProps>\r\n{\r\n    render() {\r\n        return (\r\n            <div\r\n                tabIndex={0}\r\n                onKeyPress={this.props.click}\r\n                onClick={this.props.click}\r\n            >\r\n                {this.props.children}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport class AlgorithmDropDown extends DropDown<AlgProps, DropDownTextState>\r\n{\r\n    constructor(props: AlgProps) {\r\n        super(props);\r\n        this.state = {\r\n            up: true,\r\n            display: 'none',\r\n            text: 'A* Search',\r\n            fade: 'fade-in'\r\n        };\r\n    }\r\n\r\n    onChange(key: string, algText: string) {\r\n        this.props.onChange(key);\r\n        this.setState({\r\n            text: algText\r\n        });\r\n    }\r\n\r\n    arrowClass() {\r\n        return this.state.up ? 'arrowUp' : 'arrowDown';\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div\r\n                tabIndex={0}\r\n                className='alg-drop-down drop-down'\r\n                onMouseDown={e => e.preventDefault()}\r\n                onKeyPress={(e) => this.toggle(e.nativeEvent)}\r\n                onClick={(e) => this.toggle(e.nativeEvent)}\r\n            >\r\n                <div className='alg-drop-down-button drop-down-button'>\r\n                    <span className='alg-drop-down-text drop-down-text'>{this.state.text}</span>\r\n                    <span className={'alg-arr ' + this.arrowClass()}/>\r\n                </div>\r\n                <div\r\n                    style={this.contentStyle()}\r\n                    className={this.state.fade + ' alg-drop-down-content drop-down-content'}\r\n                >\r\n                    <Clickable click={() => this.onChange('a*', 'A* Search')}>A* Search</Clickable>\r\n                    <Clickable click={() => this.onChange('dijkstra', 'Dijkstra')}>Dijkstra's Algorithm</Clickable>\r\n                    <Clickable click={() => this.onChange('best-first', 'Best First')}>Best First Search</Clickable>\r\n                    <Clickable click={() => this.onChange('bfs', 'Breadth First')}>Breadth First Search</Clickable>\r\n                    <Clickable click={() => this.onChange('dfs', 'Depth First')}>Depth First Search</Clickable>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class ClearDropDown extends DropDown<ClrProps, DropDownState>\r\n{\r\n    constructor(props: ClrProps) {\r\n        super(props);\r\n        this.state = {\r\n            up: true,\r\n            display: 'none',\r\n            fade: 'fade-in'\r\n        };\r\n    }\r\n\r\n    arrowClass() {\r\n        return this.state.up ? 'arrowUpW' : 'arrowDownW';\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div\r\n                tabIndex={0}\r\n                className='clr-drop-down drop-down'\r\n                onMouseDown={e => e.preventDefault()}\r\n                onKeyPress={(e) => this.toggle(e.nativeEvent)}\r\n                onClick={(e) => this.toggle(e.nativeEvent)}\r\n            >\r\n                <div className='clr-drop-down-button drop-down-button'>\r\n                    <span className='clr-drop-down-text drop-down-text'>Reset</span>\r\n                    <span className={'clr-arr ' + this.arrowClass()}/>\r\n                </div>\r\n                <div\r\n                    style={this.contentStyle()}\r\n                    className={this.state.fade + ' clr-drop-down-content drop-down-content'}\r\n                >\r\n                    <Clickable click={this.props.onClickPath}>Clear Path</Clickable>\r\n                    <Clickable click={this.props.onClickTiles}>Clear Tiles</Clickable>\r\n                    <Clickable click={this.props.onClickReset}>Reset Grid</Clickable>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class MazeDropDown extends DropDown<MazeProps, DropDownState>\r\n{\r\n    constructor(props: MazeProps) {\r\n        super(props);\r\n        this.state = {\r\n            up: true,\r\n            display: 'none',\r\n            fade: 'fade-in'\r\n        };\r\n    }\r\n\r\n    arrowClass() {\r\n        return this.state.up ? 'arrowUpW' : 'arrowDownW';\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div\r\n                tabIndex={0} className='maze-drop-down drop-down'\r\n                onMouseDown={e => e.preventDefault()}\r\n                onKeyPress={(e) => this.toggle(e.nativeEvent)}\r\n                onClick={(e) => this.toggle(e.nativeEvent)}\r\n            >\r\n                <div className='maze-drop-down-button drop-down-button'>\r\n                    <span className='maze-drop-down-text drop-down-text'>Terrain</span>\r\n                    <span className={'clr-arr ' + this.arrowClass()}/>\r\n                </div>\r\n                <div\r\n                    style={this.contentStyle()}\r\n                    className={this.state.fade + ' maze-drop-down-content drop-down-content'}\r\n                >\r\n                    <Clickable click={this.props.onClickMaze}>Recursive Maze Division</Clickable>\r\n                    <Clickable click={this.props.onClickMazeHorizontal}>Horizontal Skewed Maze</Clickable>\r\n                    <Clickable click={this.props.onClickMazeVertical}>Vertical Skewed Maze</Clickable>\r\n                    <Clickable click={this.props.onClickRandomTerrain}>Random Terrain</Clickable>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class TilesDropDown extends DropDown<TileProps, DropDownTextState>\r\n{\r\n    constructor(props: TileProps) {\r\n        super(props);\r\n        this.state = {\r\n            up: true,\r\n            display: 'none',\r\n            fade: 'fade-in',\r\n            text: 'Wall [∞]'\r\n        };\r\n    }\r\n\r\n    arrowClass() {\r\n        return this.state.up ? 'arrowUpW' : 'arrowDownW';\r\n    }\r\n\r\n    onChange(cost: number, text: string) {\r\n        this.props.onClickTileType(cost);\r\n        this.setState({\r\n            text: text\r\n        }, () => this.props.onClickTileType(cost));\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div\r\n                tabIndex={0}\r\n                className='tiles-drop-down drop-down'\r\n                onMouseDown={e => e.preventDefault()}\r\n                onKeyPress={(e) => this.toggle(e.nativeEvent)}\r\n                onClick={(e) => this.toggle(e.nativeEvent)}\r\n            >\r\n                <div className='tiles-drop-down-button drop-down-button'>\r\n                    <span className='tiles-drop-down-text drop-down-text'>{this.state.text}</span>\r\n                    <span className={'clr-arr ' + this.arrowClass()}/>\r\n                </div>\r\n                <div\r\n                    style={this.contentStyle()}\r\n                    className={this.state.fade + ' tiles-drop-down-content drop-down-content'}\r\n                >\r\n                    <Clickable click={() => this.onChange(-1, 'Wall [∞]')}>Wall [∞]</Clickable>\r\n                    <Clickable click={() => this.onChange(2, 'Weight [2]')}>Weight [2]</Clickable>\r\n                    <Clickable click={() => this.onChange(3, 'Weight [3]')}>Weight [3]</Clickable>\r\n                    <Clickable click={() => this.onChange(5, 'Weight [5]')}>Weight [5]</Clickable>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}","import React from 'react';\r\n\r\ninterface IProps {\r\n    boxStyle: string,\r\n    defaultChecked: boolean,\r\n    disabled?: boolean,\r\n    onChange: (checked: boolean) => void\r\n}\r\n\r\ninterface IState {\r\n    checked: boolean\r\n}\r\n\r\nclass Checkbox extends React.Component<IProps,IState>\r\n{\r\n    public static defaultProps = {\r\n        disabled: false\r\n    };\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.state = {\r\n            checked: this.props.defaultChecked\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger callback and change checkbox state\r\n     */\r\n    onChange() {\r\n        this.setState(prevState => ({\r\n            checked: !prevState.checked\r\n        }), () => this.props.onChange(this.state.checked));\r\n    }\r\n\r\n    render() {\r\n        return(\r\n            <div>\r\n                <input\r\n                    checked={this.state.checked}\r\n                    type='checkbox'\r\n                    disabled={this.props.disabled}\r\n                    className={this.props.boxStyle}\r\n                    onKeyPress={() => this.onChange()}\r\n                    onChange={() => this.onChange()}\r\n                />\r\n                {this.props.children}\r\n            </div>\r\n        );\r\n    };\r\n}\r\n\r\nexport default Checkbox;","import React from 'react';\r\n\r\ninterface IProps {\r\n    min: number,\r\n    max: number,\r\n    default: number,\r\n    step: number,\r\n    sliderStyle: string,\r\n    onChange: (val: number) => void\r\n}\r\n\r\ninterface IState {\r\n    value: number\r\n}\r\n\r\nclass SteppedRangeSlider extends React.Component<IProps, IState>\r\n{\r\n    private mouseUp = true;\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.state = {\r\n            value: this.props.default\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger callback when slider value is changed\r\n     * @param e\r\n     */\r\n    onChange(e: React.FormEvent<HTMLInputElement>) {\r\n        if(!this.mouseUp) { //to prevent firefox from resetting on release\r\n            const val = Number(e.currentTarget.value);\r\n            this.setState({\r\n                value: val\r\n            }, () => this.props.onChange(val));\r\n        }\r\n    }\r\n\r\n    onMouseUp() {\r\n        this.mouseUp = true;\r\n    }\r\n\r\n    onMouseDown() {\r\n        this.mouseUp = false;\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <input\r\n                type='range'\r\n                list='step-list'\r\n                value={this.state.value}\r\n                min={this.props.min}\r\n                max={this.props.max}\r\n                step={this.props.step}\r\n                className={this.props.sliderStyle}\r\n                onInput={e => this.onChange(e)}\r\n                onMouseUp={() => this.onMouseUp()}\r\n                onMouseDown={() => this.onMouseDown()}\r\n                onTouchEnd={() => this.onMouseUp()}\r\n                onTouchStart={() => this.onMouseDown()}\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nexport default SteppedRangeSlider;","import React from 'react';\r\n\r\ninterface IProps {\r\n    boxStyle: string,\r\n    defaultChecked: number,\r\n    disabled: boolean,\r\n    onChange: (() => void)[]\r\n}\r\n\r\ninterface IState {\r\n    checked: boolean[];\r\n}\r\n\r\nclass RadioButtonGroup extends React.Component<IProps, IState>\r\n{\r\n    public static defaultProps = {\r\n        disabled: false\r\n    };\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        const checked: boolean[] = [];\r\n        for(let i = 0; i < this.props.onChange.length; i++) {\r\n            checked.push(i === this.props.defaultChecked);\r\n        }\r\n        this.state = {\r\n            checked: checked\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set all radio buttons to checked aside from the index\r\n     * of the one that was changed\r\n     * Trigger callback\r\n     * @param index\r\n     */\r\n    onChange (index: number) {\r\n        const checked: boolean[] = [];\r\n        for(let i = 0; i < this.props.onChange.length; i++) {\r\n            checked.push(i === index);\r\n        }\r\n        this.setState({\r\n            checked: checked\r\n        }, () => this.props.onChange[index]());\r\n    }\r\n\r\n    render() {\r\n        const children = React.Children.toArray(this.props.children);\r\n        const radioButtons: JSX.Element[] = [];\r\n        for(let i = 0; i < this.props.onChange.length; i++) {\r\n            radioButtons.push(\r\n                <div key={i}>\r\n                    <input\r\n                        checked={this.state.checked[i]}\r\n                        type='radio'\r\n                        disabled={this.props.disabled}\r\n                        className={this.props.boxStyle}\r\n                        onChange={() => this.onChange(i)}\r\n                    />\r\n                    {children[i]}\r\n                </div>\r\n            );\r\n        }\r\n        return radioButtons;\r\n    };\r\n}\r\n\r\nexport default RadioButtonGroup;","import React from 'react';\r\nimport Checkbox from '../panel/Checkbox';\r\nimport SteppedRangeSlider from '../panel/SteppedRangeSlider';\r\nimport RadioButtonGroup from '../panel/RadioButtonGroup';\r\n\r\ninterface VisualProps {\r\n    defaultViz: boolean,\r\n    defaultShowArrows: boolean,\r\n    defaultShowScores: boolean,\r\n    onChangeViz: () => void,\r\n    onChangeShowArrows: () => void,\r\n    onChangeShowScores: () => void,\r\n    disabledTree: boolean,\r\n    disabledScore: boolean\r\n}\r\n\r\ninterface SpeedProps {\r\n    onChange: (value: number) => void,\r\n    initialSpeed: number\r\n}\r\n\r\ninterface SpeedState {\r\n    speedText: string\r\n}\r\n\r\ninterface AlgorithmProps {\r\n    defaultAlg: boolean,\r\n    onChangeBidirectional: (checked: boolean) => void,\r\n    disabled: boolean\r\n}\r\n\r\ninterface HeuristicProps {\r\n    defaultHeuristic: string\r\n    onClickManhattan: () => void,\r\n    onClickEuclidean: () => void,\r\n    onClickChebyshev: () => void,\r\n    onClickOctile: () => void,\r\n    disabled: boolean\r\n}\r\n\r\nconst SPEED_STEP = 5;\r\nconst SPEED_INITIAL = 10;\r\nconst MAX = 20;\r\n\r\nexport class VisualSettings extends React.Component<VisualProps>\r\n{\r\n    render() {\r\n        return (\r\n            <div>\r\n                <div className='draggable-content-title'>Visualization</div>\r\n                <Checkbox\r\n                    defaultChecked={this.props.defaultViz}\r\n                    boxStyle='box'\r\n                    onChange={this.props.onChangeViz}\r\n                >\r\n                    Show Visualization\r\n                </Checkbox>\r\n                <Checkbox\r\n                    defaultChecked={this.props.defaultShowArrows}\r\n                    boxStyle='box'\r\n                    onChange={this.props.onChangeShowArrows}\r\n                    disabled={this.props.disabledTree}\r\n                >\r\n                    Show Tree\r\n                </Checkbox>\r\n                <Checkbox\r\n                    defaultChecked={this.props.defaultShowScores}\r\n                    boxStyle='box'\r\n                    onChange={this.props.onChangeShowScores}\r\n                    disabled={this.props.disabledScore}\r\n                >\r\n                    Show Scores\r\n                </Checkbox>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class SpeedSettings extends React.Component<SpeedProps, SpeedState>\r\n{\r\n    constructor(props: SpeedProps) {\r\n        super(props);\r\n        this.state = {\r\n            speedText: String(this.props.initialSpeed)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback function to be called when slider is changed\r\n     * Call another callback and change text\r\n     * @param value\r\n     */\r\n    onChangeSpeed(value: number) {\r\n        const speed = SPEED_INITIAL + SPEED_STEP * value;\r\n        this.setState({\r\n            speedText: String(speed)\r\n        })\r\n        this.props.onChange(speed);\r\n    }\r\n\r\n    render() {\r\n        const options: JSX.Element[] = [];\r\n        for(let i = 1; i <= MAX; i++) {\r\n            options.push(<option key={'option ' + i}>{i}</option>);\r\n        }\r\n        return (\r\n            <div className='slider-container'>\r\n                <div className='slider-text'>\r\n                    Speed: <div className='speed-text'> {this.state.speedText} </div>\r\n                </div>\r\n                <SteppedRangeSlider\r\n                    min={1}\r\n                    max={MAX}\r\n                    step={1}\r\n                    default={(this.props.initialSpeed - SPEED_INITIAL) / SPEED_STEP}\r\n                    sliderStyle='slider speed-slider'\r\n                    onChange={(value: number) => this.onChangeSpeed(value)}\r\n                />\r\n                <datalist id='step-list'>\r\n                    {options}\r\n                </datalist>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class AlgorithmSettings extends React.Component<AlgorithmProps>\r\n{\r\n    constructor(props: AlgorithmProps) {\r\n        super(props);\r\n        this.state = {\r\n            disabled: false\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <div className='draggable-content-title'>Algorithm</div>\r\n                <Checkbox\r\n                    defaultChecked={this.props.defaultAlg}\r\n                    boxStyle='box'\r\n                    disabled={this.props.disabled}\r\n                    onChange={this.props.onChangeBidirectional}\r\n                >\r\n                    Bidirectional\r\n                </Checkbox>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class HeuristicSettings extends React.Component<HeuristicProps>\r\n{\r\n    constructor(props: HeuristicProps) {\r\n        super(props);\r\n        this.state = {\r\n            disabled: false\r\n        }\r\n    }\r\n\r\n    disable() {\r\n        this.setState({\r\n            disabled: true\r\n        })\r\n    }\r\n\r\n    enable() {\r\n        this.setState({\r\n            disabled: false\r\n        })\r\n    }\r\n\r\n    getIndex(heuristic: string) {\r\n        const mapping: {[key: string]: number} = {\r\n            'manhattan': 0,\r\n            'euclidean': 1,\r\n            'chebyshev': 2,\r\n            'octile': 3\r\n        }\r\n        return mapping[heuristic];\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <div className='draggable-content-title'>Heuristic</div>\r\n                <RadioButtonGroup\r\n                    boxStyle='box'\r\n                    defaultChecked={this.getIndex(this.props.defaultHeuristic)}\r\n                    disabled={this.props.disabled}\r\n                    onChange={[\r\n                        this.props.onClickManhattan, this.props.onClickEuclidean,\r\n                        this.props.onClickChebyshev, this.props.onClickOctile\r\n                    ]}\r\n                >\r\n                    {[\r\n                        <span key='Manhattan'>Manhattan</span>,\r\n                        <span key='Euclidean'>Euclidean</span>,\r\n                        <span key='Chebyshev'>Chebyshev</span>,\r\n                        <span key='Octile<'>Octile</span>\r\n                    ]}\r\n                </RadioButtonGroup>\r\n            </div>\r\n        )\r\n    }\r\n}","import React, {RefObject} from 'react';\r\n\r\ninterface IProps {\r\n    title: string,\r\n    show: boolean,\r\n    onClickXButton: () => void,\r\n    width: number,\r\n    height: number\r\n}\r\n\r\ninterface IState {\r\n    top: number,\r\n    left: number\r\n}\r\n\r\nclass DraggablePanel extends React.Component<IProps, IState>\r\n{\r\n    //refs are used to access native DOM\r\n    private draggable: RefObject<HTMLDivElement> = React.createRef();\r\n    private draggableContainer: RefObject<HTMLDivElement> = React.createRef();\r\n    private draggableContent: RefObject<HTMLDivElement> = React.createRef();\r\n\r\n    //stores previous mouse location and drag\r\n    private dragging = false;\r\n    private prevX = 0;\r\n    private prevY = 0;\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.state = {\r\n            top: -1,\r\n            left: -1\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        //mouse\r\n        document.addEventListener('mouseup', e => {\r\n            this.mouseUp(e);\r\n        });\r\n        document.addEventListener('mousemove', e => {\r\n            this.mouseMove(e);\r\n        });\r\n        window.addEventListener('mouseleave', e => {\r\n            this.mouseUp(e);\r\n        });\r\n        //touch\r\n        document.addEventListener('touchend', () => {\r\n            this.dragging = false;\r\n        });\r\n        document.addEventListener('touchmove', e => {\r\n            this.touchMove(e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Start drag and init prev mouse location when mouse is clicked on draggable\r\n     * @param e\r\n     */\r\n    mouseDown = (e: MouseEvent) => {\r\n        e.preventDefault();\r\n        this.prevY = e.clientY;\r\n        this.prevX = e.clientX;\r\n        this.dragging = true;\r\n    }\r\n\r\n    /**\r\n     * Start drag and init prev touch location when finger is clicked on draggable\r\n     * @param e\r\n     */\r\n    touchStart = (e: TouchEvent) => {\r\n        const touch = e.touches[0] || e.changedTouches[0];\r\n        this.prevY = touch.clientY;\r\n        this.prevX = touch.clientX;\r\n        this.dragging = true;\r\n    }\r\n\r\n    /**\r\n     * Called when mouse is risen on document stop drag\r\n     * @param e\r\n     */\r\n    mouseUp = (e: Event) => {\r\n        e.preventDefault();\r\n        this.dragging = false;\r\n    }\r\n\r\n    /**\r\n     * Called when the mouse is moved over the document to calculate the new position of\r\n     * the draggable canvas\r\n     * @param e\r\n     */\r\n    mouseMove = (e: MouseEvent) => {\r\n        this.drag(e.clientX, e.clientY);\r\n    }\r\n\r\n    /**\r\n     * Called when the touch is moved over the document to calculate the new position of\r\n     * the draggable canvas\r\n     * @param e\r\n     */\r\n    touchMove = (e: TouchEvent) => {\r\n        const touch = e.touches[0] || e.changedTouches[0];\r\n        this.drag(touch.clientX, touch.clientY);\r\n    }\r\n\r\n    /**\r\n     * Called when user drags over the document to move the panel\r\n     * @param clientX\r\n     * @param clientY\r\n     */\r\n    drag(clientX: number, clientY: number) {\r\n        if(this.dragging) {\r\n            const container = this.draggableContainer.current!;\r\n            let top = (container.offsetTop - (this.prevY - clientY))\r\n            let left = (container.offsetLeft - (this.prevX - clientX));\r\n            const content = this.draggableContent.current!;\r\n            const draggable = this.draggable.current!;\r\n            //stop drag if mouse goes out of bounds\r\n            if(clientY < 0 || clientY > window.innerHeight\r\n                || clientX < 0 || clientX > window.innerWidth) {\r\n                this.dragging = false;\r\n            }\r\n            //check if position is out of bounds and prevent the panel from being dragged there\r\n            if(top < 0) {\r\n                top = 0;\r\n            } else if (top > window.innerHeight - draggable.offsetHeight) {\r\n                top = window.innerHeight - draggable.offsetHeight;\r\n            }\r\n            if(left < -content.offsetWidth/2) {\r\n                left = -content.offsetWidth/2;\r\n            } else if(left > window.innerWidth - content.offsetWidth/2) {\r\n                left = window.innerWidth - content.offsetWidth/2;\r\n            }\r\n            //set new position\r\n            this.setState({\r\n                top: top,\r\n                left: left\r\n            });\r\n            //update previous pos\r\n            this.prevY = clientY;\r\n            this.prevX = clientX;\r\n        }\r\n    }\r\n\r\n    getPosition() {\r\n        const left = this.state.left;\r\n        const top = this.state.top;\r\n        if(left === -1 || top === -1) {\r\n            return {};\r\n        }\r\n        return {\r\n            left: left + 'px',\r\n            top: top + 'px',\r\n        };\r\n    }\r\n\r\n    visibleStyle()  {\r\n        return this.props.show ? 'block' : 'none';\r\n    }\r\n\r\n    draggableStyle() {\r\n        return {\r\n            width: this.props.width,\r\n            display: this.visibleStyle()\r\n        }\r\n    }\r\n\r\n    contentStyle() {\r\n        return {\r\n            width: this.props.width,\r\n            minHeight: this.props.height,\r\n            display: this.visibleStyle()\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div\r\n                ref={this.draggableContainer}\r\n                className='draggable-container'\r\n                style={this.getPosition()}\r\n            >\r\n                {this.renderDraggable()}\r\n                <div\r\n                    ref={this.draggableContent}\r\n                    style={this.contentStyle()}\r\n                    className='draggable-content'\r\n                >\r\n                    <div className='settings-general'>\r\n                        {this.props.children}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    renderDraggable() {\r\n        return (\r\n            <div\r\n                style={this.draggableStyle()}\r\n                className='draggable'\r\n                ref={this.draggable}\r\n                onMouseDown={e => this.mouseDown(e.nativeEvent)}\r\n                onTouchStart={e => this.touchStart(e.nativeEvent)}\r\n            >\r\n                <div className='draggable-title'>{this.props.title}</div>\r\n                <div\r\n                    className='x-button'\r\n                    tabIndex={0}\r\n                    onKeyPress={this.props.onClickXButton}\r\n                    onClick={this.props.onClickXButton}\r\n                    onMouseDown={e => {\r\n                        e.stopPropagation();\r\n                        e.preventDefault();\r\n                    }}\r\n                >\r\n                    <div className='x-text'>\r\n                        X\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default DraggablePanel;","import {Point, Tile} from './Components';\r\nimport Navigator, {UNIT} from './Navigator';\r\n\r\n/**\r\n * Concretion of a Plus Navigator for a grid\r\n * Allows movement akin to a 'plus' symbol\r\n */\r\nclass PlusNavigator extends Navigator\r\n{\r\n    /**\r\n     * Adds the neighbors of a point to the left, right, top and down\r\n     * @param point\r\n     */\r\n    neighbors(point: Point) {\r\n        const tiles: Tile[] = [];\r\n        if(point.x + UNIT < this.grid.getWidth()) {\r\n            const tile = this.grid.get({\r\n                x: point.x + UNIT,\r\n                y: point.y\r\n            })\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.y + UNIT < this.grid.getHeight()) {\r\n            const tile = this.grid.get({\r\n                x: point.x,\r\n                y: point.y + UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.x - UNIT >= 0) {\r\n            const tile = this.grid.get({\r\n                x: point.x - UNIT,\r\n                y: point.y\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.y - UNIT >= 0) {\r\n            const tile = this.grid.get({\r\n                x: point.x,\r\n                y: point.y - UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    /**\r\n     * Step cost function that works by getting the pathCost stored in the grid\r\n     * from one point a to b\r\n     * @param a\r\n     * @param b to point to travel to\r\n     */\r\n    cost(a: Point, b: Point) {\r\n        return this.grid.get(b).data.pathCost;\r\n    }\r\n\r\n    getType() {\r\n        return 'plus';\r\n    }\r\n}\r\n\r\nexport default PlusNavigator;","import {Grid} from './Grid';\r\nimport {Point, Tile} from './Components';\r\n\r\nexport const UNIT = 1; //number of tiles we can move at once\r\n\r\n/**\r\n * Describes an abstract navigator for a grid\r\n * Provides graph-like traversal for the grid\r\n * Determines where we can travel to from a certain point,\r\n * whether we have reached a destination, and the cost to\r\n * travel to a certain point\r\n */\r\nabstract class Navigator\r\n{\r\n    protected readonly grid: Grid;\r\n\r\n    constructor(grid: Grid) {\r\n        this.grid = grid;\r\n    }\r\n\r\n    getGrid() {\r\n        return this.grid;\r\n    }\r\n\r\n    /**\r\n     * Goal check function: Checks if two points are equal\r\n     * @param a\r\n     * @param b\r\n     */\r\n    equals(a: Point, b: Point) {\r\n        return a.x === b.x && a.y === b.y;\r\n    }\r\n\r\n    /**\r\n     * Step cost function from a to b\r\n     * @param a\r\n     * @param b to point to travel to\r\n     */\r\n    abstract cost(a: Point, b: Point): number;\r\n\r\n    /**\r\n     * Neighbors function: Gets the available neighbors for a point in a grid we can make\r\n     * in a given move\r\n     * @param point\r\n     */\r\n    abstract neighbors(point: Point): Tile[];\r\n\r\n    abstract getType(): string;\r\n}\r\n\r\nexport default Navigator;","import {Point} from '../core/Components';\r\n\r\nexport type HeuristicFunc = (a: Point, b: Point) => number;\r\n\r\nexport function manhattan(a: Point, b: Point) {\r\n    const dx = Math.abs(a.x - b.x) ;\r\n    const dy = Math.abs(a.y - b.y);\r\n    return dx + dy;\r\n}\r\n\r\nexport function euclidean(a: Point, b: Point) {\r\n    const dx = Math.abs(a.x - b.x);\r\n    const dy = Math.abs(a.y - b.y);\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\r\n\r\nexport function octile(a: Point, b: Point) {\r\n    const dx = Math.abs(a.x - b.x);\r\n    const dy = Math.abs(a.y - b.y);\r\n    return Math.SQRT2 * Math.min(dx, dy) + Math.abs(dx - dy);\r\n}\r\n\r\nexport function chebyshev(a: Point, b: Point) {\r\n    const dx = Math.abs(a.x - b.x);\r\n    const dy = Math.abs(a.y - b.y);\r\n    return Math.max(dx, dy);\r\n}\r\n\r\nexport function nullHeuristic() {\r\n    return 0;\r\n}","import {Point, Tile} from '../core/Components';\r\nimport Navigator from '../core/Navigator';\r\nimport {Node} from './Node';\r\n\r\n/**\r\n * Pathfinder performs algorithms operations on the grid\r\n * Uses the navigator rank and expand nodes\r\n */\r\nabstract class Pathfinder\r\n{\r\n    protected recentSearch: Node[] = [];\r\n    protected navigator: Navigator;\r\n\r\n    constructor(navigator: Navigator) {\r\n        this.navigator = navigator;\r\n    }\r\n\r\n    setNavigator(navigator: Navigator) {\r\n        this.navigator = navigator;\r\n    }\r\n\r\n    getNavigator() {\r\n        return this.navigator;\r\n    }\r\n\r\n    getRecentNodes() {\r\n        return this.recentSearch.length;\r\n    }\r\n\r\n    clearRecentSearch() {\r\n        this.recentSearch = [];\r\n    }\r\n\r\n    getRecentGenerations() {\r\n        return this.recentSearch.slice();\r\n    }\r\n\r\n    protected addRecent(node: Node) {\r\n        this.recentSearch.push(node);\r\n    }\r\n\r\n    abstract getAlgorithmName(): string;\r\n\r\n    /**\r\n     * Finds the best path between initial and goal on the grid\r\n     * and returns it in an array\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    abstract findPath(initial: Point, goal: Point): Tile[];\r\n}\r\n\r\n/**\r\n * Reconstructs the path from a tree, given the bottomLeaf, and\r\n * returns the shortest path in an array\r\n * @param bottomLeaf bottom of the tree to start from\r\n */\r\nexport function reconstructPath(bottomLeaf: Node) {\r\n    return reconstructPathReversed(bottomLeaf).reverse();\r\n}\r\n\r\n/**\r\n * Reconstructs the path from a tree, given the bottomLeaf, and\r\n * returns the shortest path in an array\r\n * @param bottomLeaf bottom of the tree to start from\r\n */\r\nexport function reconstructPathReversed(bottomLeaf: Node) {\r\n    const path: Tile[] = [];\r\n    while(bottomLeaf.parent !== null) {\r\n        path.push(bottomLeaf.tile);\r\n        bottomLeaf = bottomLeaf.parent;\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default Pathfinder;","import {Tile} from '../core/Components';\r\n\r\n/**\r\n * Represents a search Tree Node\r\n */\r\nexport class Node\r\n{\r\n    parent: Node | null = null; //parent node\r\n    readonly children: Node[] = [];\r\n    readonly tile: Tile; //stores a graph node\r\n\r\n    constructor(tile: Tile) {\r\n        this.tile = tile;\r\n    }\r\n\r\n    addChild(child: Node) {\r\n        child.parent = this;\r\n        this.children.push(child);\r\n    }\r\n\r\n    /**\r\n     * Some nodes don't have scores. returns -1 if the node is un-scored\r\n     */\r\n    score() {\r\n        return {\r\n            f: -1,\r\n            g: -1,\r\n            h: -1\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Represents an heuristic weighted aStar search tree node\r\n */\r\nexport class AStarNode extends Node\r\n{\r\n    readonly g: number; //path cost\r\n    readonly fScore: number; //heuristic\r\n\r\n    constructor(tile: Tile, g: number, fScore: number) {\r\n        super(tile);\r\n        this.g = g;\r\n        this.fScore = fScore;\r\n    }\r\n\r\n    f() {\r\n        return this.fScore;\r\n    }\r\n\r\n    /**\r\n     * Gets scores for the node in a readable format\r\n     */\r\n    score() {\r\n        return {\r\n            f: Math.round(this.f()),\r\n            g: Math.round(this.g),\r\n            h: Math.round(this.f() - this.g)\r\n        }\r\n    }\r\n}\r\n","import {Point} from '../core/Components';\r\n\r\n/**\r\n * A simple data structure that keeps track of whether keys have been added to it\r\n */\r\nexport class HashSet\r\n{\r\n    private map: {[key: string]: boolean | undefined} = {};\r\n\r\n    add(key: string) {\r\n        this.map[key] = true;\r\n    }\r\n\r\n    remove(key: string) {\r\n        this.map[key] = undefined;\r\n    }\r\n\r\n    has(key: string) {\r\n        return this.map[key] !== undefined;\r\n    }\r\n\r\n    clear() {\r\n        this.map = {};\r\n    }\r\n}\r\n\r\n/**\r\n * A simple data structure that stores a type at a key\r\n */\r\nexport class HashTable<Value>\r\n{\r\n    private map: {[key: string]: Value | undefined} = {};\r\n\r\n    add(key: string, data: Value) {\r\n        this.map[key] = data;\r\n    }\r\n\r\n    remove(key: string) {\r\n        this.map[key] = undefined;\r\n    }\r\n\r\n    get(key: string) {\r\n        return this.map[key];\r\n    }\r\n\r\n    has(key: string) {\r\n        return this.map[key] !== undefined;\r\n    }\r\n\r\n    clear() {\r\n        this.map = {};\r\n    }\r\n}\r\n\r\n/**\r\n * Serialize point into a unique string\r\n * @param point\r\n */\r\nexport function stringify(point: Point) {\r\n    return 'x' + point.x + 'y' + point.y;\r\n}","/**\r\n * A compare function to determine if a is 'better' (deserves a higher position) than b\r\n */\r\nexport type Comparator<E> = (a: E, b: E) => boolean\r\n\r\n/**\r\n * Minimalist Implementation of the heap data structure as an array\r\n */\r\nclass Heap<E>\r\n{\r\n    private elements: E[] = [];\r\n    readonly compare: Comparator<E>;\r\n\r\n    constructor(compare: Comparator<E>) {\r\n        this.compare = compare;\r\n    }\r\n\r\n    /**\r\n     * Returns the size of the heap\r\n     */\r\n    getSize() {\r\n        return this.elements.length;\r\n    }\r\n\r\n    /**\r\n     * Checks if heap is empty\r\n     */\r\n    isEmpty() {\r\n        return this.elements.length === 0;\r\n    }\r\n\r\n    /**\r\n     * Add a new element to the heap\r\n     * @param e\r\n     */\r\n    push(e: E) {\r\n        this.elements.push(e);\r\n        this.siftUp(this.elements.length-1); //last element\r\n    }\r\n\r\n    /**\r\n     * Returns the top of the heap without removing it\r\n     * Fails if heap is empty\r\n     */\r\n    peek() {\r\n        return this.elements[0];\r\n    }\r\n\r\n    /**\r\n     * Returns the top of the heap and removes it\r\n     * Fails if heap is empty\r\n     */\r\n    pop() {\r\n        const val = this.peek();\r\n        this.move(this.elements.length - 1, 0);\r\n        this.elements.pop();\r\n        this.siftDown(0);\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Clear the heap\r\n     */\r\n    clear() {\r\n        this.elements = [];\r\n    }\r\n\r\n    /**\r\n     * Sifts a new element that is out of order up to the right position\r\n     * @param pos of new element\r\n     */\r\n    private siftUp(pos: number) {\r\n        let parent = ((pos - 1) / 2) >> 0; //integer division\r\n        while(parent >= 0) {\r\n            //if the current position is better than parent\r\n            if(this.compare(this.elements[pos], this.elements[parent])) {\r\n                //then current position with parent and move to next\r\n                this.swap(pos, parent);\r\n                pos = parent;\r\n                parent = ((pos - 1) / 2) >> 0;\r\n            } else {\r\n                //otherwise stop\r\n                parent = -1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sifts a new element that is out of order down to the right position\r\n     * @param pos of new element\r\n     */\r\n    private siftDown(pos: number) {\r\n        const left = 2 * pos + 1;\r\n        const right = 2 * pos + 2;\r\n        //stop if the children are out of bounds\r\n        if(left >= this.elements.length) {\r\n            return;\r\n        }\r\n        //find the better child\r\n        const child = (right >= this.elements.length || this.compare(this.elements[left], this.elements[right]))\r\n            ? left : right;\r\n        //continues to sift down if the child is better than the current position\r\n        if(this.compare(this.elements[child], this.elements[pos])) {\r\n            this.swap(child, pos);\r\n            this.siftDown(child);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal move function\r\n     * @param from\r\n     * @param to\r\n     */\r\n    private move(from: number, to: number) {\r\n        this.elements[to] = this.elements[from];\r\n    }\r\n\r\n    /**\r\n     * Internal swap function\r\n     * @param a\r\n     * @param b\r\n     */\r\n    private swap(a: number, b: number) {\r\n        let val = this.elements[a];\r\n        this.elements[a] = this.elements[b];\r\n        this.elements[b] = val;\r\n    }\r\n}\r\n\r\nexport default Heap;","import Pathfinder, {reconstructPath} from './Pathfinder';\r\nimport {euclidean, HeuristicFunc} from './Heuristics';\r\nimport {AStarNode} from './Node';\r\nimport {Point} from '../core/Components';\r\nimport Navigator from '../core/Navigator';\r\nimport {HashSet, HashTable, stringify} from '../structures/Hash';\r\nimport Heap from '../structures/Heap';\r\n\r\nclass AStarPathfinder extends Pathfinder\r\n{\r\n    private readonly heuristicFunc: HeuristicFunc = (a: Point, b: Point) => euclidean(a,b);\r\n    private readonly p: number; //tie breaker\r\n\r\n    constructor(navigator: Navigator, func?: HeuristicFunc) {\r\n        super(navigator);\r\n        const grid = this.getNavigator().getGrid();\r\n        //minimum cost of taking one step / expected maximum path length\r\n        this.p = 1/(grid.getWidth() * grid.getHeight());\r\n        if(func !== undefined) {\r\n            this.heuristicFunc = func;\r\n        }\r\n    }\r\n\r\n    getAlgorithmName() {\r\n        return 'A*';\r\n    }\r\n\r\n    /**\r\n     * Performs aStar algorithm on the grid given an initial and goal point\r\n     * Always returns the shortest path, and performs well on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point) {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const openFrontier = new Heap<AStarNode>(\r\n            (a, b) => a.f() < b.f()\r\n        );\r\n        const closedSet = new HashSet();\r\n        const openSet = new HashTable<number>();\r\n        const root = new AStarNode(\r\n            grid.get(initial), 0, 0\r\n        );\r\n        openFrontier.push(root);\r\n        openSet.add(stringify(initial), root.g);\r\n        while (!openFrontier.isEmpty()) {\r\n            const currentNode = openFrontier.pop();\r\n            const currentPoint = currentNode.tile.point;\r\n            const currentKey = stringify(currentPoint);\r\n            openSet.remove(currentKey);\r\n            if(closedSet.has(currentKey)) {\r\n                continue;\r\n            }\r\n            closedSet.add(currentKey);\r\n            this.addRecent(currentNode);\r\n            if (this.navigator.equals(currentPoint, goal)) {\r\n                return reconstructPath(currentNode);\r\n            }\r\n            for (const neighbor of this.navigator.neighbors(currentPoint)) {\r\n                const neighborPoint = neighbor.point;\r\n                const neighborKey = stringify(neighborPoint);\r\n                if(closedSet.has(neighborKey)) {\r\n                    continue;\r\n                }\r\n                const g = currentNode.g + this.stepCost(currentPoint, neighborPoint);\r\n                const f = g + this.heuristic(neighborPoint, goal);\r\n                if (!openSet.has(neighborKey) || g < openSet.get(neighborKey)!) {\r\n                    const neighborNode = new AStarNode(\r\n                        neighbor, g, f\r\n                    );\r\n                    currentNode.addChild(neighborNode);\r\n                    openFrontier.push(neighborNode);\r\n                    openSet.add(neighborKey, neighborNode.g);\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Heuristic function used to estimate distance between points a and b\r\n     * Includes tie breaker to prevent exploring lots of identical paths\r\n     * @param a\r\n     * @param b\r\n     */\r\n    heuristic(a: Point, b: Point) {\r\n        return this.heuristicFunc(a, b) * (1 + this.p);\r\n    }\r\n\r\n    /**\r\n     * The step-cost function to be used, calculating the cost from\r\n     * currentPoint to neighborPoint. Uses the stepCost function provided by the\r\n     * navigator by default but can be overridden\r\n     * @param currentPoint\r\n     * @param neighborPoint\r\n     */\r\n    stepCost(currentPoint: Point, neighborPoint: Point) {\r\n        return this.navigator.cost(currentPoint, neighborPoint);\r\n    }\r\n}\r\n\r\nexport default AStarPathfinder;","import Pathfinder, {reconstructPath} from './Pathfinder';\r\nimport {Node} from './Node';\r\nimport {Point} from '../core/Components';\r\nimport {HashSet, stringify} from '../structures/Hash';\r\n\r\nclass BFSPathfinder extends Pathfinder\r\n{\r\n    getAlgorithmName() {\r\n        return 'Breadth First Search';\r\n    }\r\n\r\n    /**\r\n     * Implementation of BFS to find the shortest path from initial to point\r\n     * Doesn't always return the shortest path, and performs poorly on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point) {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const frontier: Node[] = []; //fifo, stores nodes on the frontier\r\n        const visited = new HashSet();\r\n        const root = new Node(grid.get(initial));\r\n        frontier.push(root); //enqueue\r\n        visited.add(stringify(initial));\r\n        while(frontier.length !== 0) { //not empty\r\n            const currentNode = frontier.shift()!; //dequeue\r\n            const currentPoint = currentNode.tile.point;\r\n            this.addRecent(currentNode);\r\n            if(this.navigator.equals(currentPoint, goal)) {\r\n                return reconstructPath(currentNode);\r\n            }\r\n            for(const neighbor of this.navigator.neighbors(currentPoint)) {\r\n                const neighborKey = stringify(neighbor.point);\r\n                if(!visited.has(neighborKey)) {\r\n                    const neighborNode = new Node(neighbor);\r\n                    currentNode.addChild(neighborNode);\r\n                    frontier.push(neighborNode); //enqueue\r\n                    visited.add(neighborKey);\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\nexport default BFSPathfinder;","/**\r\n * Stack node\r\n */\r\nclass Node<E>\r\n{\r\n    next: Node<E> | null = null;\r\n    data: E;\r\n\r\n    constructor(data: E) {\r\n        this.data = data;\r\n    }\r\n}\r\n\r\n/**\r\n * Minimalist Implementation of the stack data structure\r\n */\r\nclass Stack<E>\r\n{\r\n    private top: Node<E> | null = null;\r\n    private size: number = 0;\r\n\r\n    peek() {\r\n        return this.top != null ? this.top.data : undefined;\r\n    }\r\n\r\n    push(e: E) {\r\n        const node = new Node(e);\r\n        node.next = this.top;\r\n        this.top = node;\r\n        this.size++;\r\n    }\r\n\r\n    pop() {\r\n        const top = this.peek();\r\n        if(this.top != null) {\r\n            this.top = this.top.next;\r\n            this.size--;\r\n        }\r\n        return top;\r\n    }\r\n\r\n    isEmpty() {\r\n        return this.size === 0;\r\n    }\r\n\r\n    getSize() {\r\n        return this.size;\r\n    }\r\n}\r\n\r\nexport default Stack;","import Pathfinder, {reconstructPath} from './Pathfinder';\r\nimport {Node} from './Node';\r\nimport {Point} from '../core/Components';\r\nimport {HashSet, stringify} from '../structures/Hash';\r\nimport Stack from '../structures/Stack';\r\n\r\nclass DFSPathfinder extends Pathfinder\r\n{\r\n    getAlgorithmName() {\r\n        return 'Depth First Search';\r\n    }\r\n\r\n    /**\r\n     * Calls DFS between a start and goal point, will typically not find the 'Best' path,\r\n     * and will instead find the best path capable for the algorithm\r\n     * As this algorithm is non optimal it should only be used for educational purposes\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point) {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const root = new Node(grid.get(initial));\r\n        const frontier = new Stack<Node>();\r\n        frontier.push(root);\r\n        const visited = new HashSet();\r\n        while(!frontier.isEmpty()) {\r\n            const currentNode = frontier.pop()!;\r\n            const currentPoint = currentNode.tile.point;\r\n            visited.add(stringify(currentPoint));\r\n            this.addRecent(currentNode);\r\n            if(this.navigator.equals(currentPoint, goal)) {\r\n                return reconstructPath(currentNode);\r\n            }\r\n            const neighbors = this.navigator.neighbors(currentPoint).reverse();\r\n            for(const neighbor of neighbors){\r\n                const neighborKey = stringify(neighbor.point);\r\n                if(!visited.has(neighborKey)) {\r\n                    const neighborNode = new Node(neighbor);\r\n                    currentNode.addChild(neighborNode);\r\n                    frontier.push(neighborNode);\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\nexport default DFSPathfinder;\r\n","import Pathfinder, {reconstructPath, reconstructPathReversed} from './Pathfinder';\r\nimport {euclidean, HeuristicFunc} from './Heuristics';\r\nimport {AStarNode} from './Node';\r\nimport {Point} from '../core/Components';\r\nimport Navigator from '../core/Navigator';\r\nimport {HashSet, HashTable, stringify} from '../structures/Hash';\r\nimport Heap from '../structures/Heap';\r\n\r\ninterface ControlStructures {\r\n    openSet: HashTable<AStarNode>,\r\n    closedSet: HashSet,\r\n    openFrontier: Heap<AStarNode>\r\n}\r\n\r\nclass BiAStarPathfinder extends Pathfinder\r\n{\r\n    private readonly heuristic: HeuristicFunc = (a: Point, b: Point) => euclidean(a,b);\r\n\r\n    constructor(navigator: Navigator, func?: HeuristicFunc) {\r\n        super(navigator);\r\n        if(func !== undefined) {\r\n            this.heuristic = func;\r\n        }\r\n    }\r\n\r\n    getAlgorithmName() {\r\n        return 'Bidirectional A*';\r\n    }\r\n\r\n    /**\r\n     * Performs aStar algorithm on the grid given an initial and goal point\r\n     * Doesn't always returns the shortest path, but performs well on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point) {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const closedSet = new HashSet();\r\n        const startOpenFrontier = new Heap<AStarNode>(\r\n            (a, b) => a.f() < b.f()\r\n        );\r\n        const startOpenSet = new HashTable<AStarNode>();\r\n        const endOpenFrontier = new Heap<AStarNode>(\r\n            (a, b) => a.f() < b.f()\r\n        );\r\n        const endOpenSet = new HashTable<AStarNode>();\r\n        const initialRoot = new AStarNode(\r\n            grid.get(initial), 0, 0\r\n        );\r\n        startOpenFrontier.push(initialRoot);\r\n        startOpenSet.add(stringify(initial), initialRoot);\r\n        const goalRoot = new AStarNode(\r\n            grid.get(goal), 0, 0\r\n        );\r\n        endOpenFrontier.push(goalRoot);\r\n        endOpenSet.add(stringify(goal), goalRoot);\r\n        while (!startOpenFrontier.isEmpty() && !endOpenFrontier.isEmpty()) {\r\n            //expand startOpenFrontier\r\n            const startCurrentNode = startOpenFrontier.pop();\r\n            const startCurrentPoint = startCurrentNode.tile.point;\r\n            const startCurrentPointKey = stringify(startCurrentPoint);\r\n            startOpenSet.remove(startCurrentPointKey);\r\n            if(closedSet.has(startCurrentPointKey)) {\r\n                continue;\r\n            }\r\n            closedSet.add(startCurrentPointKey);\r\n            this.addRecent(startCurrentNode);\r\n            if(endOpenSet.has(startCurrentPointKey)) {\r\n                if(startCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startCurrentNode.parent\r\n                    ).concat(reconstructPathReversed(\r\n                        endOpenSet.get(startCurrentPointKey)!\r\n                    )).concat(\r\n                        grid.get(goal)\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n            }\r\n            this.doAStarExpansion({\r\n                openFrontier: startOpenFrontier,\r\n                openSet: startOpenSet,\r\n                closedSet: closedSet\r\n            }, startCurrentNode, goal);\r\n            //expand endOpenFrontier\r\n            const endCurrentNode = endOpenFrontier.pop();\r\n            const endCurrentPoint = endCurrentNode.tile.point;\r\n            const endCurrentPointKey = stringify(endCurrentPoint);\r\n            endOpenSet.remove(endCurrentPointKey);\r\n            if(closedSet.has(endCurrentPointKey)) {\r\n                continue;\r\n            }\r\n            closedSet.add(endCurrentPointKey);\r\n            this.addRecent(endCurrentNode);\r\n            if(startOpenSet.has(endCurrentPointKey)) {\r\n                if(endCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startOpenSet.get(endCurrentPointKey)!\r\n                    ).concat(reconstructPathReversed(\r\n                        endCurrentNode.parent!\r\n                    )).concat(\r\n                        grid.get(goal)\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n            }\r\n            this.doAStarExpansion({\r\n                openFrontier: endOpenFrontier,\r\n                openSet: endOpenSet,\r\n                closedSet: closedSet\r\n            }, endCurrentNode, initial);\r\n        }\r\n        return [];\r\n    }\r\n\r\n    private doAStarExpansion(structures: ControlStructures, currentNode: AStarNode, endPoint: Point) {\r\n        const currentPoint = currentNode.tile.point;\r\n        for (const neighbor of this.navigator.neighbors(currentPoint)) {\r\n            const neighborPoint = neighbor.point;\r\n            const neighborKey = stringify(neighborPoint);\r\n            if(structures.closedSet.has(neighborKey)) {\r\n                continue;\r\n            }\r\n            const g = currentNode.g + this.stepCost(currentPoint, neighborPoint);\r\n            const f = g + this.heuristic(neighborPoint, endPoint);\r\n            if (!structures.openSet.has(neighborKey) || g < structures.openSet.get(neighborKey)!.g) {\r\n                const neighborNode = new AStarNode(\r\n                    neighbor, g, f\r\n                );\r\n                currentNode.addChild(neighborNode);\r\n                structures.openFrontier.push(neighborNode);\r\n                structures.openSet.add(neighborKey, neighborNode);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The step-cost function to be used, calculating the cost from\r\n     * currentPoint to neighborPoint. Uses the stepCost function provided by the\r\n     * navigator by default but can be overridden\r\n     * @param currentPoint\r\n     * @param neighborPoint\r\n     */\r\n    stepCost(currentPoint: Point, neighborPoint: Point) {\r\n        return this.navigator.cost(currentPoint, neighborPoint);\r\n    }\r\n}\r\n\r\nexport default BiAStarPathfinder;","import Pathfinder, {reconstructPath, reconstructPathReversed} from './Pathfinder';\r\nimport {Node} from './Node';\r\nimport {Point} from '../core/Components';\r\nimport {HashTable, stringify} from '../structures/Hash';\r\n\r\ninterface ControlStructures {\r\n    frontier: Node[],\r\n    visited: HashTable<Node>\r\n}\r\n\r\nclass BiBFSPathfinder extends Pathfinder\r\n{\r\n    getAlgorithmName() {\r\n        return 'Bidirectional Breadth First Search';\r\n    }\r\n\r\n    /**\r\n     * Implementation of BFS to find the shortest path from initial to point\r\n     * Doesn't always return the shortest path, and performs poorly on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point) {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const startVisited = new HashTable<Node>();\r\n        const endVisited = new HashTable<Node>();\r\n        const startFrontier: Node[] = [];\r\n        const endFrontier: Node[] = [];\r\n        const initialRoot = new Node(grid.get(initial));\r\n        startFrontier.push(initialRoot);\r\n        startVisited.add(stringify(initial), initialRoot);\r\n        const goalRoot = new Node(grid.get(goal));\r\n        endFrontier.push(goalRoot);\r\n        endVisited.add(stringify(goal), goalRoot);\r\n        while(startFrontier.length !== 0 && endFrontier.length !== 0) {\r\n            //expand startQueue\r\n            const startCurrentNode = startFrontier.shift()!;\r\n            const startCurrentPoint = startCurrentNode.tile.point;\r\n            const startCurrentPointKey = stringify(startCurrentPoint);\r\n            this.addRecent(startCurrentNode);\r\n            if(endVisited.has(startCurrentPointKey)) {\r\n                if(startCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startCurrentNode.parent\r\n                    ).concat(reconstructPathReversed(\r\n                        endVisited.get(startCurrentPointKey)!\r\n                    )).concat(\r\n                        grid.get(goal)\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n            }\r\n            this.doBFSExpansion({\r\n                frontier: startFrontier,\r\n                visited: startVisited\r\n            }, startCurrentNode);\r\n            //expand endQueue\r\n            const endCurrentNode = endFrontier.shift()!;\r\n            const endCurrentPoint = endCurrentNode.tile.point;\r\n            const endCurrentPointKey = stringify(endCurrentPoint);\r\n            this.addRecent(endCurrentNode);\r\n            if(startVisited.has(endCurrentPointKey)) {\r\n                if(endCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startVisited.get(endCurrentPointKey)!\r\n                    ).concat(reconstructPathReversed(\r\n                        endCurrentNode.parent\r\n                    )).concat(\r\n                        grid.get(goal)\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n            }\r\n            this.doBFSExpansion({\r\n                frontier: endFrontier,\r\n                visited: endVisited\r\n            }, endCurrentNode);\r\n        }\r\n        return [];\r\n    }\r\n\r\n    private doBFSExpansion(structures: ControlStructures, currentNode: Node) {\r\n        const currentPoint = currentNode.tile.point;\r\n        for(const neighbor of this.navigator.neighbors(currentPoint)) {\r\n            const neighborKey = stringify(neighbor.point);\r\n            if(!structures.visited.has(neighborKey)) {\r\n                const neighborNode = new Node(neighbor);\r\n                currentNode.addChild(neighborNode);\r\n                structures.frontier.push(neighborNode);\r\n                structures.visited.add(neighborKey, neighborNode);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default BiBFSPathfinder;","import Navigator from '../core/Navigator';\r\nimport PlusNavigator from '../core/PlusNavigator';\r\nimport {Point} from '../core/Components';\r\nimport {Grid} from '../core/Grid';\r\nimport {\r\n    chebyshev,\r\n    euclidean,\r\n    HeuristicFunc,\r\n    manhattan,\r\n    nullHeuristic,\r\n    octile\r\n} from './Heuristics';\r\nimport Pathfinder from './Pathfinder';\r\nimport AStarPathfinder from './AStarPathfinder';\r\nimport BFSPathfinder from './BFSPathfinder';\r\nimport DFSPathfinder from './DFSPathfinder';\r\nimport BiAStarPathfinder from './BiAStarPathfinder';\r\nimport BiBFSPathfinder from \"./BiBFSPathfinder\";\r\n\r\nconst CREATE_NAVIGATOR: {[key: string]: ((grid: Grid) => Navigator)} = {\r\n    'plus': (grid: Grid) => new PlusNavigator(grid),\r\n}\r\n\r\nconst CREATE_HEURISTIC: {[key: string]: (() => HeuristicFunc)} = {\r\n    'manhattan': () => manhattan,\r\n    'euclidean': () => euclidean,\r\n    'chebyshev': () => chebyshev,\r\n    'octile': () => octile,\r\n    'null': () => nullHeuristic\r\n}\r\n\r\nconst CREATE_PATHFINDER: {[key: string]: ((navigator: Navigator, heuristic: HeuristicFunc) => Pathfinder)} = {\r\n    'dijkstra': (navigator) => {\r\n        return new (class DijkstraPathfinder extends AStarPathfinder {\r\n            getAlgorithmName() {\r\n                return 'Dijkstra';\r\n            }\r\n        })(navigator, nullHeuristic);\r\n    },\r\n    'best-first': (navigator, heuristic) => {\r\n        return new (class BestFirstPathfinder extends AStarPathfinder {\r\n            stepCost(currentPoint: Point, neighborPoint: Point) {\r\n                return 0;\r\n            }\r\n            getAlgorithmName() {\r\n                return 'Best-First Search';\r\n            }\r\n        })(navigator, heuristic);\r\n    },\r\n    'a*': (navigator, heuristic) => {\r\n        return new AStarPathfinder(navigator, heuristic);\r\n    },\r\n    'bfs': (navigator) => {\r\n        return new BFSPathfinder(navigator);\r\n    },\r\n    'dfs': (navigator) => {\r\n        return new DFSPathfinder(navigator);\r\n    },\r\n    'bi-a*': (navigator, heuristic) => {\r\n        return new BiAStarPathfinder(navigator, heuristic);\r\n    },\r\n    'bi-dijkstra': (navigator) => {\r\n        return new (class BiDijkstraPathfinder extends BiAStarPathfinder {\r\n            getAlgorithmName() {\r\n                return 'Bidirectional Dijkstra';\r\n            }\r\n        })(navigator, nullHeuristic);\r\n    },\r\n    'bi-bfs': (navigator) => {\r\n        return new BiBFSPathfinder(navigator);\r\n    }\r\n}\r\n\r\nclass PathfinderBuilder\r\n{\r\n    private navigator: string = 'plus';\r\n    private algorithm: string = 'a*';\r\n    private heuristic: string = 'null';\r\n    private readonly grid: Readonly<Grid>;\r\n\r\n    constructor(grid: Readonly<Grid>) {\r\n        this.grid = grid;\r\n    }\r\n\r\n    setNavigator(navigator: string) {\r\n        navigator = navigator.toLowerCase();\r\n        if(CREATE_NAVIGATOR[navigator] == null) {\r\n            throw new Error('No such navigator pattern exists')\r\n        } else {\r\n            this.navigator = navigator;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    setAlgorithm(algorithm: string) {\r\n        algorithm = algorithm.toLowerCase();\r\n        if(CREATE_PATHFINDER[algorithm] == null) {\r\n            throw new Error('No such pathfinding algorithm exists')\r\n        } else {\r\n            this.algorithm = algorithm;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    setHeuristic(heuristic: string) {\r\n        heuristic = heuristic.toLowerCase();\r\n        if(CREATE_HEURISTIC[heuristic] == null) {\r\n            throw new Error('No such heuristic function exists')\r\n        } else {\r\n            this.heuristic = heuristic;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Builds a pathfinder with a navigator with the set algorithm, heuristic, and navigator\r\n     */\r\n    build() {\r\n        const createHeuristic = CREATE_HEURISTIC[this.heuristic];\r\n        const createNavigator = CREATE_NAVIGATOR[this.navigator];\r\n        const createPathfinder = CREATE_PATHFINDER[this.algorithm];\r\n        return createPathfinder(createNavigator(this.grid), createHeuristic());\r\n    }\r\n\r\n    static usesHeuristic(algorithm: string) {\r\n        return algorithm === 'a*' || algorithm === 'bi-a*' ||\r\n            algorithm === 'best-first';\r\n    }\r\n\r\n    static usesWeights(algorithm: string) {\r\n        return algorithm === 'a*' || algorithm === 'bi-a*' ||\r\n            algorithm === 'best-first' || algorithm === 'dijkstra' ||\r\n            algorithm === 'bi-dijkstra';\r\n    }\r\n\r\n    //checks if an algorithm has an even/intelligent expansion\r\n    //the only algorithm that doesn't expand breadth is dfs\r\n    static usesBreadthTree(algorithm: string) {\r\n        return algorithm !== 'dfs';\r\n    }\r\n\r\n    static hasBidirectional(algorithm: string) {\r\n        return CREATE_PATHFINDER['bi-' + algorithm] != null;\r\n    }\r\n\r\n    static makeBidirectional(algorithm: string) {\r\n        return 'bi-' + algorithm;\r\n    }\r\n}\r\n\r\nexport default PathfinderBuilder;\r\n\r\n","import React from 'react';\r\nimport {Node} from '../../pathfinding/algorithms/Node';\r\nimport {Point} from '../../pathfinding/core/Components';\r\nimport AppSettings from \"../../utils/AppSettings\";\r\nimport PathfinderBuilder from \"../../pathfinding/algorithms/PathfinderBuilder\";\r\n\r\nconst CLOSED_NODE = 'rgb(198, 237, 238)';\r\nconst OPEN_NODE = 'rgb(191, 248, 159)';\r\nconst ARROW_COLOR = 'rgb(153,153,153)';\r\nconst EMPTY_NODE = 'e';\r\nconst TILE_CLASS = 'tile';\r\nconst VIZ_TILE_CLASS = 'tile-viz';\r\n\r\nconst BASE_WIDTH = 27;\r\n\r\ninterface Score {\r\n    f: number,\r\n    g: number,\r\n    h: number\r\n}\r\n\r\ninterface Arrow {\r\n    to: Point,\r\n    from: Point\r\n}\r\n\r\ninterface IProps {\r\n    settings: AppSettings,\r\n    tileWidth: number,\r\n    tilesX: number,\r\n    tilesY: number\r\n}\r\n\r\ninterface IState {\r\n    visualization: string[][],\r\n    scores: Score[][],\r\n    arrows: Arrow[]\r\n}\r\n\r\n/**\r\n * Represents a visualization canvas for the background grid\r\n * Can be mutated using functions to change the state of the current visualization\r\n */\r\nclass GridBackground extends React.Component<IProps,IState>\r\n{\r\n    private readonly width: number;\r\n    private readonly height: number;\r\n    private readonly tileWidth: number;\r\n\r\n    private tileClass: string = TILE_CLASS;\r\n\r\n    private lastAlgo: string = '';\r\n\r\n    /**\r\n     * Constructs a GridBackground with immutable height and width\r\n     * @param props\r\n     */\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.width = this.props.tilesX;\r\n        this.height = this.props.tilesY;\r\n        this.tileWidth = this.props.tileWidth;\r\n        this.state = {\r\n            visualization: this.createEmptyViz(),\r\n            scores: this.createEmptyScores(),\r\n            arrows: []\r\n        }\r\n    }\r\n\r\n    setLastAlgo(lastAlgo: string) {\r\n        this.lastAlgo = lastAlgo;\r\n    }\r\n\r\n    /**\r\n     * Create a new empty visualization canvas\r\n     */\r\n    createEmptyViz() {\r\n        const visualization: string[][] = [];\r\n        for(let y = 0; y < this.height; y++) {\r\n            const row: string[] = [];\r\n            for(let x = 0; x < this.width; x++) {\r\n                row.push(EMPTY_NODE);\r\n            }\r\n            visualization.push(row);\r\n        }\r\n        return visualization;\r\n    }\r\n\r\n    /**\r\n     * Set scores to be -1\r\n     */\r\n    createEmptyScores() {\r\n        const scores: Score[][] = [];\r\n        for(let y = 0; y < this.height; y++) {\r\n            const row: Score[] = [];\r\n            for(let x = 0; x < this.width; x++) {\r\n                row.push({\r\n                    f: -1,\r\n                    g: -1,\r\n                    h: -1\r\n                });\r\n            }\r\n            scores.push(row);\r\n        }\r\n        return scores;\r\n    }\r\n\r\n    /**\r\n     * Clear the visualization canvas and update UI\r\n     */\r\n    clear() {\r\n        this.setState({\r\n            visualization: this.createEmptyViz(),\r\n            arrows: []\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Perform a generation on a visualization array\r\n     * @param generation\r\n     * @param visualization\r\n     */\r\n    static doVizGeneration(generation: Node, visualization: string[][]) {\r\n        for(const node of generation.children) {\r\n            const point = node.tile.point;\r\n            visualization[point.y][point.x] = OPEN_NODE;\r\n        }\r\n        const point = generation.tile.point;\r\n        visualization[point.y][point.x] = CLOSED_NODE;\r\n        return visualization;\r\n    }\r\n\r\n    /**\r\n     * Perform a generation on a score array\r\n     * @param generation\r\n     * @param scores\r\n     */\r\n    static doScoreGeneration(generation: Node, scores: Score[][]) {\r\n        for(const node of generation.children) {\r\n            const point = node.tile.point;\r\n            scores[point.y][point.x] = node.score();\r\n        }\r\n        const point = generation.tile.point;\r\n        scores[point.y][point.x] = generation.score();\r\n        return scores;\r\n    }\r\n\r\n    /**\r\n     * Visualize generation and update UI\r\n     * @param generation\r\n     */\r\n    visualizeGeneration(generation: Node) {\r\n        this.setState(prevState => ({\r\n            visualization: GridBackground.doVizGeneration(\r\n                generation,\r\n                clone(prevState.visualization)\r\n            ),\r\n            scores: GridBackground.doScoreGeneration(\r\n                generation,\r\n                clone(prevState.scores)\r\n            )\r\n        }));\r\n    }\r\n\r\n    enableAnimations() {\r\n        this.tileClass = VIZ_TILE_CLASS;\r\n    }\r\n\r\n    disableAnimations() {\r\n        this.tileClass = TILE_CLASS;\r\n    }\r\n\r\n    /**\r\n     * Visualize generation array and update UI\r\n     * @param generations\r\n     */\r\n    visualizeGenerations(generations: Node[]) {\r\n        const visualization = this.createEmptyViz();\r\n        const scores = this.createEmptyScores();\r\n        for(const generation of generations) {\r\n            GridBackground.doVizGeneration(generation, visualization);\r\n            GridBackground.doScoreGeneration(generation, scores);\r\n        }\r\n        this.setState({\r\n            visualization: visualization,\r\n            scores: scores\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Perform an arrow generation on an arrow array\r\n     * @param generation\r\n     * @param arrows\r\n     */\r\n    static doArrowGeneration(generation: Node, arrows: Arrow[]) {\r\n        const point = generation.tile.point;\r\n        for(const node of generation.children) {\r\n            const childPoint = node.tile.point;\r\n            const newArrow = {\r\n                from: point,\r\n                to: childPoint,\r\n            };\r\n            //remove a duplicate arrow to indicate replacement\r\n            //in A* for example, we could have re-discovered a better path to a tile\r\n            for(let i = 0; i < arrows.length; i++) {\r\n                const a = arrows[i];\r\n                if(pointsEqual(a.to, newArrow.to)) {\r\n                    const index = arrows.indexOf(a);\r\n                    arrows.splice(index, 1);\r\n                    i--;\r\n                }\r\n            }\r\n            arrows.push(newArrow);\r\n        }\r\n        return arrows;\r\n    }\r\n\r\n    /**\r\n     * Add arrow generation without updating UI\r\n     * @param generation\r\n     */\r\n    addArrowGeneration(generation: Node) {\r\n        this.setState(prevState => ({\r\n            arrows: GridBackground.doArrowGeneration(\r\n                generation,\r\n                prevState.arrows.slice()\r\n            )\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Add arrow generations and update UI\r\n     * @param generations\r\n     */\r\n    addArrowGenerations(generations: Node[]) {\r\n        const arrows: Arrow[] = [];\r\n        for(const generation of generations) {\r\n            GridBackground.doArrowGeneration(generation, arrows)\r\n        }\r\n        this.setState({\r\n            arrows: arrows\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Visualize both generation and arrows and update UI\r\n     * @param generation\r\n     */\r\n    visualizeGenerationAndArrows(generation: Node) {\r\n        this.setState(prevState => ({\r\n            visualization: GridBackground.doVizGeneration(\r\n                generation,\r\n                clone(prevState.visualization)\r\n            ),\r\n            scores: GridBackground.doScoreGeneration(\r\n                generation,\r\n                clone(prevState.scores)\r\n            ),\r\n            arrows: GridBackground.doArrowGeneration(\r\n                generation,\r\n                prevState.arrows.slice()\r\n            )\r\n        }));\r\n    }\r\n\r\n    render() {\r\n        // console.timeEnd('time');\r\n        // console.time('time');\r\n        return (\r\n            <div>\r\n                <div className='bg'>\r\n                    {this.props.settings.visualizeAlg ? this.renderViz() : []}\r\n                </div>\r\n                <svg\r\n                    xmlns='http://www.w3.org/2000/svg'\r\n                    className='bg-grid'\r\n                >\r\n                    <defs>\r\n                        <marker\r\n                            id='arrowhead'\r\n                            markerWidth='3'\r\n                            markerHeight='3'\r\n                            refX='0'\r\n                            refY='1.5'\r\n                            orient='auto'\r\n                            fill={ARROW_COLOR}\r\n                        >\r\n                            <polygon points='0 0, 3 1.5, 0 3'/>\r\n                        </marker>\r\n                    </defs>\r\n                    {this.props.settings.showArrows &&\r\n                        this.props.settings.visualizeAlg &&\r\n                        PathfinderBuilder.usesBreadthTree(this.lastAlgo)?\r\n                        this.renderArrows() :\r\n                        []\r\n                    }\r\n                </svg>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    renderArrows() {\r\n        const width = this.tileWidth;\r\n        const offset = width/2;\r\n        const arrows: JSX.Element[] = [];\r\n        for(let i = 0; i < this.state.arrows.length; i++) {\r\n            //calculate arrow position and dimensions\r\n            const arrow = this.state.arrows[i];\r\n            const first = arrow.from;\r\n            const second = arrow.to;\r\n            const firstX = first.x * width;\r\n            const firstY = first.y * width;\r\n            const secondX = second.x * width;\r\n            const secondY = second.y * width;\r\n            const offsetX = (secondX - firstX)/4;\r\n            const offsetY = (secondY - firstY)/4;\r\n            arrows.push(\r\n                <line\r\n                    key={'arrow ' + i}\r\n                    x1={firstX + offset + offsetX}\r\n                    y1={firstY + offset + offsetY}\r\n                    x2={secondX + offset - offsetX}\r\n                    y2={secondY + offset - offsetY}\r\n                    stroke={ARROW_COLOR}\r\n                    strokeWidth={2 * this.tileWidth/BASE_WIDTH}\r\n                    className='line-arrow'\r\n                    markerEnd='url(#arrowhead)'\r\n                />\r\n            );\r\n        }\r\n        return arrows;\r\n    }\r\n\r\n    renderViz() {\r\n        const tiles: JSX.Element[][] = [];\r\n        for(let y = 0; y < this.height; y++) {\r\n            const row: JSX.Element[] = [];\r\n            for(let x = 0; x < this.width; x++) {\r\n                const point = {\r\n                    x: x, y: y\r\n                };\r\n                const viz = this.state.visualization[point.y][point.x];\r\n                const score = this.state.scores[point.y][point.x];\r\n                if(viz !== EMPTY_NODE) {\r\n                    row.push(\r\n                        this.renderTile(point, viz, score)\r\n                    );\r\n                }\r\n            }\r\n            tiles.push(row);\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    renderTile(point: Point, color: string, score: Score) {\r\n        const width = this.tileWidth;\r\n        const top = point.y * width;\r\n        const left = point.x * width;\r\n        const style = {\r\n            backgroundColor: color,\r\n            width: width + 'px',\r\n            height: width + 'px',\r\n            top: top,\r\n            left: left,\r\n            fontSize: 10 * width/BASE_WIDTH\r\n        };\r\n        const text = this.props.settings.showScores ?\r\n            <div key={point.x + ',' + point.y + 'score'}>\r\n                <div className='f-text'>\r\n                    {score.f === -1 ? '' : score.f}\r\n                </div>\r\n            </div> :\r\n            ''\r\n        return (\r\n            <div\r\n                key={point.x + ',' + point.y}\r\n                style={style}\r\n                className={this.tileClass}\r\n            >\r\n                {text}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction clone<T>(array: T[][]) {\r\n    return array.map(\r\n        (arr) => arr.slice()\r\n    );\r\n}\r\n\r\nfunction pointsEqual(point1: Point, point2: Point) {\r\n    return point1.x === point2.x && point1.y === point2.y;\r\n}\r\n\r\nexport default GridBackground;","/**\r\n * Represents a point in 2d space\r\n * Immutable\r\n */\r\nexport interface Point\r\n{\r\n    readonly x: number;\r\n    readonly y: number;\r\n}\r\n\r\n/**\r\n * Represents the data inside a tile\r\n * Solid tiles cannot be passed while non solid ones can\r\n * pathCost stores how expensive it is to travel to the tile if it isn't solid\r\n * Immutable\r\n */\r\nexport interface TileData\r\n{\r\n    readonly pathCost: number;\r\n    readonly isSolid: boolean;\r\n}\r\n\r\n/**\r\n * Represents a tile on the Grid\r\n */\r\nexport interface Tile\r\n{\r\n    data: TileData;\r\n    readonly point: Point;\r\n}\r\n\r\n/**\r\n * Simple function to create a solid tile with path cost of 1\r\n * @param isSolid\r\n */\r\nexport function createTileData(isSolid: boolean): TileData {\r\n    return {\r\n        pathCost: 1,\r\n        isSolid: isSolid\r\n    }\r\n}\r\n\r\n","import {createTileData, Point, Tile, TileData} from './Components';\r\n\r\nexport interface Grid\r\n{\r\n    getWidth(): number;\r\n    getHeight(): number;\r\n    inBounds(point: Point): boolean;\r\n    get(point: Point): Tile;\r\n    isSolid(point: Point): boolean;\r\n    mutate(point: Point, data: TileData): void;\r\n    mutateTile(tile: Tile): void;\r\n    mutateDefault(point: Point, solid: boolean): void;\r\n    output(console: Console): void;\r\n    getJson(): string;\r\n    walkable(point: Point): boolean;\r\n    isEmpty(point: Point): boolean;\r\n    clone(): Grid;\r\n}\r\n\r\n/**\r\n * A square grid system that stores nodes in a matrix\r\n * Uses an x,y system where x corresponds to column of the matrix,\r\n * and y corresponds to the row of the matrix\r\n * Tile should be treated like graph nodes\r\n */\r\nclass RectGrid implements Grid\r\n{\r\n    private readonly tiles: Tile[][];\r\n    private readonly width: number;\r\n    private readonly height: number;\r\n\r\n    /**\r\n     * Constructs a grid either with empty or predefined tiles\r\n     * @param width of the grid\r\n     * @param height of grid\r\n     */\r\n    constructor(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.tiles = createEmptyGrid(width, height);\r\n    }\r\n\r\n    getWidth() {\r\n        return this.width;\r\n    }\r\n\r\n    getHeight() {\r\n        return this.height;\r\n    }\r\n\r\n    /**\r\n     * Checks if a given point is in bounds\r\n     * Other functions assume arguments are in bounds, this should be used\r\n     * if there is reasonable doubt about whether a point is in bounds\r\n     * @param point, to check\r\n     */\r\n    inBounds(point: Point) {\r\n        return point.x >= 0 && point.x < this.width && point.y >= 0 && point.y < this.height;\r\n    }\r\n\r\n    /**\r\n     * Retrieves a defensive tile for a position\r\n     * Defensive copy prevents this object from being mutated without calling\r\n     * a mutate function\r\n     * @param point, point to get\r\n     */\r\n    get(point: Point) {\r\n        return {\r\n            point: this.tiles[point.y][point.x].point,\r\n            data: this.tiles[point.y][point.x].data\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Mutates a position's tile to solid or non solid\r\n     * @param point, point to mutate\r\n     * @param data to mutate to\r\n     */\r\n    mutate(point: Point, data: TileData) {\r\n        this.tiles[point.y][point.x].data = data;\r\n    }\r\n\r\n    /**\r\n     * Mutates a a tile by point\r\n     * @param tile to mutate\r\n     */\r\n    mutateTile(tile: Tile) {\r\n        this.tiles[tile.point.y][tile.point.x].data = tile.data;\r\n    }\r\n\r\n    /**\r\n     * Mutate tile at point\r\n     * @param point to mutate at\r\n     * @param solid to determine what default tile to create\r\n     */\r\n    mutateDefault(point: Point, solid: boolean) {\r\n        this.mutate(\r\n            point, createTileData(solid)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Outputs the grid to a console\r\n     * @param console\r\n     */\r\n    output(console: Console) {\r\n        for(let y = 0; y < this.height; y++) {\r\n            let str = '';\r\n            for(let x = 0; x < this.width; x++) {\r\n                str += this.tiles[y][x].data.isSolid + ', ';\r\n            }\r\n            console.log(str);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns json of tiles\r\n     */\r\n    getJson() {\r\n        return JSON.stringify(this.tiles);\r\n    }\r\n\r\n    /**\r\n     * Determines if a tile can be walked on\r\n     * @param point\r\n     */\r\n    walkable(point: Point) {\r\n        return !this.tiles[point.y][point.x].data.isSolid;\r\n    }\r\n\r\n    /**\r\n     * Determines if a tile isSolid\r\n     * @param point\r\n     */\r\n    isSolid(point: Point) {\r\n        return this.tiles[point.y][point.x].data.isSolid;\r\n    }\r\n\r\n    /**\r\n     * Determines if a tile is \"empty\"\r\n     *  Meaning it isn't solid and it has a pathCost of 1\r\n     * @param point\r\n     */\r\n    isEmpty(point: Point) {\r\n        const data = this.tiles[point.y][point.x].data;\r\n        return data.pathCost === 1 && !data.isSolid\r\n    }\r\n\r\n    clone() {\r\n        const grid = new RectGrid(this.width, this.height);\r\n        for(let y = 0; y < grid.height; y++) {\r\n            for(let x = 0; x < grid.width; x++) {\r\n                const point = {\r\n                    x: x, y: y\r\n                }\r\n                grid.mutateTile(this.get(point));\r\n            }\r\n        }\r\n        return grid;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a 2d matrix of empty nodes\r\n */\r\nfunction createEmptyGrid(width: number, height: number) {\r\n    const nodes: Tile[][] = [];\r\n    for(let y = 0; y < height; y++) {\r\n        const row: Tile[] = [];\r\n        for(let x = 0; x < width; x++) {\r\n            row.push({\r\n                point: {\r\n                    x: x, y: y\r\n                },\r\n                data: createTileData(false)\r\n            });\r\n        }\r\n        nodes.push(row);\r\n    }\r\n    return nodes;\r\n}\r\n\r\nexport default RectGrid;","import React from 'react';\r\nimport {Point} from '../../pathfinding/core/Components';\r\n\r\ninterface TileProps {\r\n    tileWidth: number,\r\n    point: Point,\r\n    color: string,\r\n}\r\n\r\nclass TileFg extends React.Component<TileProps>\r\n{\r\n    render() {\r\n        const size = this.props.tileWidth\r\n        const top = this.props.point.y * this.props.tileWidth;\r\n        const left = this.props.point.x * this.props.tileWidth;\r\n        return (\r\n            <div\r\n                style={{\r\n                    position: 'absolute',\r\n                    width: size,\r\n                    height: size,\r\n                    top: top,\r\n                    left: left,\r\n                    backgroundColor: this.props.color,\r\n                    display: 'block',\r\n                    borderColor: this.props.color\r\n                }}\r\n                className={'svg-tile tile-fg'}\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nexport default TileFg;","import React from 'react';\r\nimport {Point} from '../../pathfinding/core/Components';\r\n\r\ninterface SolidProps {\r\n    tileSize: number,\r\n    point: Point,\r\n    doTileAnimation: boolean\r\n}\r\n\r\nclass SolidFg extends React.Component<SolidProps>\r\n{\r\n    private readonly doTileAnimation: boolean;\r\n\r\n    constructor(props: SolidProps) {\r\n        super(props)\r\n        this.doTileAnimation = this.props.doTileAnimation;\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div\r\n                style={{\r\n                    position: 'absolute',\r\n                    left: this.props.point.x * this.props.tileSize,\r\n                    top: this.props.point.y * this.props.tileSize,\r\n                    width: this.props.tileSize,\r\n                    height: this.props.tileSize\r\n                }}\r\n                className={this.doTileAnimation ? 'solid-animation' : 'solid'}\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nexport default SolidFg;","export default __webpack_public_path__ + \"static/media/weight.cae5804e.svg\";","import React from 'react';\r\nimport {Point} from '../../pathfinding/core/Components';\r\nimport Weight from '../../../images/weight.svg';\r\n\r\ninterface WeightProps {\r\n    tileSize: number,\r\n    point: Point,\r\n    doTileAnimation: boolean\r\n}\r\n\r\nclass WeightFg extends React.Component<WeightProps>\r\n{\r\n    private readonly doTileAnimation: boolean;\r\n\r\n    constructor(props: WeightProps) {\r\n        super(props)\r\n        this.doTileAnimation = this.props.doTileAnimation;\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div\r\n                style={{\r\n                    left: this.props.point.x * this.props.tileSize,\r\n                    top: this.props.point.y * this.props.tileSize,\r\n                    width: this.props.tileSize,\r\n                    height: this.props.tileSize,\r\n                    backgroundImage: `url(${Weight})`,\r\n                    position: 'absolute'\r\n                }}\r\n                className={this.doTileAnimation ? 'weight-animation' : 'weight'}\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nexport default WeightFg;","import React, {RefObject} from 'react';\r\nimport {createTileData, Point, Tile, TileData} from '../../pathfinding/core/Components';\r\nimport RectGrid, {Grid} from '../../pathfinding/core/Grid';\r\nimport TileFg from './TileFg';\r\nimport SolidFg from './SolidFg';\r\nimport WeightFg from './WeightFg';\r\n\r\ninterface IProps {\r\n    tileSize: number,\r\n    tilesX: number,\r\n    tilesY: number,\r\n    onTilesDragged: () => void,\r\n    topMargin: number\r\n}\r\n\r\ninterface IState {\r\n    grid: Grid,\r\n    initial: Point,\r\n    goal: Point,\r\n    path: Tile[]\r\n}\r\n\r\nconst INITIAL_COLOR = 'rgb(131, 217, 52)';\r\nconst GOAL_COLOR = 'rgb(203, 75, 14)';\r\nconst ARROW_PATH_COLOR = 'rgb(73, 79, 250)';\r\n\r\nconst BASE_WIDTH = 27;\r\n\r\n/**\r\n * Represents actual tile contents of the Grid itself\r\n * Will re-render itself when given a new Grid\r\n * Binds listeners to allow user to \"draw\" on the grid foreground\r\n */\r\nclass GridForeground extends React.Component<IProps,IState>\r\n{\r\n    private svg: RefObject<SVGSVGElement> = React.createRef();\r\n\r\n    private tilePointer: TileData;\r\n\r\n    private drawing: boolean = false;\r\n    private erasing: boolean = false;\r\n    private draggingInitial: boolean = false;\r\n    private draggingGoal: boolean = false;\r\n    private disable: boolean = false;\r\n\r\n    private doTileAnimation: boolean = true;\r\n\r\n    private readonly width: number;\r\n    private readonly height: number;\r\n\r\n    private initialKey: number = 0;\r\n    private goalKey: number = 0;\r\n\r\n    /**\r\n     * Constructs a GridForeground with immutable height and width\r\n     * @param props\r\n     */\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.width = this.props.tilesX;\r\n        this.height = this.props.tilesY;\r\n        const end = this.calcEndPointInView();\r\n        this.tilePointer = createTileData(true);\r\n        this.state = {\r\n            grid: new RectGrid(this.width, this.height),\r\n            path: [],\r\n            initial: {\r\n                x: ((end.x)/3) >> 0,\r\n                y: ((end.y)/3) >> 0\r\n            },\r\n            goal: {\r\n                x: ((2*(end.x)/3) >> 0) - 1,\r\n                y: ((2*(end.y)/3) >> 0) - 1\r\n            }\r\n        }\r\n    }\r\n\r\n    changeTile(data: TileData) {\r\n        this.tilePointer = data;\r\n    }\r\n\r\n    calcEndPointInView() {\r\n        const xEnd = Math.round(window.innerWidth / this.props.tileSize);\r\n        const yEnd = Math.round((window.innerHeight - this.props.topMargin - 30) / this.props.tileSize);\r\n        return {\r\n            x: xEnd, y: yEnd\r\n        }\r\n    }\r\n\r\n    toggleDisable() {\r\n        this.disable = !this.disable;\r\n    }\r\n\r\n    getBoundingRect() {\r\n        return this.svg.current!.getBoundingClientRect();\r\n    }\r\n\r\n    mouseDown(e: MouseEvent) {\r\n        e.preventDefault();\r\n        const bounds = this.getBoundingRect();\r\n        this.onPress(e.clientX - bounds.left, e.clientY - bounds.top, e.button);\r\n    }\r\n\r\n    mouseUp(e: MouseEvent) {\r\n        e.preventDefault();\r\n        if(isControlKey(e.button)) {\r\n            this.draggingGoal = false;\r\n            this.draggingInitial = false;\r\n            this.drawing = false;\r\n            this.erasing = false;\r\n        }\r\n    }\r\n\r\n    mouseMove(e: MouseEvent) {\r\n        const bounds = this.getBoundingRect();\r\n        this.onDrag(e.clientX - bounds.left, e.clientY - bounds.top);\r\n    }\r\n\r\n    touchStart(e: TouchEvent) {\r\n        const touch = e.touches[0] || e.changedTouches[0];\r\n        const bounds = this.getBoundingRect();\r\n        this.onPress(touch.clientX - bounds.left, touch.clientY - bounds.top, 0);\r\n    }\r\n\r\n    touchMove(e: TouchEvent) {\r\n        const touch = e.touches[0] || e.changedTouches[0];\r\n        const bounds = this.getBoundingRect();\r\n        this.onDrag(touch.clientX - bounds.left, touch.clientY - bounds.top);\r\n    }\r\n\r\n    onEndingEvent(e: Event) {\r\n        e.preventDefault();\r\n        this.draggingGoal = false;\r\n        this.draggingInitial = false;\r\n        this.drawing = false;\r\n        this.erasing = false;\r\n    }\r\n\r\n    /**\r\n     * Responds to the event thrown at screen coordinates on press\r\n     * @param xCoordinate\r\n     * @param yCoordinate\r\n     * @param button\r\n     */\r\n    onPress(xCoordinate: number, yCoordinate: number, button: number) {\r\n        const point = this.calculatePoint(xCoordinate,yCoordinate);\r\n        if(isControlKey(button)) {\r\n            if(pointsEqual(point, this.state.initial)) {\r\n                this.draggingInitial = true;\r\n            } else if(pointsEqual(point, this.state.goal)) {\r\n                this.draggingGoal = true;\r\n            } else if(!this.disable) {\r\n                if(this.state.grid.isEmpty(point)) {\r\n                    this.drawing = true;\r\n                    this.drawTile(point);\r\n                } else {\r\n                    this.erasing = true;\r\n                    this.eraseTile(point);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Responds to the event thrown at screen coordinates on drag/move\r\n     * @param xCoordinate\r\n     * @param yCoordinate\r\n     */\r\n    onDrag(xCoordinate: number, yCoordinate: number) {\r\n        const point = this.calculatePoint(xCoordinate,yCoordinate);\r\n        if(this.draggingInitial) {\r\n            this.moveInitial(point);\r\n        } else if(this.draggingGoal) {\r\n            this.moveGoal(point);\r\n        } else if(!pointsEqual(point, this.state.initial)\r\n            && !pointsEqual(point, this.state.goal) && !this.disable)\r\n        {\r\n            if(this.drawing) {\r\n                this.drawTile(point);\r\n            } else if(this.erasing) {\r\n                this.eraseTile(point);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw an entire new grid on the foreground with disabled animations\r\n     * @param grid\r\n     */\r\n    drawGrid(grid: Grid) {\r\n        this.doTileAnimation = false;\r\n        this.setState({\r\n            grid: grid\r\n        }, () => this.doTileAnimation = true)\r\n    }\r\n\r\n    /**\r\n     * Draw tile at point\r\n     * @param point\r\n     */\r\n    drawTile(point: Point) {\r\n        const grid = this.state.grid.clone();\r\n        if(grid.inBounds(point)) {\r\n            grid.mutateTile({\r\n                point: point,\r\n                data: this.tilePointer\r\n            });\r\n        }\r\n        this.setState({\r\n            grid: grid\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Checks if a node is visualized, then changes the tile to empty if it isn't\r\n     * @param point\r\n     */\r\n    eraseTile(point: Point) {\r\n        const grid = this.state.grid.clone();\r\n        if(grid.inBounds(point)) {\r\n            grid.mutateDefault(point, false);\r\n        }\r\n        this.setState({\r\n            grid: grid\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Clear grid in state\r\n     */\r\n    clearTiles() {\r\n        const grid = this.state.grid.clone();\r\n        for(let y = 0; y < this.height; y++) {\r\n            for(let x = 0; x < this.width; x++) {\r\n                const point = {\r\n                    x: x, y: y\r\n                }\r\n                grid.mutateDefault(point, false);\r\n            }\r\n        }\r\n        this.setState({\r\n            grid: grid\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Moves initial to a new point\r\n     * @param point\r\n     */\r\n    moveInitial(point: Point) {\r\n        if(this.canMoveEndPoint(point)) {\r\n            this.initialKey++;\r\n            this.setState({\r\n                initial: point\r\n            }, () => this.props.onTilesDragged());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves goal to a new point\r\n     * @param point\r\n     */\r\n    moveGoal(point: Point) {\r\n        if(this.canMoveEndPoint(point)) {\r\n            this.goalKey++;\r\n            this.setState({\r\n                goal: point\r\n            }, () => this.props.onTilesDragged());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if we can move any of the end points (goal or initial) to that point\r\n     * @param point\r\n     */\r\n    canMoveEndPoint(point: Point) {\r\n        return this.state.grid.inBounds(point)\r\n            && this.state.grid.isEmpty(point)\r\n            && !pointsEqual(this.state.initial, point)\r\n            && !pointsEqual(this.state.goal, point)\r\n            && !this.disable;\r\n    }\r\n\r\n    /**\r\n     * Draw a path onto the grid\r\n     * @param path\r\n     */\r\n    drawPath(path: Tile[]) {\r\n        this.setState({\r\n            path: path.slice()\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Erase path from the grid\r\n     */\r\n    erasePath() {\r\n        this.setState({\r\n            path: []\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts real screen x,y coordinates into\r\n     * a 2d point position on the grid\r\n     * @param xCoordinate\r\n     * @param yCoordinate\r\n     */\r\n    calculatePoint(xCoordinate: number, yCoordinate: number) {\r\n        return {\r\n            x: Math.floor(xCoordinate/this.props.tileSize),\r\n            y: Math.floor(yCoordinate/this.props.tileSize)\r\n        }\r\n    }\r\n\r\n    resetPoints() {\r\n        this.initialKey++;\r\n        this.goalKey++;\r\n        const end = this.calcEndPointInView();\r\n        this.setState({\r\n            initial: {\r\n                x: ((end.x)/3) >> 0,\r\n                y: ((end.y)/3) >> 0\r\n            },\r\n            goal: {\r\n                x: ((2*(end.x)/3) >> 0) - 1,\r\n                y: ((2*(end.y)/3) >> 0) - 1\r\n            }\r\n        });\r\n    }\r\n\r\n    render() {\r\n        // console.timeEnd('time');\r\n        // console.time('time');\r\n        return (\r\n            <div>\r\n                <div className='endpoint-tiles-table'>\r\n                    {this.renderEndTile(this.state.initial, INITIAL_COLOR,'initial' + this.initialKey)}\r\n                    {this.renderEndTile(this.state.goal, GOAL_COLOR,'goal' + this.goalKey)}\r\n                </div>\r\n                <svg\r\n                    ref={this.svg}\r\n                    xmlns='http://www.w3.org/2000/svg'\r\n                    className='arrow-grid'\r\n                >\r\n                    <defs>\r\n                        <marker\r\n                            id='arrowhead-path'\r\n                            markerWidth='3'\r\n                            markerHeight='3'\r\n                            refX='0'\r\n                            refY='1.5'\r\n                            orient='auto'\r\n                            fill={ARROW_PATH_COLOR}\r\n                        >\r\n                            <polygon points='0 0, 3 1.5, 0 3'/>\r\n                        </marker>\r\n                    </defs>\r\n                    {this.renderPath()}\r\n                </svg>\r\n                <div\r\n                    className='tiles-table'\r\n                    onContextMenu={e => e.preventDefault()}\r\n                    onMouseDown={e => this.mouseDown(e.nativeEvent)}\r\n                    onMouseUp={e => this.mouseUp(e.nativeEvent)}\r\n                    onMouseMove={e => this.mouseMove(e.nativeEvent)}\r\n                    onMouseLeave={e => this.onEndingEvent(e.nativeEvent)}\r\n                    onTouchStart={e => this.touchStart(e.nativeEvent)}\r\n                    onTouchMoveCapture={e => this.touchMove(e.nativeEvent)}\r\n                    onTouchEnd={e => this.onEndingEvent(e.nativeEvent)}\r\n                    onTouchCancel={e => this.onEndingEvent(e.nativeEvent)}\r\n                >\r\n                    {this.renderTilesTable()}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    renderPath() {\r\n        const lines: JSX.Element[] = [];\r\n        for(let i = 0; i < this.state.path.length-1; i++) {\r\n            const first = this.state.path[i].point;\r\n            const second = this.state.path[i+1].point;\r\n            lines.push(this.renderPathArrow(i, first, second));\r\n        }\r\n        return lines;\r\n    }\r\n\r\n    renderPathArrow(index: number, first: Point, second: Point) {\r\n        const width = this.props.tileSize;\r\n        const offset = width/2;\r\n        const firstX = first.x * width;\r\n        const firstY = first.y * width;\r\n        const secondX = second.x * width;\r\n        const secondY = second.y * width;\r\n        const offsetX = (secondX - firstX)/4;\r\n        const offsetY = (secondY - firstY)/4;\r\n        return (\r\n            <line\r\n                key={'path ' + index}\r\n                x1={firstX + offset + offsetX}\r\n                y1={firstY + offset + offsetY}\r\n                x2={secondX + offset - offsetX}\r\n                y2={secondY + offset - offsetY}\r\n                stroke={ARROW_PATH_COLOR}\r\n                strokeWidth={2 * this.props.tileSize/BASE_WIDTH}\r\n                className='line'\r\n                markerEnd='url(#arrowhead-path)'\r\n            />\r\n        );\r\n    }\r\n\r\n    renderTilesTable() {\r\n        const tiles: JSX.Element[] = [];\r\n        for(let y = 0; y < this.height; y++) {\r\n            for(let x = 0; x < this.width; x++) {\r\n                const point = {\r\n                    x: x, y: y\r\n                }\r\n                const cost = this.state.grid.get(point).data.pathCost;\r\n                if(this.state.grid.isSolid(point)) {\r\n                    //render a solid tile div\r\n                    tiles.push(\r\n                        <SolidFg\r\n                            key={x + ',' + y}\r\n                            point={point}\r\n                            tileSize={this.props.tileSize}\r\n                            doTileAnimation={this.doTileAnimation}\r\n                        />\r\n                    );\r\n                } else if(cost > 1) {\r\n                    //render a weight svg\r\n                    tiles.push(\r\n                        <WeightFg\r\n                            key={x + ',' + y}\r\n                            point={point}\r\n                            tileSize={this.props.tileSize}\r\n                            doTileAnimation={this.doTileAnimation}\r\n                        />\r\n                    );\r\n                    //render a div containing the cost as text\r\n                    tiles.push(\r\n                        this.renderWeightText(\r\n                            point,\r\n                            cost,\r\n                            x + ',' + y + ' text'\r\n                        )\r\n                    )\r\n                }\r\n            }\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    renderWeightText(point: Point, cost: number, key: string) {\r\n        return (\r\n            <div\r\n                key={key}\r\n                style={{\r\n                    left: point.x * this.props.tileSize,\r\n                    top: point.y * this.props.tileSize,\r\n                    width: this.props.tileSize,\r\n                    height: this.props.tileSize,\r\n                    position: 'absolute',\r\n                    color: 'white',\r\n                    fontSize: this.props.tileSize / 2.1,\r\n                    paddingTop: this.props.tileSize / 3.70,\r\n                    textAlign: 'center',\r\n                    cursor: 'default'\r\n                }}\r\n            >\r\n                {cost}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    renderEndTile(point: Point, color: string, key: string) {\r\n        return (\r\n            <TileFg\r\n                key={key}\r\n                point={point}\r\n                tileWidth={this.props.tileSize}\r\n                color={color}\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nfunction pointsEqual(point1: Point, point2: Point) {\r\n    return point1.x === point2.x && point1.y === point2.y;\r\n}\r\n\r\nfunction isControlKey(button: number) {\r\n    //right or left mouse\r\n    return button === 0 || button === 2;\r\n}\r\n\r\nexport default GridForeground;","import React, {RefObject} from 'react';\r\n\r\ninterface IProps {\r\n    algorithm: string,\r\n    length: number,\r\n    cost: number,\r\n    time: number,\r\n    nodes: number\r\n}\r\n\r\nclass StatsPanel extends React.Component<IProps>\r\n{\r\n    private readonly textLog: RefObject<HTMLTextAreaElement> = React.createRef();\r\n\r\n    componentDidUpdate() {\r\n        this.textLog.current!.scrollTop = this.textLog.current!.scrollHeight;\r\n    }\r\n\r\n    render() {\r\n        const time = precise(this.props.time);\r\n        const text = this.props.algorithm === '' ? '' :\r\n            this.props.algorithm +\r\n            ' visited ' +\r\n            this.props.nodes +\r\n            ' nodes in ' +\r\n            time +\r\n            ' ms. Path length = ' +\r\n            this.props.length +\r\n            '. Path cost = ' +\r\n            this.props.cost +\r\n            '. ';\r\n        return(\r\n            <textarea\r\n                tabIndex={-1}\r\n                ref={this.textLog}\r\n                readOnly={true}\r\n                className='stats-text-area no-select'\r\n                value={text}\r\n                unselectable={'on'}\r\n                onDrop={() => false}\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nfunction precise(x: number) {\r\n    return x.toFixed(2);\r\n}\r\n\r\nexport default StatsPanel;","import React from 'react';\r\nimport {Point} from '../../pathfinding/core/Components';\r\n\r\ninterface IProps {\r\n    tileWidth: number,\r\n    tilesX: number,\r\n    tilesY: number\r\n}\r\n\r\n/**\r\n * A component for a grid with specific width and height proportions\r\n */\r\nclass GridStaticTiles extends React.Component<IProps>\r\n{\r\n    private readonly width: number;\r\n    private readonly height: number;\r\n    private readonly tileWidth: number;\r\n\r\n    /**\r\n     * Constructs a GridBackground with immutable height and width\r\n     * @param props\r\n     */\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.width = this.props.tilesX;\r\n        this.height = this.props.tilesY;\r\n        this.tileWidth = this.props.tileWidth;\r\n    }\r\n\r\n    //should only render once, and never again\r\n    componentDidUpdate() {\r\n        return false;\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <div className='bg'>\r\n                    {this.renderTiles()}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    renderTiles() {\r\n        const tiles: JSX.Element[][] = [];\r\n        for(let y = 0; y < this.height; y++) {\r\n            const row: JSX.Element[] = [];\r\n            for(let x = 0; x < this.width; x++) {\r\n                const point = {\r\n                    x: x, y: y\r\n                };\r\n                row.push(\r\n                    this.renderTile(point)\r\n                );\r\n            }\r\n            tiles.push(row);\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    renderTile(point: Point) {\r\n        const width = this.tileWidth;\r\n        const top = point.y * this.tileWidth;\r\n        const left = point.x * this.tileWidth;\r\n        const style = {\r\n            backgroundColor: 'white',\r\n            width: width + 'px',\r\n            height: width + 'px',\r\n            top: top,\r\n            left: left\r\n        };\r\n        return (\r\n            <div\r\n                key={point.x + ',' + point.y}\r\n                style={style}\r\n                className='tile'\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nexport default GridStaticTiles;","import {createTileData, Point, Tile, TileData} from '../core/Components';\r\nimport {Grid} from '../core/Grid';\r\nimport {HashSet, stringify} from '../structures/Hash';\r\n\r\nabstract class TerrainGenerator\r\n{\r\n    protected readonly width: number;\r\n    protected readonly height: number;\r\n    protected readonly ignore: HashSet;\r\n    protected readonly data: TileData;\r\n\r\n    protected constructor(width: number, height: number, data?: TileData, ignore?: Point[]) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.ignore = new HashSet();\r\n        if(data !== undefined) {\r\n            this.data = data;\r\n        } else {\r\n            this.data = createTileData(true);\r\n        }\r\n        if(ignore !== undefined) {\r\n            for(const i of ignore) {\r\n                this.ignore.add(stringify(i));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws a tile to the grid\r\n     * @param grid\r\n     * @param tile\r\n     */\r\n    protected draw(grid: Grid, tile: Tile) {\r\n        if(!this.shouldIgnore(tile.point)) {\r\n            grid.mutateTile(tile);\r\n        }\r\n    }\r\n\r\n    protected getTerrain() {\r\n        return this.data;\r\n    }\r\n\r\n    protected getSolid() {\r\n        return {\r\n            pathCost: 1,\r\n            isSolid: true\r\n        }\r\n    }\r\n\r\n    protected shouldIgnore(point: Point) {\r\n        return this.ignore.has(stringify(point));\r\n    }\r\n\r\n    abstract generateTerrain(topLeft?: Point, bottomRight?: Point): Grid;\r\n}\r\n\r\nexport default TerrainGenerator;","import TerrainGenerator from './TerrainGenerator';\r\nimport {Point, TileData} from '../core/Components';\r\nimport RectGrid from '../core/Grid';\r\n\r\nclass TerrainRandomGenerator extends TerrainGenerator\r\n{\r\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\r\n    constructor(width: number, height: number, tileData?: TileData, ignore?: Point[]) {\r\n        super(width, height, tileData, ignore);\r\n    }\r\n\r\n    /**\r\n     * Performs a random terrain generation algorithm where each tile has a 1/4\r\n     * chance of being solid\r\n     * @param topLeft optional parameter to specify what point the terrain should start from\r\n     *  This should not be further up/left than (1,1)\r\n     * @param bottomRight optional parameter to specify how far down and right the terrain will go\r\n     *  This should not be further right/down than (width-2,height-2)\r\n     */\r\n    generateTerrain(topLeft?: Point, bottomRight?: Point) {\r\n        const grid = new RectGrid(this.width, this.height);\r\n        if(topLeft === undefined) {\r\n            topLeft = {\r\n                x: 1, y: 1\r\n            }\r\n        }\r\n        if(bottomRight === undefined) {\r\n            bottomRight = {\r\n                x: grid.getWidth()-2,\r\n                y: grid.getHeight()-2\r\n            }\r\n        }\r\n        for(let x = topLeft.x - 1; x <= bottomRight.x + 1; x++) {\r\n            for(let y = topLeft.y - 1; y <= bottomRight.y + 1; y++) {\r\n                if(getRand(0, 3) === 0) {\r\n                    this.draw(grid,{\r\n                        point: {\r\n                            x: x, y: y\r\n                        },\r\n                        data: this.getTerrain()\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        return grid;\r\n    }\r\n}\r\n\r\n/**\r\n * Generate a random number between min and max, inclusive for min and max\r\n * @param min\r\n * @param max\r\n */\r\nfunction getRand(min: number, max: number) {\r\n    return Math.floor(Math.random() * (max+1-min) + min);\r\n}\r\n\r\nexport default TerrainRandomGenerator;","import TerrainGenerator from './TerrainGenerator';\r\nimport RectGrid, {Grid} from '../core/Grid';\r\nimport {createTileData, Point, Tile, TileData} from '../core/Components';\r\n\r\nconst LIMIT = 2;\r\n\r\nexport const NO_SKEW = 0;\r\nexport const VERTICAL_SKEW = 1;\r\nexport const HORIZONTAL_SKEW = 2;\r\n\r\ninterface Chamber {\r\n    topLeft: Point; //min\r\n    bottomRight: Point; //max\r\n}\r\n\r\nclass TerrainMazeGenerator extends TerrainGenerator\r\n{\r\n    private readonly divideWidth: (width: number, height: number) => boolean;\r\n\r\n    constructor(width: number, height: number, tileData?: TileData, ignore?: Point[], slant?: number) {\r\n        super(width, height, tileData, ignore);\r\n        if(slant === undefined || slant === NO_SKEW) {\r\n            this.divideWidth = divideWidthNoSkew;\r\n        } else if(slant === VERTICAL_SKEW) {\r\n            this.divideWidth = divideWidthVSkew;\r\n        } else if(slant === HORIZONTAL_SKEW) {\r\n            this.divideWidth = divideWidthHSkew;\r\n        } else {\r\n            throw new Error(\"Invalid recursive maze division skew type\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Performs the recursive division maze generation algorithm on a new empty grid\r\n     * by bisecting parts until the maze can no longer be bisected\r\n     * Params must be within bounds and create a chamber\r\n     * @param topLeft optional parameter to specify what point the maze should start from\r\n     *  This should not be further up/left than (1,1)\r\n     * @param bottomRight optional parameter to specify how far down and right the maze will go\r\n     *  This should not be further right/down than (width-2,height-2)\r\n     */\r\n    generateTerrain(topLeft?: Point, bottomRight?: Point) {\r\n        const grid = new RectGrid(this.width, this.height);\r\n        if(topLeft === undefined) {\r\n            topLeft = {\r\n                x: 1, y: 1\r\n            }\r\n        }\r\n        if(bottomRight === undefined) {\r\n            bottomRight = {\r\n                x: grid.getWidth()-2,\r\n                y: grid.getHeight()-2\r\n            }\r\n        }\r\n        for(let x = topLeft.x - 1; x <= bottomRight.x + 1; x++) {\r\n            this.draw(grid,{\r\n                point: {\r\n                    x: x, y: topLeft.y - 1\r\n                },\r\n                data: this.getSolid()\r\n            });\r\n            this.draw(grid,{\r\n                point: {\r\n                    x: x, y: bottomRight.y + 1\r\n                },\r\n                data: this.getSolid()\r\n            });\r\n        }\r\n        for(let y = topLeft.y - 1; y <= bottomRight.y + 1; y++) {\r\n            this.draw(grid,{\r\n                point: {\r\n                    x: topLeft.x - 1, y: y\r\n                },\r\n                data: this.getSolid()\r\n            });\r\n            this.draw(grid,{\r\n                point: {\r\n                    x: bottomRight.x + 1, y: y\r\n                },\r\n                data: this.getSolid()\r\n            });\r\n        }\r\n        this.divide(grid,{\r\n            topLeft: topLeft,\r\n            bottomRight: bottomRight,\r\n        });\r\n        return grid;\r\n    }\r\n\r\n    /**\r\n     * Draws a list of tiles to the grid\r\n     * @param grid\r\n     * @param tiles\r\n     */\r\n    private drawArr(grid: Grid, tiles: Tile[]) {\r\n        for(const tile of tiles) {\r\n            this.draw(grid, tile);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a line between a region, with an open hole, in a chamber,\r\n     * and call bisection algorithm on it, and call division algorithms on\r\n     * its split chambers until no chambers can be bisected\r\n     * @param grid\r\n     * @param chamber\r\n     */\r\n    divide(grid: Grid, chamber: Chamber) {\r\n        const width = widthOf(chamber);\r\n        const height = heightOf(chamber);\r\n        const min = chamber.topLeft;\r\n        const max = chamber.bottomRight;\r\n        if(this.divideWidth(width,height)) {\r\n            if(width > LIMIT) {\r\n                //calculate axis\r\n                const randX = getMidPoint(\r\n                    min.x, max.x\r\n                );\r\n                //create axis wall\r\n                const toDraw: Tile[] = [];\r\n                for(let y = min.y; y <= max.y; y++) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: y\r\n                        },\r\n                        data: this.getTerrain()\r\n                    });\r\n                }\r\n                //create holes in axis wall\r\n                let edgeBlocked = false;\r\n                if(canDrawHole(grid.get({\r\n                    x: randX, y: min.y-1\r\n                }))) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: min.y\r\n                        },\r\n                        data: createTileData(false)\r\n                    });\r\n                    edgeBlocked = true;\r\n                }\r\n                if(canDrawHole(grid.get({\r\n                    x: randX, y: max.y+1\r\n                }))) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: max.y\r\n                        },\r\n                        data: createTileData(false)\r\n                    });\r\n                    edgeBlocked = true;\r\n                }\r\n                if(!edgeBlocked) {\r\n                    const randY = getRand(\r\n                        min.y, max.y,\r\n                    );\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: randY\r\n                        },\r\n                        data: createTileData(false)\r\n                    });\r\n                }\r\n                this.drawArr(grid, toDraw);\r\n                //create children chambers and recurse\r\n                const leftChamber = {\r\n                    topLeft: chamber.topLeft,\r\n                    bottomRight: {\r\n                        x: randX-1,\r\n                        y: chamber.bottomRight.y\r\n                    },\r\n                };\r\n                const rightChamber = {\r\n                    topLeft: {\r\n                        x: randX+1,\r\n                        y: chamber.topLeft.y\r\n                    },\r\n                    bottomRight: chamber.bottomRight,\r\n                };\r\n                this.divide(grid, leftChamber);\r\n                this.divide(grid, rightChamber);\r\n            }\r\n        } else {\r\n            if(height > LIMIT) {\r\n                //calculate axis\r\n                const randY = getMidPoint(\r\n                    min.y, max.y\r\n                );\r\n                //draw axis wall\r\n                const toDraw: Tile[] = [];\r\n                for(let x = min.x; x <= max.x; x++) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: x, y: randY\r\n                        },\r\n                        data: this.getTerrain()\r\n                    });\r\n                }\r\n                //create holes in axis wall\r\n                let edgeBlocked = false;\r\n                if(canDrawHole(grid.get({\r\n                    x: min.x-1, y: randY\r\n                }))) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: min.x, y: randY\r\n                        },\r\n                        data: createTileData(false)\r\n                    });\r\n                    edgeBlocked = true;\r\n                }\r\n                if(canDrawHole(grid.get({\r\n                    x: max.x+1, y: randY\r\n                }))) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: max.x, y: randY\r\n                        },\r\n                        data: createTileData(false)\r\n                    });\r\n                    edgeBlocked = true;\r\n                }\r\n                if(!edgeBlocked) {\r\n                    const randX = getRand(\r\n                        min.x, max.x,\r\n                    );\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: randY\r\n                        },\r\n                        data: createTileData(false)\r\n                    });\r\n                }\r\n                this.drawArr(grid, toDraw);\r\n                //create children chambers and recurse\r\n                const topChamber = {\r\n                    topLeft: chamber.topLeft,\r\n                    bottomRight: {\r\n                        x: chamber.bottomRight.x,\r\n                        y: randY-1\r\n                    },\r\n                };\r\n                const bottomChamber = {\r\n                    topLeft: {\r\n                        x: chamber.topLeft.x,\r\n                        y: randY+1\r\n                    },\r\n                    bottomRight: chamber.bottomRight,\r\n                };\r\n                this.divide(grid, topChamber);\r\n                this.divide(grid, bottomChamber);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction divideWidthNoSkew(width: number, height: number) {\r\n    return width >= height;\r\n}\r\n\r\nfunction divideWidthHSkew(width: number, height: number) {\r\n    return width >= height * 2;\r\n}\r\n\r\nfunction divideWidthVSkew(width: number, height: number) {\r\n    return width * 2 >= height;\r\n}\r\n\r\nfunction widthOf(chamber: Chamber) {\r\n    return chamber.bottomRight.x - chamber.topLeft.x + 1;\r\n}\r\n\r\nfunction heightOf(chamber: Chamber) {\r\n    return chamber.bottomRight.y - chamber.topLeft.y + 1;\r\n}\r\n\r\nfunction canDrawHole(tile: Tile) {\r\n    return tile.data.pathCost === 1 && !tile.data.isSolid;\r\n}\r\n\r\n/**\r\n * Returns the 'midpoint' to be used\r\n * @param min\r\n * @param max\r\n */\r\nfunction getMidPoint(min: number, max: number) {\r\n    const range = max - min;\r\n    if(range >= 20) {\r\n        return ((min+max)/2) >> 0;\r\n    } else if(range > 5) {\r\n        const mid = ((min+max)/2) >> 0;\r\n        const points = [mid, mid+1];\r\n        return points[getRand(0,points.length-1)];\r\n    } else {\r\n        return getRand(min+1,max-1);\r\n    }\r\n}\r\n\r\n/**\r\n * Generate a random number between min and max, inclusive for min and max\r\n * @param min\r\n * @param max\r\n */\r\nfunction getRand(min: number, max: number) {\r\n    return Math.floor(Math.random() * (max+1-min) + min);\r\n}\r\n\r\nexport default TerrainMazeGenerator;","import TerrainRandomGenerator from './TerrainRandomGenerator';\r\nimport TerrainMazeGenerator from './TerrainMazeGenerator';\r\nimport {createTileData, Point, TileData} from '../core/Components';\r\n\r\nexport const MAZE = 0;\r\nexport const MAZE_VERTICAL_SKEW = 1;\r\nexport const MAZE_HORIZONTAL_SKEW = 2;\r\nexport const RANDOM_TERRAIN = 3;\r\n\r\nclass TerrainGeneratorBuilder\r\n{\r\n    private width: number = 0;\r\n    private height: number = 0;\r\n    private type: number = MAZE;\r\n    private ignore: Point[] = [];\r\n    private data: TileData = createTileData(true);\r\n\r\n    setDimensions(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    setGeneratorType(type: number) {\r\n        this.type = type;\r\n        return this;\r\n    }\r\n\r\n    setIgnorePoints(ignore: Point[]) {\r\n        this.ignore = ignore.slice();\r\n        return this;\r\n    }\r\n\r\n    setTileData(data: TileData) {\r\n        this.data = data;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Builds a terrain generator with the specified type\r\n     */\r\n    build() {\r\n       if(this.type >= RANDOM_TERRAIN) {\r\n           return new TerrainRandomGenerator(this.width, this.height, this.data, this.ignore);\r\n       } else {\r\n           return new TerrainMazeGenerator(this.width, this.height, this.data, this.ignore, this.type);\r\n       }\r\n    }\r\n}\r\n\r\nexport default TerrainGeneratorBuilder;","class VirtualTimer\r\n{\r\n    private timeout: NodeJS.Timeout;\r\n    private readonly callback: () => void\r\n    private timeStarted: number;\r\n    private timeRemaining: number;\r\n    private finished: boolean;\r\n\r\n    constructor(callback: () => void, countDown: number) {\r\n        this.callback = callback;\r\n        this.finished = false;\r\n        this.timeStarted = Date.now();\r\n        this.timeRemaining = countDown;\r\n        this.timeout = setTimeout(() => {\r\n            callback();\r\n            this.finished = true;\r\n        }, this.timeRemaining);\r\n    }\r\n\r\n    clear() {\r\n        clearTimeout(this.timeout);\r\n        this.finished = true;\r\n    }\r\n\r\n    pause() {\r\n        if(!this.finished) {\r\n            clearTimeout(this.timeout);\r\n            this.timeRemaining -= Date.now() - this.timeStarted;\r\n        }\r\n    }\r\n\r\n    resume() {\r\n        if(!this.finished) {\r\n            this.timeStarted = Date.now();\r\n            this.timeout = setTimeout(() => {\r\n                this.callback();\r\n                this.finished = true;\r\n            }, this.timeRemaining);\r\n        }\r\n    }\r\n\r\n    isFinished() {\r\n        return this.finished;\r\n    }\r\n\r\n    getNativeTimeout() {\r\n        return this.timeout;\r\n    }\r\n}\r\n\r\nexport default VirtualTimer;","import React, {RefObject} from 'react';\r\nimport GridBackground from './GridBackground';\r\nimport GridForeground from './GridForeground';\r\nimport StatsPanel from './StatsPanel';\r\nimport GridStaticTiles from './GridStaticTiles';\r\nimport {Node} from '../../pathfinding/algorithms/Node';\r\nimport PathfinderBuilder from '../../pathfinding/algorithms/PathfinderBuilder';\r\nimport Pathfinder from '../../pathfinding/algorithms/Pathfinder';\r\nimport {euclidean} from '../../pathfinding/algorithms/Heuristics';\r\nimport TerrainGeneratorBuilder, {RANDOM_TERRAIN} from '../../pathfinding/algorithms/TerrainGeneratorBuilder';\r\nimport {createTileData, Point, Tile, TileData} from '../../pathfinding/core/Components';\r\nimport {HashSet, stringify} from '../../pathfinding/structures/Hash';\r\nimport AppSettings from '../../utils/AppSettings';\r\nimport VirtualTimer from '../../utils/VirtualTimer';\r\n\r\ninterface IProps {\r\n    tileWidth: number,\r\n    settings: Readonly<AppSettings>,\r\n    onChangeVisualizing: (visualizing: boolean) => void;\r\n}\r\n\r\ninterface IState {\r\n    time: number,\r\n    length: number,\r\n    cost: number,\r\n    nodes: number,\r\n    algorithm: string\r\n}\r\n\r\n/**\r\n * Component to encapsulate and perform all pathfinding operations\r\n * Exposes functions to initiate pathfinding or draw terrain\r\n */\r\nclass PathfindingVisualizer extends React.Component<IProps,IState>\r\n{\r\n    //references to expose background and foreground grids to parent\r\n    private background: RefObject<GridBackground> = React.createRef();\r\n    private foreground: RefObject<GridForeground> = React.createRef();\r\n\r\n    private visualized = false;\r\n    private visualizing = false;\r\n    private visualTimeouts: VirtualTimer[]  = [];\r\n    private generations: Node[] = [];\r\n    private paused = false;\r\n    private wasPaused = false; //paused before alt tab?\r\n\r\n    private mazeTile: TileData = createTileData(true);\r\n\r\n    private readonly tilesX: number;\r\n    private readonly tilesY: number;\r\n    private readonly tileWidth: number\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        const w = window.screen.availWidth - (window.outerWidth - window.innerWidth);\r\n        const h = window.screen.availHeight - (window.outerHeight - window.innerHeight);\r\n        this.tileWidth = this.props.tileWidth;\r\n        this.tilesX = Math.floor(w / this.tileWidth) + 1;\r\n        this.tilesY = Math.floor((h - 75 - 30) / this.tileWidth) + 1;\r\n        this.state = {\r\n            time: -1,\r\n            length: -1,\r\n            cost: -1,\r\n            nodes: -1,\r\n            algorithm: ''\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Automatically pause/resume the visualization when user alt tabs\r\n     */\r\n    componentDidMount() {\r\n        window.addEventListener('blur', () => {\r\n            this.wasPaused = this.isPaused();\r\n            if(!this.wasPaused) {\r\n                this.pausePathfinding();\r\n            }\r\n        });\r\n        window.addEventListener('focus', () => {\r\n            if(this.isPaused() && !this.wasPaused) {\r\n                this.resumePathfinding();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Prevents pathfinding visualizer from being updated unless the algorithm stats\r\n     * have changed (meaning an algorithm was visualized)\r\n     * Doesn't prevent Foreground and background from being updated automatically\r\n     * when their state changes\r\n     * @param nextProps\r\n     * @param nextState\r\n     */\r\n    shouldComponentUpdate(nextProps: Readonly<IProps>, nextState: Readonly<IState>) {\r\n        const prevState = this.state;\r\n        const prevProps = this.props;\r\n        return prevProps.settings.showArrows !== nextProps.settings.showArrows ||\r\n            prevProps.settings.showScores !== nextProps.settings.showScores ||\r\n            prevProps.settings.visualizeAlg !== nextProps.settings.visualizeAlg ||\r\n            prevState.time !== nextState.time ||\r\n            prevState.length !== nextState.length ||\r\n            prevState.cost !== nextState.cost ||\r\n            prevState.nodes !== nextState.nodes ||\r\n            prevState.algorithm !== nextState.algorithm;\r\n    }\r\n\r\n    changeTile(data: TileData) {\r\n        this.mazeTile = data; //enables weighted terrain\r\n        this.foreground.current!.changeTile(data);\r\n    }\r\n\r\n    canShowVisualization() {\r\n        const settings = this.props.settings;\r\n        return settings.visualizeAlg;\r\n    }\r\n\r\n    isPaused() {\r\n        return this.paused;\r\n    }\r\n\r\n    /**\r\n     * Pause the delayed pathfinding algorithm being performed\r\n     */\r\n    pausePathfinding() {\r\n        this.paused = true;\r\n        for(const timeout of this.visualTimeouts) {\r\n            timeout.pause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resume the delayed pathfinding algorithm being performed\r\n     * Will reset the timeouts to the last time the timeout was paused/started\r\n     * if not properly called while the timeout is paused\r\n     */\r\n    resumePathfinding() {\r\n        this.paused = false;\r\n        for(const timeout of this.visualTimeouts) {\r\n            timeout.resume();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Performs the pathfinding algorithm on the grid and visualizes it\r\n     */\r\n    doPathfinding() {\r\n        this.clearPath();\r\n        const settings = this.props.settings;\r\n        const pathfinder = this.getPathfinder(settings);\r\n        const path = this.findPath(pathfinder);\r\n        this.generations = pathfinder.getRecentGenerations();\r\n        this.visualizeGenerations(this.generations);\r\n        this.addArrowGenerations(this.generations);\r\n        this.drawPath(path);\r\n    }\r\n\r\n    /**\r\n     * Performs the pathfinding algorithm on the grid and visualizes it with delays between successive\r\n     * node generations\r\n     * If the visualizer is currently visualizing, the visualization stops instead\r\n     */\r\n    doDelayedPathfinding() {\r\n        const settings = this.props.settings;\r\n        const background = this.background.current!;\r\n        background.setLastAlgo(settings.algorithm)\r\n        background.enableAnimations();\r\n        this.paused = false;\r\n        this.clearVisualization();\r\n        this.clearPath();\r\n        this.visualized = false;\r\n        const foreground = this.foreground.current!;\r\n        foreground.toggleDisable();\r\n        if(!this.visualizing) { //start visualization if not visualizing\r\n            this.visualizing = true;\r\n            this.props.onChangeVisualizing(this.visualizing);\r\n            const pathfinder = this.getPathfinder(settings);\r\n            const path = this.findPath(pathfinder);\r\n            const promises: Promise<VirtualTimer>[] = []; //to call function when timeouts finish\r\n            this.visualTimeouts = [];\r\n            const baseIncrement = settings.delayInc;\r\n            const visualizeAlg = this.canShowVisualization();\r\n            if(visualizeAlg) {\r\n                let delay = 0;\r\n                this.generations = pathfinder.getRecentGenerations();\r\n                const generationSet = new HashSet(); //to keep track of rediscovered nodes\r\n                this.generations.forEach((generation) => {\r\n                    const promise = new Promise<VirtualTimer>((resolve) => {\r\n                        //each generation gets a higher timeout\r\n                        const timeout = new VirtualTimer(() => {\r\n                            this.visualizeGenerationAndArrows(generation);\r\n                            resolve(timeout);\r\n                        }, delay);\r\n                        this.visualTimeouts.push(timeout);\r\n                    });\r\n                    promises.push(promise);\r\n                    if(!generationSet.has(stringify(generation.tile.point))) {\r\n                        //rediscovered nodes shouldn't add a delay to visualization\r\n                        delay += baseIncrement;\r\n                    }\r\n                    generationSet.add(stringify(generation.tile.point));\r\n                });\r\n            }\r\n            //call functions when timeouts finish\r\n            Promise.all(promises).then(() => {\r\n                this.drawPath(path);\r\n                foreground.toggleDisable();\r\n                this.visualizing = false;\r\n                this.visualized = true;\r\n                this.props.onChangeVisualizing(this.visualizing);\r\n                background.disableAnimations();\r\n            });\r\n        } else { //stop visualizing if currently visualizing\r\n            for (const timeout of this.visualTimeouts) {\r\n                timeout.clear();\r\n            }\r\n            this.visualizing = false;\r\n            this.props.onChangeVisualizing(this.visualizing);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the pathfinder for the settings\r\n     * @param settings\r\n     */\r\n    getPathfinder(settings: AppSettings) {\r\n        const algorithmKey = settings.algorithm;\r\n        const algorithm = settings.bidirectional && PathfinderBuilder.hasBidirectional(algorithmKey) ?\r\n            PathfinderBuilder.makeBidirectional(algorithmKey) : algorithmKey;\r\n        return new PathfinderBuilder(this.foreground.current!.state.grid)\r\n            .setAlgorithm(algorithm)\r\n            .setHeuristic(settings.heuristicKey)\r\n            .setNavigator(settings.navigatorKey)\r\n            .build();\r\n    }\r\n\r\n    /**\r\n     * Find path with a given pathfinder, includes benchmarking\r\n     * @param pathfinder\r\n     */\r\n     findPath(pathfinder: Pathfinder) {\r\n        const foreground = this.foreground.current!;\r\n        const t0 = performance.now();\r\n        const path = pathfinder.findPath(foreground.state.initial, foreground.state.goal);\r\n        const t1 = performance.now();\r\n        const t2 = t1 - t0;\r\n        this.setState({\r\n            time: t2,\r\n            nodes: pathfinder.getRecentNodes(),\r\n            length: calcLength(foreground.state.initial, path),\r\n            cost: calcCost(foreground.state.grid.get(foreground.state.initial), path),\r\n            algorithm: pathfinder.getAlgorithmName()\r\n        });\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Draw path on the grid and change length on ui\r\n     * @param path\r\n     */\r\n    drawPath(path: Tile[]) {\r\n        const foreground = this.foreground.current!\r\n        path.unshift(this.foreground.current!.state.grid.get(foreground.state.initial));\r\n        this.foreground.current!.drawPath(path);\r\n    }\r\n\r\n    /**\r\n     * Called when child foreground moves a tile\r\n     */\r\n    onTilesDragged() {\r\n        if(this.visualized) {\r\n            this.clearVisualization();\r\n            this.doPathfinding();\r\n            this.visualized = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create terrain on the grid foreground\r\n     */\r\n    createTerrain(mazeType: number, useMazeTile: boolean) {\r\n        if(this.visualizing) {\r\n            return;\r\n        }\r\n        this.clearTiles();\r\n        this.clearPath();\r\n        this.clearVisualization();\r\n        const foreground = this.foreground.current!;\r\n        const end = this.calcEndPointInView();\r\n        const newState = (mazeType !== RANDOM_TERRAIN) ? {\r\n            initial: {\r\n                x: 1, y: 1\r\n            },\r\n            goal: {\r\n                x: end.x-2, y: end.y-2\r\n            }\r\n        } : {\r\n            initial: {\r\n                x: 1, y: ((end.y-1) / 2) >> 0\r\n            },\r\n            goal: {\r\n                x: end.x-2, y: ((end.y-1) / 2) >> 0\r\n            }\r\n        };\r\n        foreground.setState(newState,() => {\r\n            const prevGrid = foreground.state.grid;\r\n            const generator = new TerrainGeneratorBuilder()\r\n                .setDimensions(\r\n                    prevGrid.getWidth(),\r\n                    prevGrid.getHeight()\r\n                )\r\n                .setGeneratorType(mazeType)\r\n                .setIgnorePoints([foreground.state.initial, foreground.state.goal])\r\n                .setTileData(useMazeTile ? this.mazeTile : getSolid())\r\n                .build();\r\n            const topLeft = {\r\n                x: 1, y: 1\r\n            };\r\n            const bottomRight = {\r\n                x: end.x-2, y: end.y-2\r\n            };\r\n            const grid = generator.generateTerrain(topLeft, bottomRight);\r\n            foreground.drawGrid(grid);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Calculate the end/goal point in view of the screen\r\n     * Used to calculate the terrain dimensions\r\n     */\r\n    calcEndPointInView() {\r\n        const xEnd = window.innerWidth / this.tileWidth;\r\n        const yEnd = (window.innerHeight - 75 - 30) / this.tileWidth;\r\n        const xFloor = Math.floor(xEnd);\r\n        const yFloor = Math.floor(yEnd);\r\n        const xDecimal = xEnd - xFloor;\r\n        const yDecimal = yEnd - yFloor;\r\n        let x = xDecimal > 0.05 ? Math.ceil(xEnd) : xFloor;\r\n        let y = yDecimal > 0.05 ? Math.ceil(yEnd) : yFloor;\r\n        if(x > this.tilesX) {\r\n            x = this.tilesX\r\n        }\r\n        if(y > this.tilesY) {\r\n            y = this.tilesY\r\n        }\r\n        return {\r\n            x: x, y: y\r\n        }\r\n    }\r\n\r\n    resetPoints() {\r\n        if(!this.visualizing) {\r\n            this.foreground.current!.resetPoints();\r\n        }\r\n    }\r\n\r\n    clearPath = () => {\r\n        this.foreground.current!.erasePath();\r\n    }\r\n\r\n    clearTiles() {\r\n        this.foreground.current!.clearTiles();\r\n    }\r\n\r\n    clearTilesChecked() {\r\n        if(!this.visualizing) {\r\n            this.foreground.current!.clearTiles();\r\n        }\r\n    }\r\n\r\n    clearVisualization() {\r\n        this.visualized = false;\r\n        this.background.current!.clear();\r\n    }\r\n\r\n    clearVisualizationChecked() {\r\n        if(!this.visualizing) {\r\n            this.visualized = false;\r\n            this.background.current!.clear();\r\n        }\r\n    }\r\n\r\n    visualizeGenerations(generations: Node[]) {\r\n        this.background.current!.visualizeGenerations(generations);\r\n        this.visualized = true;\r\n    }\r\n\r\n    visualizeGeneration(generation: Node) {\r\n        this.background.current!.visualizeGeneration(generation);\r\n    }\r\n\r\n    addArrowGenerations(generations: Node[]) {\r\n        this.background.current!.addArrowGenerations(generations);\r\n    }\r\n\r\n    addArrowGeneration(generation: Node) {\r\n        this.background.current!.addArrowGeneration(generation);\r\n    }\r\n\r\n    visualizeGenerationAndArrows(generation: Node) {\r\n        this.background.current!.visualizeGenerationAndArrows(generation);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <StatsPanel\r\n                    algorithm={this.state.algorithm}\r\n                    length={this.state.length}\r\n                    cost={this.state.cost}\r\n                    time={this.state.time}\r\n                    nodes={this.state.nodes}\r\n                />\r\n                <div>\r\n                    <GridStaticTiles\r\n                        tileWidth={this.tileWidth}\r\n                        tilesX={this.tilesX}\r\n                        tilesY={this.tilesY}\r\n                    />\r\n                    <GridBackground\r\n                        ref={this.background}\r\n                        settings={this.props.settings}\r\n                        tileWidth={this.tileWidth}\r\n                        tilesX={this.tilesX}\r\n                        tilesY={this.tilesY}\r\n                    />\r\n                    <GridForeground\r\n                        ref={this.foreground}\r\n                        topMargin={75}\r\n                        onTilesDragged={() => this.onTilesDragged()}\r\n                        tileSize={this.tileWidth}\r\n                        tilesX={this.tilesX}\r\n                        tilesY={this.tilesY}\r\n                    />\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction getSolid() {\r\n    return {\r\n        pathCost: 1,\r\n        isSolid: true\r\n    }\r\n}\r\n\r\nfunction calcLength(initial: Point, path: Tile[]) {\r\n    if(path.length === 0) {\r\n        return 0;\r\n    }\r\n    let len = euclidean(initial, path[0].point);\r\n    for (let i = 0; i < path.length - 1; i++) {\r\n        len += euclidean(path[i].point, path[i + 1].point);\r\n    }\r\n    return +(len).toFixed(3);\r\n}\r\n\r\nfunction calcCost(initial: Tile, path: Tile[]) {\r\n    if(path.length === 0) {\r\n        return 0;\r\n    }\r\n    let len = euclidean(initial.point, path[0].point) * path[0].data.pathCost;\r\n    for (let i = 0; i < path.length - 1; i++) {\r\n        len += euclidean(path[i].point, path[i + 1].point) * path[i + 1].data.pathCost;\r\n    }\r\n    return +(len).toFixed(3);\r\n}\r\n\r\nexport default PathfindingVisualizer;","export default __webpack_public_path__ + \"static/media/react.93a4bdf1.png\";","import React, {RefObject} from 'react';\r\nimport TopBar from './navbar/TopBar';\r\nimport {SettingsButton, VisualizeButton} from './navbar/Buttons';\r\nimport {\r\n    AlgorithmDropDown,\r\n    ClearDropDown,\r\n    MazeDropDown,\r\n    TilesDropDown\r\n} from './navbar/DropDownComponents';\r\nimport {\r\n    AlgorithmSettings,\r\n    HeuristicSettings, \r\n    SpeedSettings,\r\n    VisualSettings\r\n} from './navbar/SettingPanels';\r\nimport DraggablePanel from './panel/DraggablePanel';\r\nimport PathfindingVisualizer from './grid/PathfindingVisualizer';\r\nimport PathfinderBuilder from '../pathfinding/algorithms/PathfinderBuilder';\r\nimport {\r\n    MAZE,\r\n    MAZE_HORIZONTAL_SKEW,\r\n    MAZE_VERTICAL_SKEW,\r\n    RANDOM_TERRAIN\r\n} from '../pathfinding/algorithms/TerrainGeneratorBuilder';\r\nimport Icon from '../../images/react.png';\r\nimport AppSettings, {getDefaultSettings} from \"../utils/AppSettings\";\r\n\r\ninterface IProps {}\r\n\r\ninterface IState {\r\n    settings: AppSettings,\r\n\r\n    heuristicDisabled: boolean,\r\n    bidirectionalDisabled: boolean,\r\n    arrowsDisabled: boolean,\r\n    scoreDisabled: boolean\r\n\r\n    panelShow: boolean,\r\n\r\n    visualizing: boolean,\r\n    paused: boolean,\r\n\r\n    useIcon: boolean\r\n}\r\n\r\nclass PathfindingApp extends React.Component<IProps, IState>\r\n{\r\n    //expose visualizer to parent to connect to button siblings\r\n    private visualizer: RefObject<PathfindingVisualizer> = React.createRef();\r\n\r\n    //drop down refs needed to invoke behavior between dropdowns\r\n    private algDropDown: RefObject<AlgorithmDropDown> = React.createRef();\r\n    private clrDropDown: RefObject<ClearDropDown> = React.createRef();\r\n    private mazeDropDown: RefObject<MazeDropDown> = React.createRef();\r\n    private tilesDropDown: RefObject<TilesDropDown> = React.createRef();\r\n\r\n    private readonly tileWidth: number;\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.state = {\r\n            settings: getDefaultSettings(),\r\n            heuristicDisabled: false,\r\n            bidirectionalDisabled: false,\r\n            arrowsDisabled: false,\r\n            scoreDisabled: false,\r\n            panelShow: false,\r\n            visualizing: false,\r\n            paused: false,\r\n            useIcon: this.useIcon()\r\n        }\r\n        const mobile = isMobile();\r\n        this.tileWidth =  mobile ? 47 : Math.round(window.screen.availWidth / 57);\r\n    }\r\n\r\n    /**\r\n     * Binds window listeners.\r\n     * One listener is to hide drop downs on click anywhere\r\n     * Other listener is to keep track of screen size to check if we show icon\r\n     */\r\n    componentDidMount() {\r\n        window.addEventListener('click', () => {\r\n            this.algDropDown.current!.hide();\r\n            this.clrDropDown.current!.hide();\r\n            this.mazeDropDown.current!.hide();\r\n            this.tilesDropDown.current!.hide();\r\n        });\r\n        window.addEventListener('resize', () => {\r\n            this.setState({\r\n                useIcon: this.useIcon()\r\n            })\r\n        });\r\n    }\r\n\r\n    useIcon() {\r\n        return window.innerWidth <= 850;\r\n    }\r\n\r\n    /**\r\n     * Called when the drop downs are clicked to prevent more\r\n     * than one dropdown from being open at a time\r\n     */\r\n\r\n    onClickAlgDrop() {\r\n        this.clrDropDown.current!.hide();\r\n        this.mazeDropDown.current!.hide();\r\n        this.tilesDropDown.current!.hide();\r\n    }\r\n\r\n    onClickClrDrop() {\r\n        this.algDropDown.current!.hide();\r\n        this.mazeDropDown.current!.hide();\r\n        this.tilesDropDown.current!.hide();\r\n    }\r\n\r\n    onClickMazeDrop() {\r\n        this.clrDropDown.current!.hide();\r\n        this.algDropDown.current!.hide();\r\n        this.tilesDropDown.current!.hide();\r\n    }\r\n\r\n    onClickTilesDrop() {\r\n        this.clrDropDown.current!.hide();\r\n        this.algDropDown.current!.hide();\r\n        this.mazeDropDown.current!.hide();\r\n    }\r\n\r\n    /**\r\n     * Utility functions to change overall state of application\r\n     * Settings, overall appearance, etc\r\n     */\r\n\r\n    changeVButtonColor(visualizing: boolean) {\r\n        this.setState({\r\n            visualizing: visualizing\r\n        })\r\n    }\r\n\r\n    toggleSettings() {\r\n        this.setState(prevState => ({\r\n            panelShow: !prevState.panelShow\r\n        }));\r\n    }\r\n\r\n    hideSettings() {\r\n        this.setState({\r\n            panelShow: false\r\n        });\r\n    }\r\n\r\n    doPathfinding() {\r\n        this.setState({\r\n            paused: false\r\n        });\r\n        this.visualizer.current!.doDelayedPathfinding();\r\n    }\r\n\r\n    pausePathfinding() {\r\n        this.setState({\r\n            paused: true\r\n        });\r\n        this.visualizer.current!.pausePathfinding();\r\n    }\r\n\r\n    resumePathfinding() {\r\n        this.setState({\r\n            paused: false\r\n        });\r\n        this.visualizer.current!.resumePathfinding();\r\n    }\r\n\r\n    clearPath() {\r\n        this.visualizer.current!.clearPath();\r\n        this.visualizer.current!.clearVisualizationChecked();\r\n    }\r\n\r\n    clearTiles() {\r\n        this.clearPath();\r\n        this.visualizer.current!.clearTilesChecked();\r\n    }\r\n\r\n    resetBoard() {\r\n        this.clearPath();\r\n        this.clearTiles();\r\n        this.visualizer.current!.resetPoints();\r\n    }\r\n\r\n    createMaze() {\r\n        this.visualizer.current!.createTerrain(MAZE, false);\r\n    }\r\n\r\n    createMazeVSkew() {\r\n        this.visualizer.current!.createTerrain(MAZE_VERTICAL_SKEW, false);\r\n    }\r\n\r\n    createMazeHSkew() {\r\n        this.visualizer.current!.createTerrain(MAZE_HORIZONTAL_SKEW, false);\r\n    }\r\n\r\n    createRandomTerrain() {\r\n        this.visualizer.current!.createTerrain(RANDOM_TERRAIN, true);\r\n    }\r\n\r\n    changeTile(cost: number) {\r\n        this.visualizer.current!.changeTile({\r\n            isSolid: cost === -1,\r\n            pathCost: cost\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Functions to modify app's settings\r\n     */\r\n\r\n    changeAlgo(algorithm: string) {\r\n        this.setState(prevState => ({\r\n            heuristicDisabled: !PathfinderBuilder.usesHeuristic(algorithm),\r\n            bidirectionalDisabled: !PathfinderBuilder.hasBidirectional(algorithm),\r\n            scoreDisabled: !PathfinderBuilder.usesWeights(algorithm),\r\n            arrowsDisabled: !PathfinderBuilder.usesBreadthTree(algorithm),\r\n            settings: {\r\n                ...prevState.settings,\r\n                algorithm: algorithm\r\n            }\r\n        }));\r\n    }\r\n\r\n    changeVisualize() {\r\n        this.setState(prevState => ({\r\n            settings: {\r\n                ...prevState.settings,\r\n                visualizeAlg: !prevState.settings.visualizeAlg\r\n            }\r\n        }));\r\n    }\r\n\r\n    changeShowArrows() {\r\n        this.setState(prevState => ({\r\n            settings: {\r\n                ...prevState.settings,\r\n                showArrows: !prevState.settings.showArrows\r\n            }\r\n        }));\r\n    }\r\n\r\n    changeShowScores() {\r\n        this.setState(prevState => ({\r\n            settings: {\r\n                ...prevState.settings,\r\n                showScores: !prevState.settings.showScores\r\n            }\r\n        }));\r\n    }\r\n\r\n    changeBidirectional() {\r\n        this.setState(prevState => ({\r\n            settings: {\r\n                ...prevState.settings,\r\n                bidirectional: !prevState.settings.bidirectional\r\n            }\r\n        }));\r\n    }\r\n\r\n    changeSpeed(value: number) {\r\n        this.setState(prevState => ({\r\n            settings: {\r\n                ...prevState.settings,\r\n                delayInc: value\r\n            }\r\n        }));\r\n    }\r\n\r\n    changeManhattan() {\r\n        this.setState(prevState => ({\r\n            settings: {\r\n                ...prevState.settings,\r\n                heuristicKey: 'manhattan'\r\n            }\r\n        }));\r\n    }\r\n\r\n    changeEuclidean() {\r\n        this.setState(prevState => ({\r\n            settings: {\r\n                ...prevState.settings,\r\n                heuristicKey: 'euclidean'\r\n            }\r\n        }));\r\n    }\r\n\r\n    changeChebyshev() {\r\n        this.setState(prevState => ({\r\n            settings: {\r\n                ...prevState.settings,\r\n                heuristicKey: 'chebyshev'\r\n            }\r\n        }));\r\n    }\r\n\r\n    changeOctile() {\r\n        this.setState(prevState => ({\r\n            settings: {\r\n                ...prevState.settings,\r\n                heuristicKey: 'octile'\r\n            }\r\n        }));\r\n    }\r\n\r\n    render() {\r\n        const title: string = 'Pathfinding Visualizer';\r\n        const icon = this.state.useIcon ?\r\n            <img\r\n                width={'100%'} height={'100%'}\r\n                className='icon'\r\n                alt={title} src={Icon}\r\n            /> :\r\n            title;\r\n        return (\r\n            <div>\r\n                <DraggablePanel\r\n                    title='Grid Settings'\r\n                    show={this.state.panelShow}\r\n                    onClickXButton={() => this.hideSettings()}\r\n                    width={350}\r\n                    height={425}\r\n                >\r\n                    <VisualSettings\r\n                        defaultViz={this.state.settings.visualizeAlg}\r\n                        defaultShowArrows={this.state.settings.showArrows}\r\n                        defaultShowScores={this.state.settings.showScores}\r\n                        disabledTree={this.state.arrowsDisabled}\r\n                        disabledScore={this.state.scoreDisabled}\r\n                        onChangeViz={() => this.changeVisualize()}\r\n                        onChangeShowArrows={() => this.changeShowArrows()}\r\n                        onChangeShowScores={() => this.changeShowScores()}\r\n                    />\r\n                    <SpeedSettings\r\n                        onChange={(value: number) => this.changeSpeed(value)}\r\n                        initialSpeed={this.state.settings.delayInc}\r\n                    />\r\n                    <AlgorithmSettings\r\n                        defaultAlg={this.state.settings.bidirectional}\r\n                        disabled={this.state.bidirectionalDisabled}\r\n                        onChangeBidirectional={() => this.changeBidirectional()}\r\n                    />\r\n                    <HeuristicSettings\r\n                        defaultHeuristic={this.state.settings.heuristicKey}\r\n                        disabled={this.state.heuristicDisabled}\r\n                        onClickManhattan={() => this.changeManhattan()}\r\n                        onClickEuclidean={() => this.changeEuclidean()}\r\n                        onClickChebyshev={() => this.changeChebyshev()}\r\n                        onClickOctile={() => this.changeOctile()}\r\n                    />\r\n                </DraggablePanel>\r\n                <TopBar>\r\n                    <a href='https://github.com/JosephPrichard/PathfinderReact' className='title'\r\n                       style={{\r\n                           width: this.state.useIcon ? 70 : 'auto',\r\n                           height: this.state.useIcon ? 52 : '100%'\r\n                       }}\r\n                    >\r\n                        {icon}\r\n                    </a>\r\n                    <div className='top-container'>\r\n                        <AlgorithmDropDown\r\n                            ref={this.algDropDown}\r\n                            onClick={() => this.onClickAlgDrop()}\r\n                            onChange={(alg: string) => this.changeAlgo(alg)}\r\n                        />\r\n                        <VisualizeButton\r\n                            active={this.state.visualizing}\r\n                            paused={this.state.paused}\r\n                            onPause={() => this.pausePathfinding()}\r\n                            onResume={() => this.resumePathfinding()}\r\n                            onStartStop={() => this.doPathfinding()}\r\n                        />\r\n                        <ClearDropDown\r\n                            ref={this.clrDropDown}\r\n                            onClick={() => this.onClickClrDrop()}\r\n                            onClickTiles={() => this.clearTiles()}\r\n                            onClickPath={() => this.clearPath()}\r\n                            onClickReset={() => this.resetBoard()}\r\n                        />\r\n                        <TilesDropDown\r\n                            ref={this.tilesDropDown}\r\n                            onClick={() => this.onClickTilesDrop()}\r\n                            onClickTileType={(cost: number) => this.changeTile(cost)}\r\n                        />\r\n                        <MazeDropDown\r\n                            ref={this.mazeDropDown}\r\n                            onClick={() => this.onClickMazeDrop()}\r\n                            onClickMaze={() => this.createMaze()}\r\n                            onClickMazeHorizontal={() => this.createMazeHSkew()}\r\n                            onClickMazeVertical={() => this.createMazeVSkew()}\r\n                            onClickRandomTerrain={() => this.createRandomTerrain()}\r\n                        />\r\n                        <SettingsButton onClick={() => this.toggleSettings()}/>\r\n                    </div>\r\n                </TopBar>\r\n                <PathfindingVisualizer\r\n                    ref={this.visualizer}\r\n                    onChangeVisualizing={(viz: boolean) => this.changeVButtonColor(viz)}\r\n                    settings={this.state.settings}\r\n                    tileWidth={this.tileWidth}/>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction isMobile() {\r\n    return /Android|webOS|iPhone|iPad|Mac|Macintosh|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\r\n}\r\n\r\nexport default PathfindingApp;","interface AppSettings\r\n{\r\n    visualizeAlg: boolean,\r\n    showArrows: boolean,\r\n    delayInc: number,\r\n    algorithm: string,\r\n    heuristicKey: string,\r\n    navigatorKey: string,\r\n    bidirectional: boolean,\r\n    showScores: boolean\r\n}\r\n\r\nexport function getDefaultSettings(): AppSettings {\r\n    return {\r\n        visualizeAlg: true,\r\n        showArrows: true,\r\n        delayInc: 25,\r\n        algorithm: 'a*',\r\n        heuristicKey: 'manhattan',\r\n        navigatorKey: 'plus',\r\n        bidirectional: false,\r\n        showScores: false\r\n    }\r\n}\r\n\r\nexport default AppSettings;","import React from 'react';\r\nimport './styles/Grid.css';\r\nimport './styles/Utility.css';\r\nimport './styles/Navbar.css';\r\nimport PathfindingApp from './common/components/PathfindingApp';\r\n\r\nclass App extends React.Component\r\n{\r\n    render() {\r\n        return (\r\n            <PathfindingApp/>\r\n        );\r\n    }\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n//import reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n    <React.StrictMode>\r\n        <App/>\r\n    </React.StrictMode>,\r\n    document.getElementById('root')\r\n);\r\n\r\n//reportWebVitals();\r\n"],"sourceRoot":""}
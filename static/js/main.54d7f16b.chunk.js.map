{"version":3,"sources":["view/navbar/TopBar.tsx","view/navbar/Buttons.tsx","view/navbar/DropDown.tsx","view/elements/DraggablePanel.tsx","view/grid/GridBackground.tsx","pathfinding/core/Components.ts","pathfinding/core/Grid.ts","view/grid/TileFg.tsx","view/grid/GridForeground.tsx","view/grid/StatsPanel.tsx","pathfinding/core/Navigator.ts","pathfinding/core/PlusNavigator.ts","pathfinding/algorithms/Heuristics.ts","pathfinding/core/AsteriskNavigator.ts","pathfinding/structures/Hash.ts","pathfinding/structures/Heap.ts","pathfinding/algorithms/Pathfinder.ts","pathfinding/algorithms/Node.ts","pathfinding/algorithms/AStar.ts","pathfinding/algorithms/BFS.ts","pathfinding/structures/Stack.ts","pathfinding/algorithms/DFS.ts","pathfinding/algorithms/BidirectionalAStar.ts","pathfinding/algorithms/BidirectionalBFS.ts","pathfinding/algorithms/PathfinderBuilder.ts","pathfinding/algorithms/MazeGenerator.ts","view/grid/PathfindingVisualizer.tsx","view/elements/Checkbox.tsx","view/elements/SteppedRangeSlider.tsx","view/elements/RadioButtonGroup.tsx","view/navbar/SettingPanels.tsx","view/SettingsManager.ts","view/PathfindingSettings.ts","view/PathfindingApp.tsx","App.tsx","index.tsx"],"names":["TopBar","bar","React","createRef","window","addEventListener","props","onChangeHeight","current","offsetHeight","this","ref","className","children","Component","VisualizeButton","onMouseDown","e","preventDefault","color","onClick","SettingsButton","AlgorithmDropDown","show","setState","up","display","hide","toggle","stopPropagation","isHidden","state","contentStyle","onChange","key","algText","arrowClass","fade","tabIndex","onKeyPress","nativeEvent","style","click","ClearDropDown","onClickPath","onClickTiles","MazeDropDown","onClickMaze","onClickMazeVertical","onClickMazeHorizontal","Clickable","DraggablePanel","draggable","draggableContainer","draggableContent","dragging","prevX","prevY","mouseDown","clientY","clientX","mouseUp","mouseMove","container","top","offsetTop","left","offsetLeft","content","innerHeight","innerWidth","offsetWidth","getPosition","renderDraggable","title","onClickXButton","document","EMPTY_NODE","ARROW_COLOR","GridBackground","visualization","arrows","width","height","renderKey","createTile","point","tileWidth","y","x","tile","createElement","String","backgroundColor","clear","createEmptyBg","forceUpdate","doGeneration","generation","visualizeGeneration","visualizeGenerations","generations","doArrowGeneration","childPoint","push","from","to","addArrowGeneration","addArrowGenerations","renderArrows","offset","i","length","arrow","first","second","firstX","firstY","secondX","secondY","offsetX","offsetY","x1","y1","x2","y2","stroke","strokeWidth","markerEnd","renderTiles","tiles","row","renderTile","tilesX","tilesY","xmlns","id","markerWidth","markerHeight","refX","refY","orient","fill","points","isSolid","pathCost","GridGraph","grid","mutateDefault","solid","mutate","undefined","nodes","data","createEmptyGrid","inBounds","get","console","str","log","JSON","stringify","TileFg","applyExpandAnimation","original","tileSize","setTimeout","applyShrinkAnimation","size","doAnimation","shapeRendering","ARROW_PATH_COLOR","pointsEqual","point1","point2","GridForeground","svg","mouseDown0","mouseDown2","draggingInitial","draggingGoal","disable","doTileAnimation","bounds","getBoundingRect","onPress","button","onDrag","touchStart","touch","touches","changedTouches","onTouch","touchMove","onEndingEvent","xCoordinate","yCoordinate","calculatePoint","initial","goal","drawTile","eraseTile","moveInitial","moveGoal","drawGrid","clearTiles","onTilesDragged","drawPath","path","slice","erasePath","Math","floor","renderPath","lines","renderPathArrow","index","renderEndTile","end","calcEndPointInView","round","topMargin","getBoundingClientRect","onContextMenu","onMouseUp","onMouseMove","onMouseLeave","onTouchStart","onTouchMoveCapture","onTouchEnd","onTouchCancel","StatsPanel","textLog","scrollTop","scrollHeight","clientHeight","time","toFixed","text","algorithm","readOnly","value","unselectable","onDrop","Navigator","a","b","PlusNavigator","getWidth","getHeight","euclidean","dx","abs","dy","sqrt","AsteriskNavigator","walkBottomRight","walkTopRight","walkBottomLeft","walkTopLeft","HashSet","map","HashTable","Heap","compare","elements","siftUp","val","peek","move","pop","siftDown","pos","parent","swap","right","child","reconstructPath","bottomLeaf","reconstructPathReversed","reverse","Pathfinder","navigator","recentSearch","node","onGeneration","Node","AStarNode","g","fScore","AStarPathfinder","func","heuristic","clearRecentSearch","getGrid","openSet","f","closedSet","root","add","isEmpty","currentNode","addRecent","currentPoint","equals","neighbors","neighbor","neighborPoint","neighborKey","stepCost","has","neighborNode","addChild","cost","BFSPathfinder","queue","visited","shift","next","Stack","DFSPathfinder","stack","BiAStarPathfinder","startOpenSet","startClosedSet","endOpenSet","endClosedSet","initialRoot","goalRoot","startCurrentNode","startCurrentPoint","startCurrentPointKey","concat","endCurrentNode","endCurrentPoint","endCurrentPointKey","BiBFSPathfinder","startVisited","endVisited","startQueue","endQueue","CREATE_NAVIGATOR","CREATE_HEURISTIC","manhattan","max","chebyshev","SQRT2","min","octile","CREATE_PATHFINDER","PathfinderBuilder","toLowerCase","Error","createHeuristic","createNavigator","createPathfinder","divideWidthNoSkew","divideWidthHSkew","divideWidthVSkew","getMidPoint","range","mid","getRand","random","MazeGenerator","slant","divideWidth","topLeft","bottomRight","draw","divide","chamber","widthOf","heightOf","randY","randX","toDraw","edgeBlocked","drawArr","leftChamber","rightChamber","topChamber","bottomChamber","mutateTile","calcLength","len","PathfindingVisualizer","background","foreground","stats","visualized","visualizing","visualTimeouts","doPathfinding","settings","pathfinder","getPathfinder","findPath","clearPath","reconstructSolution","showArrows","visualizeAlg","doDelayedPathfinding","clearVisualization","toggleDisable","clearTimeout","onChangeVisualizing","increment","delayInc","promises","delay","expandVisualization","promise","Promise","resolve","timeout","all","then","algorithmKey","bidirectional","hasBidirectional","makeBidirectional","setAlgorithm","setHeuristic","heuristicKey","setNavigator","navigatorKey","build","t0","performance","now","t2","getRecentNodes","getAlgorithmName","unshift","createMaze","prevGrid","generator","generateMaze","setPositions","xEnd","yEnd","xFloor","yFloor","yDecimal","ceil","endPoint","clearTilesChecked","clearVisualizationChecked","w","screen","availWidth","h","availHeight","Checkbox","prevState","checked","defaultChecked","type","disabled","boxStyle","defaultProps","SteppedRangeSlider","Number","currentTarget","default","list","step","sliderStyle","onInput","RadioButtonGroup","Children","toArray","radioButtons","VisualSettings","onChangeViz","onChangeShowArrows","SpeedSettings","onChangeSpeed","speedTexts","speedText","AlgorithmSettings","onChangeDiagonals","onChangeBidirectional","HeuristicSettings","enable","onClickManhattan","onClickEuclidean","onClickChebyshev","onClickOctile","SettingsManager","changeAlgo","algo","changeVisualize","changeShowArrows","changeBidirectional","changeDiagonals","changeSpeed","changeManhattan","changeEuclidean","changeChebyshev","changeOctile","PathfindingApp","algDropDown","clrDropDown","mazeDropDown","settingsManager","onClickAlgDrop","onClickClrDrop","onClickMazeDrop","changeVButtonColor","vButtonColor","toggleSettings","panelShow","hideSettings","heuristicDisabled","usesHeuristic","bidirectionalDisabled","arrowsDisabled","createMazeVSkew","createMazeHSkew","setLength","setTime","test","userAgent","href","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.54d7f16b.chunk.js","sourcesContent":["import React, {RefObject} from 'react';\r\n\r\ninterface IProps {\r\n    onChangeHeight: (height: number) => void\r\n}\r\n\r\nclass TopBar extends React.Component<IProps>\r\n{\r\n    private bar: RefObject<HTMLDivElement> = React.createRef();\r\n\r\n    componentDidMount() {\r\n        window.addEventListener('resize', () => this.props.onChangeHeight(this.bar.current!.offsetHeight));\r\n        this.props.onChangeHeight(this.bar.current!.offsetHeight);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div ref={this.bar} className='top-navbar navbar-expand-sm top-navbar'>\r\n                {this.props.children}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default TopBar;","import React from 'react';\r\n\r\ninterface VProps {\r\n    color: string\r\n    onClick: ()  => void\r\n}\r\n\r\ninterface SProps {\r\n    onClick: ()  => void\r\n}\r\n\r\nexport class VisualizeButton extends React.Component<VProps>\r\n{\r\n    render() {\r\n        return (\r\n            <button onMouseDown={e => e.preventDefault()}\r\n                    className={'button ' + this.props.color}\r\n                    onClick={this.props.onClick}\r\n            >\r\n                Visualize!\r\n            </button>\r\n        );\r\n    }\r\n}\r\n\r\nexport class SettingsButton extends React.Component<SProps>\r\n{\r\n    render() {\r\n        return (\r\n            <button onMouseDown={e => e.preventDefault()}\r\n                    className='button settings-button'\r\n                    onClick={this.props.onClick}>\r\n                Settings\r\n            </button>\r\n        );\r\n    }\r\n}\r\n","import React from 'react';\r\n\r\ninterface AlgProps {\r\n    onClick: () => void,\r\n    onChange: (alg: string) => void\r\n}\r\n\r\ninterface AlgState {\r\n    up: boolean,\r\n    display: string,\r\n    algText: string,\r\n    fade: string\r\n}\r\n\r\ninterface ClrProps {\r\n    onClick: () => void,\r\n    onClickPath: () => void,\r\n    onClickTiles: () => void\r\n}\r\n\r\ninterface DState {\r\n    up: boolean,\r\n    display: string,\r\n    fade: string\r\n}\r\n\r\ninterface MazeProps {\r\n    onClick: () => void,\r\n    onClickMaze: () => void,\r\n    onClickMazeHorizontal: () => void,\r\n    onClickMazeVertical: () => void\r\n}\r\n\r\nexport class AlgorithmDropDown extends React.Component<AlgProps, AlgState>\r\n{\r\n    constructor(props: AlgProps) {\r\n        super(props);\r\n        this.state = {\r\n            up: true,\r\n            display: 'none',\r\n            algText: 'A* Search',\r\n            fade: 'fade-in'\r\n        };\r\n    }\r\n\r\n    show = () => {\r\n        this.setState({\r\n            up: false,\r\n            display: 'block',\r\n        });\r\n    }\r\n\r\n    hide = () => {\r\n        this.setState({\r\n            display: 'none',\r\n            up: true,\r\n        });\r\n    }\r\n\r\n    toggle = (e: Event) => {\r\n        e.stopPropagation();\r\n        this.props.onClick();\r\n        if(this.isHidden()) {\r\n            this.show();\r\n        } else {\r\n            this.hide();\r\n        }\r\n    }\r\n\r\n    isHidden = () => {\r\n        return this.state.display === 'none';\r\n    }\r\n\r\n    contentStyle = () => {\r\n        return {\r\n            display: this.state.display\r\n        }\r\n    }\r\n\r\n    onChange = (key: string, algText: string) => {\r\n        this.props.onChange(key);\r\n        this.setState({\r\n            algText: algText\r\n        });\r\n    }\r\n\r\n    arrowClass = () => {\r\n        return this.state.up ? 'arrowUp' : 'arrowDown';\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div tabIndex={0} className='alg-drop-down drop-down'\r\n                 onMouseDown={e => e.preventDefault()}\r\n                 onKeyPress={(e) => this.toggle(e.nativeEvent)}\r\n                 onClick={(e) => this.toggle(e.nativeEvent)}\r\n            >\r\n                <div className='alg-drop-down-button drop-down-button'>\r\n                    <span className='alg-drop-down-text drop-down-text'>{this.state.algText}</span>\r\n                    <span className={'alg-arr ' + this.arrowClass()}/>\r\n                </div>\r\n                <div style={this.contentStyle()}\r\n                     className={this.state.fade + ' alg-drop-down-content drop-down-content'}\r\n                >\r\n                    <Clickable click={() => this.onChange('a*', 'A* Search')}>A* Search</Clickable>\r\n                    <Clickable click={() => this.onChange('dijkstra', 'Dijkstra')}>Dijkstra's Algorithm</Clickable>\r\n                    <Clickable click={() => this.onChange('best-first', 'Best First')}>Best First Search</Clickable>\r\n                    <Clickable click={() => this.onChange('bfs', 'Breadth First')}>Breadth First Search</Clickable>\r\n                    <Clickable click={() => this.onChange('dfs', 'Depth First')}>Depth First Search</Clickable>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class ClearDropDown extends React.Component<ClrProps, DState>\r\n{\r\n    constructor(props: ClrProps) {\r\n        super(props);\r\n        this.state = {\r\n            up: true,\r\n            display: 'none',\r\n            fade: 'fade-in'\r\n        };\r\n    }\r\n\r\n    show = () => {\r\n        this.setState({\r\n            up: false,\r\n            display: 'block',\r\n        });\r\n    }\r\n\r\n    hide = () => {\r\n        this.setState({\r\n            display: 'none',\r\n            up: true,\r\n        });\r\n    }\r\n\r\n    toggle = (e: Event) => {\r\n        e.stopPropagation();\r\n        this.props.onClick();\r\n        if(this.isHidden()) {\r\n            this.show();\r\n        } else {\r\n            this.hide();\r\n        }\r\n    }\r\n\r\n    isHidden = () => {\r\n        return this.state.display === 'none';\r\n    }\r\n\r\n    contentStyle = () => {\r\n        return {\r\n            display: this.state.display\r\n        }\r\n    }\r\n\r\n    arrowClass = () => {\r\n        return this.state.up ? 'arrowUpW' : 'arrowDownW';\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div tabIndex={0} className='clr-drop-down drop-down'\r\n                 onMouseDown={e => e.preventDefault()}\r\n                 onKeyPress={(e) => this.toggle(e.nativeEvent)}\r\n                 onClick={(e) => this.toggle(e.nativeEvent)}\r\n            >\r\n                <div className='clr-drop-down-button drop-down-button'>\r\n                    <span className='clr-drop-down-text drop-down-text'>Clear Grid</span>\r\n                    <span className={'clr-arr ' + this.arrowClass()}/>\r\n                </div>\r\n                <div style={this.contentStyle()}\r\n                     className={this.state.fade + ' clr-drop-down-content drop-down-content'}\r\n                >\r\n                    <Clickable click={this.props.onClickPath}>Clear Path</Clickable>\r\n                    <Clickable click={this.props.onClickTiles}>Clear Tiles</Clickable>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class MazeDropDown extends React.Component<MazeProps, DState>\r\n{\r\n    constructor(props: MazeProps) {\r\n        super(props);\r\n        this.state = {\r\n            up: true,\r\n            display: 'none',\r\n            fade: 'fade-in'\r\n        };\r\n    }\r\n\r\n    show = () => {\r\n        this.setState({\r\n            up: false,\r\n            display: 'block',\r\n        });\r\n    }\r\n\r\n    hide = () => {\r\n        this.setState({\r\n            display: 'none',\r\n            up: true,\r\n        });\r\n    }\r\n\r\n    toggle = (e: Event) => {\r\n        e.stopPropagation();\r\n        this.props.onClick();\r\n        if(this.isHidden()) {\r\n            this.show();\r\n        } else {\r\n            this.hide();\r\n        }\r\n    }\r\n\r\n    isHidden = () => {\r\n        return this.state.display === 'none';\r\n    }\r\n\r\n    contentStyle = () => {\r\n        return {\r\n            display: this.state.display\r\n        }\r\n    }\r\n\r\n    arrowClass = () => {\r\n        return this.state.up ? 'arrowUpW' : 'arrowDownW';\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div tabIndex={0} className='maze-drop-down drop-down'\r\n                 onMouseDown={e => e.preventDefault()}\r\n                 onKeyPress={(e) => this.toggle(e.nativeEvent)}\r\n                 onClick={(e) => this.toggle(e.nativeEvent)}\r\n            >\r\n                <div className='maze-drop-down-button drop-down-button'>\r\n                    <span className='maze-drop-down-text drop-down-text'>Mazes</span>\r\n                    <span className={'clr-arr ' + this.arrowClass()}/>\r\n                </div>\r\n                <div style={this.contentStyle()}\r\n                     className={this.state.fade + ' maze-drop-down-content drop-down-content'}\r\n                >\r\n                    <Clickable click={this.props.onClickMaze}>Recursive Maze Division</Clickable>\r\n                    <Clickable click={this.props.onClickMazeVertical}>Maze (vertical skew)</Clickable>\r\n                    <Clickable click={this.props.onClickMazeHorizontal}>Maze (horizontal skew)</Clickable>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\ninterface ClickableProps {\r\n    click: () => void;\r\n}\r\n\r\nclass Clickable extends React.Component<ClickableProps>\r\n{\r\n    render() {\r\n        return (\r\n            <div tabIndex={0} onKeyPress={this.props.click} onClick={this.props.click}>{this.props.children}</div>\r\n        )\r\n    }\r\n}","import React, {RefObject} from 'react';\r\n\r\ninterface IProps {\r\n    title: string,\r\n    show: boolean,\r\n    onClickXButton: () => void\r\n}\r\n\r\ninterface IState {\r\n    top: number,\r\n    left: number,\r\n}\r\n\r\nclass DraggablePanel extends React.Component<IProps, IState>\r\n{\r\n    //refs are used to access native DOM\r\n    private draggable: RefObject<HTMLDivElement> = React.createRef();\r\n    private draggableContainer: RefObject<HTMLDivElement> = React.createRef();\r\n    private draggableContent: RefObject<HTMLDivElement> = React.createRef();\r\n\r\n    //stores previous mouse location and drag\r\n    private dragging = false;\r\n    private prevX = 0;\r\n    private prevY = 0;\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.state = {\r\n            top: -1,\r\n            left: -1,\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        document.addEventListener('mouseup', e => {\r\n            this.mouseUp(e);\r\n        });\r\n        document.addEventListener('mousemove', e => {\r\n            this.mouseMove(e);\r\n        });\r\n        window.addEventListener('mouseleave', e => {\r\n            this.mouseUp(e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Start drag and init prev mouse location when mouse is clicked on draggable\r\n     * @param e\r\n     */\r\n    private mouseDown = (e: MouseEvent) => {\r\n        e.preventDefault();\r\n        this.prevY = e.clientY;\r\n        this.prevX = e.clientX;\r\n        this.dragging = true;\r\n    }\r\n\r\n    /**\r\n     * Called when mouse is risen on document stop drag\r\n     * @param e\r\n     */\r\n    private mouseUp = (e: MouseEvent) => {\r\n        e.preventDefault();\r\n        this.dragging = false;\r\n    }\r\n\r\n    /**\r\n     * Called when the mouse is moved over the document to calculate the new position of\r\n     * the draggable canvas\r\n     * @param e\r\n     */\r\n    private mouseMove = (e: MouseEvent) => {\r\n        if(this.dragging) {\r\n            const container = this.draggableContainer.current!;\r\n            let top = (container.offsetTop - (this.prevY - e.clientY))\r\n            let left = (container.offsetLeft - (this.prevX - e.clientX));\r\n            const content = this.draggableContent.current!;\r\n            const draggable = this.draggable.current!;\r\n            //stop drag if mouse goes out of bounds\r\n            if(e.clientY < 0 || e.clientY > window.innerHeight\r\n                    || e.clientX < 0 || e.clientX > window.innerWidth) {\r\n                this.dragging = false;\r\n            }\r\n            //check if position is out of bounds and prevent the panel from being dragged there\r\n            if(top < 0) {\r\n                top = 0;\r\n            } else if (top > window.innerHeight - draggable.offsetHeight) {\r\n                top = window.innerHeight - draggable.offsetHeight;\r\n            }\r\n            if(left < -content.offsetWidth/2) {\r\n                left = -content.offsetWidth/2;\r\n            } else if(left > window.innerWidth - content.offsetWidth/2) {\r\n                left = window.innerWidth - content.offsetWidth/2;\r\n            }\r\n            //set new position\r\n            this.setState({\r\n                top: top\r\n            });\r\n            this.setState({\r\n                left: left\r\n            });\r\n            //update previous pos\r\n            this.prevY = e.clientY;\r\n            this.prevX = e.clientX;\r\n        }\r\n    }\r\n\r\n    getPosition = () => {\r\n        const left = this.state.left;\r\n        const top = this.state.top;\r\n        if(left === -1 || top === -1) {\r\n            return {};\r\n        }\r\n        return {\r\n            left: left + 'px',\r\n            top: top + 'px',\r\n        };\r\n    }\r\n\r\n    contentStyle = () => {\r\n        return {\r\n            display: this.props.show ? 'block' : 'none'\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div ref={this.draggableContainer} className='draggable-container' style={this.getPosition()}>\r\n                {this.renderDraggable()}\r\n                <div ref={this.draggableContent} style={this.contentStyle()} className='draggable-content'>\r\n                    <div className='settings-general'>\r\n                        {this.props.children}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    private renderDraggable = () => {\r\n        return (\r\n            <div style={this.contentStyle()} className='draggable'\r\n                 ref={this.draggable}\r\n                 onMouseDown={e => this.mouseDown(e.nativeEvent)}\r\n            >\r\n                <div className='draggable-title'>{this.props.title}</div>\r\n                <div className='x-button' onClick={this.props.onClickXButton}>X</div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default DraggablePanel;","import React from 'react';\r\nimport {Node} from '../../pathfinding/algorithms/Node';\r\nimport {Point} from '../../pathfinding/core/Components';\r\n\r\ninterface IProps {\r\n    tileWidth: number,\r\n    tilesX: number,\r\n    tilesY: number\r\n}\r\n\r\nconst CLOSED_NODE = 'rgb(198, 237, 238)';\r\nconst OPEN_NODE = 'rgb(191, 248, 159)';\r\nconst EMPTY_NODE = 'white';\r\nconst ARROW_COLOR = 'rgb(153,153,153)';\r\n\r\nclass GridBackground extends React.Component<IProps>\r\n{\r\n    /**\r\n     * Represents the state of the component\r\n     * Stored outside of State to prevent copies, allowing\r\n     * updates with forceUpdate to improve App performance\r\n     */\r\n    private visualization: string[][];\r\n    private arrows: {to: Point, from: Point}[];\r\n\r\n    private readonly width: number;\r\n    private readonly height: number;\r\n\r\n    private renderKey: number = 0;\r\n\r\n    /**\r\n     * Constructs a GridBackground with immutable height and width\r\n     * @param props\r\n     */\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.width = this.props.tilesX;\r\n        this.height = this.props.tilesY;\r\n        this.visualization = this.createEmptyBg();\r\n        this.arrows = []\r\n    }\r\n\r\n    /**\r\n     * Create a tile with native dom\r\n     * @param point\r\n     */\r\n    private createTile = (point: Point) => {\r\n        const width = this.props.tileWidth;\r\n        const top = point.y * this.props.tileWidth;\r\n        const left = point.x * this.props.tileWidth;\r\n        const tile = document.createElement('div');\r\n        tile.className = 'tile';\r\n        tile.style.width = width + 'px';\r\n        tile.style.height = width + 'px';\r\n        tile.style.top = String(top);\r\n        tile.style.left = String(left);\r\n        tile.style.backgroundColor = EMPTY_NODE;\r\n        return tile;\r\n    }\r\n\r\n    /**\r\n     * Create a new empty visualization canvas\r\n     */\r\n    createEmptyBg() {\r\n        const visualization = [];\r\n        for(let y = 0; y < this.height; y++) {\r\n            const row: string[] = [];\r\n            for(let x = 0; x < this.width; x++) {\r\n                row.push(EMPTY_NODE);\r\n            }\r\n            visualization.push(row);\r\n        }\r\n        return visualization;\r\n    }\r\n\r\n    /**\r\n     * Clear the visualization canvas and update UI\r\n     */\r\n    clear = () => {\r\n        this.visualization = this.createEmptyBg();\r\n        this.arrows = [];\r\n        this.forceUpdate();\r\n    }\r\n\r\n    /**\r\n     * Perform a generation on a visualization array\r\n     * @param generation\r\n     * @param visualization\r\n     */\r\n    private doGeneration = (generation: Node, visualization: string[][]) => {\r\n        //modify state directly to improve performance\r\n        for(const node of generation.children) {\r\n            const point = node.tile.point;\r\n            visualization[point.y][point.x] = OPEN_NODE;\r\n        }\r\n        const point = generation.tile.point;\r\n        visualization[point.y][point.x] = CLOSED_NODE;\r\n        return visualization;\r\n    }\r\n\r\n    /**\r\n     * Visualize generation and update UI\r\n     * @param generation\r\n     */\r\n    visualizeGeneration = (generation: Node) => {\r\n        this.doGeneration(generation, this.visualization);\r\n        this.forceUpdate();\r\n    }\r\n\r\n    /**\r\n     * Visualize generation array and update UI\r\n     * @param generations\r\n     */\r\n    visualizeGenerations = (generations: Node[]) => {\r\n        const visualization = this.createEmptyBg();\r\n        for(const generation of generations) {\r\n            this.doGeneration(generation, visualization);\r\n        }\r\n        this.visualization = visualization;\r\n        this.forceUpdate();\r\n    }\r\n\r\n    /**\r\n     * Perform an arrow generation on an arrows array\r\n     * @param generation\r\n     * @param arrows\r\n     */\r\n    private doArrowGeneration = (generation: Node, arrows: {to: Point, from: Point}[]) => {\r\n        //modify state directly to improve performance\r\n        const point = generation.tile.point;\r\n        for(const node of generation.children) {\r\n            const childPoint = node.tile.point;\r\n            arrows.push({\r\n                from: point,\r\n                to: childPoint,\r\n            });\r\n        }\r\n        return arrows;\r\n    }\r\n\r\n    /**\r\n     * Add arrow generation without updating UI\r\n     * @param generation\r\n     */\r\n    addArrowGeneration = (generation: Node) => {\r\n        this.doArrowGeneration(generation, this.arrows);\r\n    }\r\n\r\n    /**\r\n     * Add arrow generations without updating UI\r\n     * @param generations\r\n     */\r\n    addArrowGenerations = (generations: Node[]) => {\r\n        this.arrows = [];\r\n        for(const generation of generations) {\r\n            this.doArrowGeneration(generation, this.arrows)\r\n        }\r\n        this.forceUpdate();\r\n    }\r\n\r\n    render() {\r\n        this.renderKey++;\r\n        return (\r\n            <div>\r\n                <div className='bg'>\r\n                    {this.renderTiles()}\r\n                </div>\r\n                <svg xmlns='http://www.w3.org/2000/svg' className='grid'>\r\n                    <defs>\r\n                        <marker id='arrowhead' markerWidth='3' markerHeight='3'\r\n                                refX='0' refY='1.5' orient='auto'\r\n                                fill={ARROW_COLOR}\r\n                        >\r\n                            <polygon points='0 0, 3 1.5, 0 3'/>\r\n                        </marker>\r\n                    </defs>\r\n                    {this.renderArrows()}\r\n                </svg>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    private renderArrows = () => {\r\n        const width = this.props.tileWidth;\r\n        const offset = width/2;\r\n        const arrows: JSX.Element[] = [];\r\n        for(let i = 0; i < this.arrows.length; i++) {\r\n            //calculate arrow position and dimensions\r\n            const arrow = this.arrows[i];\r\n            const first = arrow.from;\r\n            const second = arrow.to;\r\n            const firstX = first.x * width;\r\n            const firstY = first.y * width;\r\n            const secondX = second.x * width;\r\n            const secondY = second.y * width;\r\n            const offsetX = (secondX - firstX)/4;\r\n            const offsetY = (secondY - firstY)/4;\r\n            //generate a key for arrow that unique within the arrows array and across all possible arrow arrays\r\n            const key = 'arrow ' + i + ',' + this.renderKey;\r\n            //create arrow\r\n            arrows.push(<line key={key}\r\n                              x1={firstX + offset + offsetX}\r\n                              y1={firstY + offset + offsetY}\r\n                              x2={secondX + offset - offsetX}\r\n                              y2={secondY + offset - offsetY}\r\n                              stroke={ARROW_COLOR} strokeWidth='2' className='line-arrow'\r\n                              markerEnd='url(#arrowhead)' />);\r\n        }\r\n        return arrows;\r\n    }\r\n\r\n    private renderTiles = () => {\r\n        const tiles: JSX.Element[][] = [];\r\n        for(let y = 0; y < this.height; y++) {\r\n            const row: JSX.Element[] = [];\r\n            for(let x = 0; x < this.width; x++) {\r\n                const point = {\r\n                    x: x, y: y\r\n                };\r\n                row.push(\r\n                    this.renderTile(point, this.visualization[point.y][point.x])\r\n                );\r\n            }\r\n            tiles.push(row);\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    private renderTile = (point: Point, color: string) => {\r\n        const width = this.props.tileWidth;\r\n        const top = point.y * this.props.tileWidth;\r\n        const left = point.x * this.props.tileWidth;\r\n        const style = {\r\n            backgroundColor: color,\r\n            width: width + 'px',\r\n            height: width + 'px',\r\n            top: top,\r\n            left: left\r\n        };\r\n        return (\r\n            <div key={point.x + ',' + point.y} style={style} className='tile'/>\r\n        );\r\n    }\r\n}\r\n\r\nexport default GridBackground;","/**\r\n * Represents a point in 2d space\r\n */\r\nexport interface Point\r\n{\r\n    readonly x: number;\r\n    readonly y: number;\r\n}\r\n\r\n/**\r\n * Represents the data inside a tile\r\n * Solid tiles cannot be passed while non solid ones can\r\n * pathCost stores how expensive it is to travel to the tile if it isn't solid\r\n */\r\nexport interface TileData\r\n{\r\n    readonly pathCost: number;\r\n    readonly isSolid: boolean;\r\n}\r\n\r\n/**\r\n * Represents a tile on the Grid\r\n */\r\nexport interface Tile\r\n{\r\n    data: TileData;\r\n    readonly point: Point;\r\n}\r\n\r\n/**\r\n * Simple function to create a solid tile with path cost of 1\r\n * @param isSolid\r\n */\r\nexport function createTile(isSolid: boolean) {\r\n    return {\r\n        pathCost: 1,\r\n        isSolid: isSolid\r\n    }\r\n}\r\n\r\n","import {createTile, Point, Tile, TileData} from './Components';\r\n\r\nexport interface Grid\r\n{\r\n    getWidth(): number;\r\n    getHeight(): number;\r\n    inBounds(point: Point): boolean;\r\n    get(point: Point): Tile;\r\n    isSolid(point: Point): boolean;\r\n    mutate(point: Point, data: TileData): void;\r\n    mutateTile(tile: Tile): void;\r\n    mutateDefault(point: Point, solid: boolean): void;\r\n    output(console: Console): void;\r\n    getJson(): string;\r\n    walkable(point: Point): boolean;\r\n    clone(): Grid;\r\n}\r\n\r\n/**\r\n * A square grid system that stores nodes in a matrix\r\n * Uses an x,y system where x corresponds to column of the matrix,\r\n * and y corresponds to the row of the matrix\r\n * TileData.ts should be treated like graph nodes\r\n */\r\nclass GridGraph implements Grid\r\n{\r\n    private readonly tiles: Tile[][];\r\n    private readonly width: number;\r\n    private readonly height: number;\r\n\r\n    /**\r\n     * Constructs a grid either with empty or predefined tiles\r\n     * @param width of the grid\r\n     * @param height of grid\r\n     * will perform a defensive copy to the grid\r\n     * @param grid, optional parameter to copy tiles from that grid to\r\n     * this grid\r\n     */\r\n    constructor(width: number, height: number, grid?: Grid) {\r\n        this.width = width;\r\n        this.height = height;\r\n        if(grid === undefined) {\r\n            this.tiles = createEmptyGrid(width, height);\r\n        } else {\r\n            this.tiles = [];\r\n            for(let y = 0; y < height; y++) {\r\n                const row: Tile[] = [];\r\n                for(let x = 0; x < width; x++) {\r\n                    const point = {\r\n                        x: x, y: y\r\n                    }\r\n                    const inBounds = grid.inBounds(point);\r\n                    row.push({\r\n                        data: {\r\n                            pathCost: inBounds ? grid.get(point).data.pathCost : 1,\r\n                            isSolid: inBounds ? grid.get(point).data.isSolid : false\r\n                        },\r\n                        point: {\r\n                            x: x, y: y\r\n                        }\r\n                    });\r\n                }\r\n               this.tiles.push(row);\r\n            }\r\n        }\r\n    }\r\n\r\n    getWidth() {\r\n        return this.width;\r\n    }\r\n\r\n    getHeight() {\r\n        return this.height;\r\n    }\r\n\r\n    /**\r\n     * Checks if a given point is in bounds\r\n     * Other functions assume arguments are in bounds, this should be used\r\n     * if there is reasonable doubt about whether a point is in bounds\r\n     * @param point, to check\r\n     */\r\n    inBounds(point: Point) {\r\n        return point.x >= 0 && point.x < this.width && point.y >= 0 && point.y < this.height;\r\n    }\r\n\r\n    /**\r\n     * Retrieves a defensive tile for a position\r\n     * Defensive copy prevents this object from being mutated without calling\r\n     * a mutate function\r\n     * @param point, point to get\r\n     */\r\n    get(point: Point) {\r\n        return {\r\n            point: this.tiles[point.y][point.x].point,\r\n            data: this.tiles[point.y][point.x].data\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Mutates a position's tile to solid or non solid\r\n     * @param point, point to mutate\r\n     * @param data to mutate to\r\n     */\r\n    mutate(point: Point, data: TileData) {\r\n        this.tiles[point.y][point.x].data = data;\r\n    }\r\n\r\n    /**\r\n     * Mutates a a tile by point\r\n     * @param tile to mutate\r\n     */\r\n    mutateTile(tile: Tile) {\r\n        this.tiles[tile.point.y][tile.point.x].data = tile.data;\r\n    }\r\n\r\n    /**\r\n     * Mutate tile at point\r\n     * @param point to mutate at\r\n     * @param solid to determine what default tile to create\r\n     */\r\n    mutateDefault = (point: Point, solid: boolean) => {\r\n        this.mutate(\r\n            point, createTile(solid)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Outputs the grid to a console\r\n     * @param console\r\n     */\r\n    output(console: Console) {\r\n        for(let y = 0; y < this.height; y++) {\r\n            let str = '';\r\n            for(let x = 0; x < this.width; x++) {\r\n                str += this.tiles[y][x].data.isSolid + ', ';\r\n            }\r\n            console.log(str);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns json of tiles\r\n     */\r\n    getJson() {\r\n        return JSON.stringify(this.tiles);\r\n    }\r\n\r\n    /**\r\n     * Determines if a tile can be walked on\r\n     * @param point\r\n     */\r\n    walkable(point: Point) {\r\n        return !this.get(point).data.isSolid;\r\n    }\r\n\r\n    isSolid(point: Point): boolean {\r\n        return this.get(point).data.isSolid;\r\n    }\r\n\r\n    clone(): Grid {\r\n        return new GridGraph(this.width, this.height, this);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a 2d matrix of empty nodes\r\n */\r\nfunction createEmptyGrid(width: number, height: number) {\r\n    const nodes: Tile[][] = [];\r\n    for(let y = 0; y < height; y++) {\r\n        const row: Tile[] = [];\r\n        for(let x = 0; x < width; x++) {\r\n            row.push({\r\n                point: {\r\n                    x: x, y: y\r\n                },\r\n                data: createTile(false)\r\n            });\r\n        }\r\n        nodes.push(row);\r\n    }\r\n    return nodes;\r\n}\r\n\r\nexport default GridGraph;","import React from 'react';\r\nimport {Point} from '../../pathfinding/core/Components';\r\n\r\ninterface IProps {\r\n    tileWidth: number,\r\n    point: Point,\r\n    color: string,\r\n    doAnimation: boolean\r\n}\r\n\r\ninterface IState {\r\n    tileSize: number\r\n}\r\n\r\nclass TileFg extends React.Component<IProps, IState>\r\n{\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        const size = this.props.doAnimation ?  0 : this.props.tileWidth;\r\n        this.state = {\r\n            tileSize: size,\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n        if(this.props.doAnimation) {\r\n            this.applyExpandAnimation();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Animation to expand element from half size to full size over a few milliseconds\r\n     * Can be slow to execute so animations should be enabled with caution\r\n     */\r\n    applyExpandAnimation = () => {\r\n        const total = 5\r\n        const original = this.state.tileSize;\r\n        for(let i = 1; i <= total; i++) {\r\n            const expand = () => this.setState({\r\n                tileSize: original + i * (this.props.tileWidth/(total))\r\n            });\r\n            setTimeout(expand, i*10);\r\n        }\r\n    }\r\n\r\n    applyShrinkAnimation = () => {\r\n        const total = 5\r\n        const original = this.state.tileSize;\r\n        for(let i = 1; i <= total; i++) {\r\n            const expand = () => this.setState({\r\n                tileSize: original - i * (this.props.tileWidth/(total))\r\n            });\r\n            setTimeout(expand, i*10);\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const width = this.state.tileSize;\r\n        const top = this.props.point.y * this.props.tileWidth + (this.props.tileWidth - width)/2;\r\n        const left = this.props.point.x * this.props.tileWidth + (this.props.tileWidth - width)/2;\r\n        const style = {\r\n            fill: this.props.color,\r\n            stroke: 'none',\r\n            display: 'block'\r\n        };\r\n        return (\r\n            <rect x={left} y={top}\r\n                  shapeRendering='crispEdges'\r\n                  width={width} height={width}\r\n                  style={style} className={'tile svg-tile'}\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nexport default TileFg;","import React, {RefObject} from 'react';\r\nimport {Point, Tile} from '../../pathfinding/core/Components';\r\nimport GridGraph, {Grid} from '../../pathfinding/core/Grid';\r\nimport TileFg from './TileFg';\r\n\r\ninterface IProps {\r\n    tileWidth: number,\r\n    tilesX: number,\r\n    tilesY: number,\r\n    onTilesDragged: () => void,\r\n    topMargin: number,\r\n}\r\n\r\ninterface IState {\r\n    grid: Grid,\r\n    initial: Point,\r\n    goal: Point,\r\n    path: Tile[]\r\n}\r\n\r\nconst SOLID_COLOR = 'rgb(45, 48, 54)';\r\nconst INITIAL_COLOR = 'rgb(131, 217, 52)';\r\nconst GOAL_COLOR = 'rgb(203, 75, 14)';\r\nconst ARROW_PATH_COLOR = 'rgb(73, 79, 250)';\r\n\r\nclass GridForeground extends React.Component<IProps,IState>\r\n{\r\n    private svg: RefObject<SVGSVGElement> = React.createRef();\r\n\r\n    private mouseDown0: boolean = false;\r\n    private mouseDown2: boolean = false;\r\n    private draggingInitial: boolean = false;\r\n    private draggingGoal: boolean = false;\r\n    private disable: boolean = false;\r\n\r\n    private doTileAnimation: boolean = true;\r\n\r\n    private readonly width: number;\r\n    private readonly height: number;\r\n\r\n    /**\r\n     * Constructs a GridForeground with immutable height and width\r\n     * @param props\r\n     */\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.width = this.props.tilesX;\r\n        this.height = this.props.tilesY;\r\n        const end = this.calcEndPointInView();\r\n        this.state = {\r\n            grid: new GridGraph(this.width, this.height),\r\n            path: [],\r\n            initial: {\r\n                x: ((end.x)/3) >> 0,\r\n                y: ((end.y)/3) >> 0\r\n            },\r\n            goal: {\r\n                x: ((2*(end.x)/3) >> 0) - 1,\r\n                y: ((2*(end.y)/3) >> 0) - 1\r\n            }\r\n        }\r\n    }\r\n\r\n    calcEndPointInView() {\r\n        const xEnd = Math.round(window.innerWidth / this.props.tileWidth);\r\n        const yEnd = Math.round((window.innerHeight - this.props.topMargin - 30) / this.props.tileWidth);\r\n        return {\r\n            x: xEnd, y: yEnd\r\n        }\r\n    }\r\n\r\n    toggleDisable() {\r\n        this.disable = !this.disable;\r\n    }\r\n\r\n    getBoundingRect() {\r\n        return this.svg.current!.getBoundingClientRect();\r\n    }\r\n\r\n    private mouseDown = (e: MouseEvent) => {\r\n        e.preventDefault();\r\n        const bounds = this.getBoundingRect();\r\n        this.onPress(e.clientX - bounds.left, e.clientY - bounds.top, e.button);\r\n    }\r\n\r\n    private mouseUp = (e: MouseEvent) => {\r\n        e.preventDefault();\r\n        if(e.button === 0) {\r\n            this.draggingGoal = false;\r\n            this.draggingInitial = false;\r\n            this.mouseDown0 = false;\r\n        } else if(e.button === 2) {\r\n            this.mouseDown2 = false;\r\n        }\r\n    }\r\n\r\n    private mouseMove = (e: MouseEvent) => {\r\n        const bounds = this.getBoundingRect();\r\n        this.onDrag(e.clientX - bounds.left, e.clientY - bounds.top);\r\n    }\r\n\r\n    private touchStart = (e: TouchEvent) => {\r\n        const touch = e.touches[0] || e.changedTouches[0];\r\n        const bounds = this.getBoundingRect();\r\n        this.onTouch(touch.clientX - bounds.left, touch.clientY - bounds.top);\r\n    }\r\n\r\n    private touchMove = (e: TouchEvent) => {\r\n        const touch = e.touches[0] || e.changedTouches[0];\r\n        const bounds = this.getBoundingRect();\r\n        this.onDrag(touch.clientX - bounds.left, touch.clientY - bounds.top);\r\n    }\r\n\r\n    private onEndingEvent = (e: Event) => {\r\n        e.preventDefault();\r\n        this.draggingGoal = false;\r\n        this.draggingInitial = false;\r\n        this.mouseDown0 = false;\r\n        this.mouseDown2 = false;\r\n    }\r\n\r\n    /**\r\n     * Responds to the event thrown at screen coordinates on press\r\n     * @param xCoordinate\r\n     * @param yCoordinate\r\n     * @param button\r\n     */\r\n    private onPress = (xCoordinate: number, yCoordinate: number, button: number) => {\r\n        const point = this.calculatePoint(xCoordinate,yCoordinate);\r\n        if(button === 0) {\r\n            this.mouseDown0 = true;\r\n            if(pointsEqual(point, this.state.initial)) {\r\n                this.draggingInitial = true;\r\n            } else if(pointsEqual(point, this.state.goal)) {\r\n                this.draggingGoal = true;\r\n            } else if(!this.disable) {\r\n                this.drawTile(point);\r\n            }\r\n        } else if(button === 2) {\r\n            this.mouseDown2 = true;\r\n            if(!pointsEqual(point,this.state.initial) && !pointsEqual(point, this.state.goal) && !this.disable) {\r\n                this.eraseTile(point);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Responds to the event thrown at screen coordinates on touch\r\n     * @param xCoordinate\r\n     * @param yCoordinate\r\n     */\r\n    private onTouch = (xCoordinate: number, yCoordinate: number) => {\r\n        const point = this.calculatePoint(xCoordinate,yCoordinate);\r\n        if(pointsEqual(point, this.state.initial)) {\r\n            this.mouseDown0 = true;\r\n            this.draggingInitial = true;\r\n        } else if(pointsEqual(point, this.state.goal)) {\r\n            this.mouseDown0 = true;\r\n            this.draggingGoal = true;\r\n        } else if(!this.state.grid.isSolid(point)) {\r\n            this.mouseDown0 = true;\r\n            if(!this.disable) {\r\n                this.drawTile(point);\r\n            }\r\n        } else {\r\n            this.mouseDown2 = true;\r\n            if(!pointsEqual(point, this.state.initial) && !pointsEqual(point, this.state.goal) && !this.disable) {\r\n                this.eraseTile(point);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Responds to the event thrown at screen coordinates on drag/move\r\n     * @param xCoordinate\r\n     * @param yCoordinate\r\n     */\r\n    private onDrag = (xCoordinate: number, yCoordinate: number) => {\r\n        const point = this.calculatePoint(xCoordinate,yCoordinate);\r\n        if(this.mouseDown0) {\r\n            if(this.draggingInitial) {\r\n                this.moveInitial(point);\r\n            } else if(this.draggingGoal) {\r\n                this.moveGoal(point);\r\n            } else if(!pointsEqual(point,this.state.initial) && !pointsEqual(point, this.state.goal) && !this.disable) {\r\n                this.drawTile(point);\r\n            }\r\n        } else if(this.mouseDown2) {\r\n            if(!pointsEqual(point, this.state.initial) && !pointsEqual(point, this.state.goal) && !this.disable) {\r\n                this.eraseTile(point);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw an entire new grid on the foreground with disabled animations\r\n     * @param grid\r\n     */\r\n    drawGrid = (grid: Grid) => {\r\n        this.doTileAnimation = false;\r\n        this.setState({\r\n            grid: grid\r\n        }, () => this.doTileAnimation = true)\r\n    }\r\n\r\n    /**\r\n     * Draw tile at point\r\n     * @param point\r\n     */\r\n    drawTile = (point: Point) => {\r\n        const grid = this.state.grid;\r\n        if(grid.inBounds(point)) {\r\n            grid.mutateDefault(point, true);\r\n        }\r\n        this.forceUpdate();\r\n    }\r\n\r\n    /**\r\n     * Checks if a node is visualized, then changes the tile to empty if it isn't\r\n     * @param point\r\n     */\r\n    eraseTile = (point: Point) => {\r\n        const grid = this.state.grid;\r\n        if(grid.inBounds(point)) {\r\n            grid.mutateDefault(point, false);\r\n        }\r\n        this.forceUpdate();\r\n    }\r\n\r\n    /**\r\n     * Clear grid in state\r\n     */\r\n    clearTiles = () => {\r\n        const grid = this.state.grid;\r\n        for(let y = 0; y < this.height; y++) {\r\n            for(let x = 0; x < this.width; x++) {\r\n                const point = {\r\n                    x: x, y: y\r\n                }\r\n                grid.mutateDefault(point, false);\r\n            }\r\n        }\r\n        this.forceUpdate();\r\n    }\r\n\r\n    /**\r\n     * Moves initial to a new point\r\n     * @param point\r\n     */\r\n    moveInitial = (point: Point) => {\r\n        if(this.state.grid.inBounds(point)\r\n            && !this.state.grid.isSolid(point)\r\n            && !pointsEqual(this.state.goal, point)\r\n            && !pointsEqual(this.state.initial, point)\r\n            && !this.disable)\r\n        {\r\n            this.setState({\r\n                initial: point\r\n            }, () => this.props.onTilesDragged());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves goal to a new point\r\n     * @param point\r\n     */\r\n    moveGoal = (point: Point) => {\r\n        if(this.state.grid.inBounds(point)\r\n            && !this.state.grid.isSolid(point)\r\n            && !pointsEqual(this.state.initial, point)\r\n            && !pointsEqual(this.state.goal, point)\r\n            && !this.disable)\r\n        {\r\n            this.setState({\r\n                goal: point\r\n            }, () => this.props.onTilesDragged());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw a path onto the grid\r\n     * @param path\r\n     */\r\n    drawPath = (path: Tile[]) => {\r\n        this.setState({\r\n            path: path.slice()\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Erase path from the grid\r\n     */\r\n    erasePath = () => {\r\n        this.setState({\r\n            path: []\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts real screen x,y coordinates into\r\n     * a 2d point position on the grid\r\n     * @param xCoordinate\r\n     * @param yCoordinate\r\n     */\r\n    calculatePoint = (xCoordinate: number, yCoordinate: number) => {\r\n        return {\r\n            x: Math.floor(xCoordinate/this.props.tileWidth),\r\n            y: Math.floor(yCoordinate/this.props.tileWidth)\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <svg ref={this.svg} xmlns='http://www.w3.org/2000/svg' className='grid'\r\n                 onContextMenu={e => e.preventDefault()}\r\n                 onMouseDown={e => this.mouseDown(e.nativeEvent)}\r\n                 onMouseUp={e => this.mouseUp(e.nativeEvent)}\r\n                 onMouseMove={e => this.mouseMove(e.nativeEvent)}\r\n                 onMouseLeave={e => this.onEndingEvent(e.nativeEvent)}\r\n                 onTouchStart={e => this.touchStart(e.nativeEvent)}\r\n                 onTouchMoveCapture={e => this.touchMove(e.nativeEvent)}\r\n                 onTouchEnd={e => this.onEndingEvent(e.nativeEvent)}\r\n                 onTouchCancel={e => this.onEndingEvent(e.nativeEvent)}\r\n            >\r\n                <defs>\r\n                    <marker id='arrowhead-path' markerWidth='3' markerHeight='3'\r\n                            refX='0' refY='1.5' orient='auto'\r\n                            fill={ARROW_PATH_COLOR}\r\n                    >\r\n                        <polygon points='0 0, 3 1.5, 0 3'/>\r\n                    </marker>\r\n                </defs>\r\n                {this.renderEndTile(this.state.initial, INITIAL_COLOR,'initial')}\r\n                {this.renderEndTile(this.state.goal, GOAL_COLOR,'goal')}\r\n                {this.renderPath()}\r\n                {this.renderTiles()}\r\n            </svg>\r\n        );\r\n    }\r\n\r\n    private renderPath = () => {\r\n        const lines: JSX.Element[] = [];\r\n        for(let i = 0; i < this.state.path.length-1; i++) {\r\n            const first = this.state.path[i].point;\r\n            const second = this.state.path[i+1].point;\r\n            lines.push(this.renderPathArrow(i, first, second));\r\n        }\r\n        return lines;\r\n    }\r\n\r\n    private renderPathArrow = (index: number, first: Point, second: Point) => {\r\n        const width = this.props.tileWidth;\r\n        const offset = width/2;\r\n        const firstX = first.x * width;\r\n        const firstY = first.y * width;\r\n        const secondX = second.x * width;\r\n        const secondY = second.y * width;\r\n        const offsetX = (secondX - firstX)/4;\r\n        const offsetY = (secondY - firstY)/4;\r\n        return (\r\n            <line key={'path ' + index}\r\n                  x1={firstX + offset + offsetX}\r\n                  y1={firstY + offset + offsetY}\r\n                  x2={secondX + offset - offsetX}\r\n                  y2={secondY + offset - offsetY}\r\n                  stroke={ARROW_PATH_COLOR} strokeWidth='2' className='line-path-arrow'\r\n                  markerEnd='url(#arrowhead-path)' />\r\n        );\r\n    }\r\n\r\n    private renderTiles = () => {\r\n        const tiles: JSX.Element[] = [];\r\n        for(let y = 0; y < this.height; y++) {\r\n            for(let x = 0; x < this.width; x++) {\r\n                const point = {\r\n                    x: x, y: y\r\n                }\r\n                if(this.state.grid.isSolid(point)) {\r\n                    tiles.push(\r\n                        <TileFg key={point.x + ',' + point.y} point={point}\r\n                                doAnimation={this.doTileAnimation}\r\n                                tileWidth={this.props.tileWidth}\r\n                                color={SOLID_COLOR}\r\n                        />\r\n                    );\r\n                }\r\n            }\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    private renderEndTile = (point: Point, color: string, key: string) => {\r\n        return <TileFg key={key} point={point} doAnimation={false}\r\n                       tileWidth={this.props.tileWidth}\r\n                       color={color}/>\r\n    }\r\n}\r\n\r\nfunction pointsEqual(point1: Point, point2: Point) {\r\n    return point1.x === point2.x && point1.y === point2.y;\r\n}\r\n\r\nexport default GridForeground;","import React, {RefObject} from 'react';\r\n\r\ninterface IProps {\r\n    algorithm: string,\r\n    length: number,\r\n    time: number,\r\n    nodes: number,\r\n}\r\n\r\nclass StatsPanel extends React.Component<IProps>\r\n{\r\n    private readonly textLog: RefObject<HTMLTextAreaElement> = React.createRef();\r\n\r\n    componentDidUpdate() {\r\n        this.textLog.current!.scrollTop = this.textLog.current!.scrollHeight;\r\n    }\r\n\r\n    getHeight() {\r\n        return this.textLog.current!.clientHeight;\r\n    }\r\n\r\n    render() {\r\n        const time = precise(this.props.time);\r\n        const text = this.props.algorithm === '' ? '' :\r\n            this.props.algorithm + ' visited ' + this.props.nodes + ' nodes in ' +\r\n            time + ' ms. Path length = ' + this.props.length + '. ';\r\n        return(\r\n            <div>\r\n                <textarea tabIndex={-1} ref={this.textLog} readOnly={true}\r\n                          className='stats-text-area no-select'\r\n                          value={text} unselectable={'on'} onDrop={() => false}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction precise(x: number) {\r\n    return x.toFixed(2);\r\n}\r\n\r\nexport default StatsPanel;","import {Grid} from './Grid';\r\nimport {Point, Tile} from './Components';\r\n\r\nexport const UNIT = 1; //number of tiles we can move at once\r\n\r\n/**\r\n * Describes an abstract navigator for a grid\r\n * Provides graph-like traversal for the grid\r\n * Determines where we can travel to from a certain point,\r\n * whether we have reached a destination, and the cost to\r\n * travel to a certain point\r\n */\r\nabstract class Navigator\r\n{\r\n    protected readonly grid: Grid;\r\n\r\n    constructor(grid: Grid) {\r\n        this.grid = grid;\r\n    }\r\n\r\n    getGrid() {\r\n        return this.grid;\r\n    }\r\n\r\n    /**\r\n     * Goal check function: Checks if two points are equal\r\n     * @param a\r\n     * @param b\r\n     */\r\n    equals(a: Point, b: Point) {\r\n        return a.x === b.x && a.y === b.y;\r\n    }\r\n\r\n    /**\r\n     * Step cost function from a to b\r\n     * @param a\r\n     * @param b to point to travel to\r\n     */\r\n    abstract cost(a: Point, b: Point): number;\r\n\r\n    /**\r\n     * Neighbors function: Gets the available neighbors for a point in a grid we can make\r\n     * in a given move\r\n     * @param point\r\n     */\r\n    abstract neighbors(point: Point): Tile[];\r\n}\r\n\r\nexport default Navigator;","import {Point, Tile} from './Components';\r\nimport Navigator, {UNIT} from './Navigator';\r\n\r\n/**\r\n * Concretion of a Plus Navigator for a grid\r\n * Allows movement akin to a 'plus' symbol\r\n */\r\nclass PlusNavigator extends Navigator\r\n{\r\n    /**\r\n     * Adds the neighbors of a point to the left, right, top and down\r\n     * @param point\r\n     */\r\n    neighbors(point: Point): Tile[] {\r\n        const tiles: Tile[] = [];\r\n        if(point.x + UNIT < this.grid.getWidth()) {\r\n            const tile = this.grid.get({\r\n                x: point.x + UNIT,\r\n                y: point.y\r\n            })\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.y + UNIT < this.grid.getHeight()) {\r\n            const tile = this.grid.get({\r\n                x: point.x,\r\n                y: point.y + UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.x - UNIT >= 0) {\r\n            const tile = this.grid.get({\r\n                x: point.x - UNIT,\r\n                y: point.y\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.y - UNIT >= 0) {\r\n            const tile = this.grid.get({\r\n                x: point.x,\r\n                y: point.y - UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    /**\r\n     * Step cost function that works by getting the pathCost stored in the grid\r\n     * from one point a to b\r\n     * @param a\r\n     * @param b to point to travel to\r\n     */\r\n    cost(a: Point, b: Point) {\r\n        return this.grid.get(b).data.pathCost;\r\n    }\r\n}\r\n\r\nexport default PlusNavigator;","import {Point} from '../core/Components';\r\n\r\nexport type HeuristicFunc = (a: Point, b: Point) => number;\r\n\r\nexport function manhattan(a: Point, b: Point): number {\r\n    const dx = Math.abs(a.x - b.x) ;\r\n    const dy = Math.abs(a.y - b.y);\r\n    return dx + dy;\r\n}\r\n\r\nexport function euclidean(a: Point, b: Point): number {\r\n    const dx = Math.abs(a.x - b.x);\r\n    const dy = Math.abs(a.y - b.y);\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\r\n\r\nexport function octile(a: Point, b: Point): number {\r\n    const dx = Math.abs(a.x - b.x);\r\n    const dy = Math.abs(a.y - b.y);\r\n    return Math.SQRT2 * Math.min(dx, dy) + Math.abs(dx - dy);\r\n}\r\n\r\nexport function chebyshev(a: Point, b: Point): number {\r\n    const dx = Math.abs(a.x - b.x);\r\n    const dy = Math.abs(a.y - b.y);\r\n    return Math.max(dx, dy);\r\n}\r\n\r\nexport function nullHeuristic(a: Point, b: Point): number {\r\n    return 0;\r\n}","import {Point, Tile} from './Components';\r\nimport Navigator, {UNIT} from './Navigator';\r\nimport {euclidean} from '../algorithms/Heuristics';\r\n\r\n/**\r\n * Concretion of a Plus Navigator for a grid\r\n * Allows movement akin to a 'asterisk' symbol\r\n */\r\nclass AsteriskNavigator extends Navigator\r\n{\r\n    /**\r\n     * Adds the neighbors of a point to the left, right, top and down\r\n     * @param point\r\n     */\r\n    neighbors(point: Point): Tile[] {\r\n        //keep track of double squares that block diagonals\r\n        let walkBottomRight = false;\r\n        let walkTopRight = false;\r\n        let walkBottomLeft = false;\r\n        let walkTopLeft = false;\r\n        //plus\r\n        const tiles: Tile[] = [];\r\n        if(point.x + UNIT < this.grid.getWidth()) {\r\n            const tile = this.grid.get({\r\n                x: point.x + UNIT,\r\n                y: point.y\r\n            })\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n                walkBottomRight = true;\r\n                walkTopRight = true;\r\n            }\r\n        }\r\n        if(point.y + UNIT < this.grid.getHeight()) {\r\n            const tile = this.grid.get({\r\n                x: point.x,\r\n                y: point.y + UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n                walkBottomRight = true;\r\n                walkBottomLeft = true;\r\n            }\r\n        }\r\n        if(point.x - UNIT >= 0) {\r\n            const tile = this.grid.get({\r\n                x: point.x - UNIT,\r\n                y: point.y\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n                walkBottomLeft = true;\r\n                walkTopLeft = true;\r\n            }\r\n        }\r\n        if(point.y - UNIT >= 0) {\r\n            const tile = this.grid.get({\r\n                x: point.x,\r\n                y: point.y - UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n                walkTopRight = true;\r\n                walkTopLeft = true;\r\n            }\r\n        }\r\n        //diagonals\r\n        if(point.x + UNIT < this.grid.getWidth() &&\r\n            point.y + UNIT < this.grid.getHeight() &&\r\n            walkBottomRight) {\r\n            const tile = this.grid.get({\r\n                x: point.x + UNIT,\r\n                y: point.y + UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.x - UNIT >= 0 &&\r\n            point.y + UNIT < this.grid.getHeight() &&\r\n            walkBottomLeft) {\r\n            const tile = this.grid.get({\r\n                x: point.x - UNIT,\r\n                y: point.y + UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.x + UNIT < this.grid.getWidth() &&\r\n            point.y - UNIT >= 0 &&\r\n            walkTopRight) {\r\n            const tile =  this.grid.get({\r\n                x: point.x + UNIT,\r\n                y: point.y - UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.x - UNIT >= 0 &&\r\n            point.y - UNIT >= 0 &&\r\n            walkTopLeft) {\r\n            const tile =  this.grid.get({\r\n                x: point.x - UNIT,\r\n                y: point.y - UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    /**\r\n     * Step cost function that works by getting the pathCost stored in the grid\r\n     * from one point a to b\r\n     * Returns the exact distance multiplied by the cost to travel there\r\n     * @param a\r\n     * @param b to point to travel to\r\n     */\r\n    cost(a: Point, b: Point) {\r\n        return euclidean(a,b) * this.grid.get(b).data.pathCost;\r\n    }\r\n\r\n}\r\n\r\nexport default AsteriskNavigator;","import {Point} from '../core/Components';\r\n\r\n/**\r\n * A simple data structure that keeps track of whether keys have been added to it\r\n */\r\nexport class HashSet\r\n{\r\n    private map: {[key: string]: boolean} = {};\r\n\r\n    add(key: string) {\r\n        this.map[key] = true;\r\n    }\r\n\r\n    remove(key: string) {\r\n        this.map[key] = false;\r\n    }\r\n\r\n    has(key: string) {\r\n        return this.map[key];\r\n    }\r\n\r\n    clear() {\r\n        this.map = {};\r\n    }\r\n}\r\n\r\n/**\r\n * A simple data structure that stores a type at a key\r\n */\r\nexport class HashTable<Value>\r\n{\r\n    private map: {[key: string]: Value | undefined} = {};\r\n\r\n    add(key: string, data: Value) {\r\n        this.map[key] = data;\r\n    }\r\n\r\n    remove(key: string) {\r\n        this.map[key] = undefined;\r\n    }\r\n\r\n    get(key: string) {\r\n        return this.map[key];\r\n    }\r\n\r\n    has(key: string) {\r\n        return this.map[key] !== undefined;\r\n    }\r\n\r\n    clear() {\r\n        this.map = {};\r\n    }\r\n}\r\n\r\n/**\r\n * Serialize point into a unique string\r\n * @param point\r\n */\r\nexport function stringify(point: Point) {\r\n    return 'x' + point.x + 'y' + point.y;\r\n}","/**\r\n * A compare function to determine if a is 'better' (deserves a higher position) than b\r\n */\r\nexport type Comparator<E> = (a: E, b: E) => boolean\r\n\r\n/**\r\n * Minimalist Implementation of the heap data structure as an array\r\n */\r\nclass Heap<E>\r\n{\r\n    private elements: E[] = [];\r\n    readonly compare: Comparator<E>;\r\n\r\n    constructor(compare: Comparator<E>) {\r\n        this.compare = compare;\r\n    }\r\n\r\n    /**\r\n     * Returns the size of the heap\r\n     */\r\n    getSize() {\r\n        return this.elements.length;\r\n    }\r\n\r\n    /**\r\n     * Checks if heap is empty\r\n     */\r\n    isEmpty() {\r\n        return this.elements.length === 0;\r\n    }\r\n\r\n    /**\r\n     * Add a new element to the heap\r\n     * @param e\r\n     */\r\n    push(e: E) {\r\n        this.elements.push(e);\r\n        this.siftUp(this.elements.length-1); //last element\r\n    }\r\n\r\n    /**\r\n     * Returns the top of the heap without removing it\r\n     * Fails if heap is empty\r\n     */\r\n    peek() {\r\n        return this.elements[0];\r\n    }\r\n\r\n    /**\r\n     * Returns the top of the heap and removes it\r\n     * Fails if heap is empty\r\n     */\r\n    pop() {\r\n        const val = this.peek();\r\n        this.move(this.elements.length - 1, 0);\r\n        this.elements.pop();\r\n        this.siftDown(0);\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Clear the heap\r\n     */\r\n    clear() {\r\n        this.elements = [];\r\n    }\r\n\r\n    /**\r\n     * Sifts a new element that is out of order up to the right position\r\n     * @param pos of new element\r\n     */\r\n    private siftUp(pos: number) {\r\n        let parent = ((pos - 1) / 2) >> 0; //integer division\r\n        while(parent >= 0) {\r\n            //if the current position is better than parent\r\n            if(this.compare(this.elements[pos], this.elements[parent])) {\r\n                //then current position with parent and move to next\r\n                this.swap(pos, parent);\r\n                pos = parent;\r\n                parent = ((pos - 1) / 2) >> 0;\r\n            } else {\r\n                //otherwise stop\r\n                parent = -1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sifts a new element that is out of order down to the right position\r\n     * @param pos of new element\r\n     */\r\n    private siftDown(pos: number) {\r\n        const left = 2 * pos + 1;\r\n        const right = 2 * pos + 2;\r\n        //stop if the children are out of bounds\r\n        if(left >= this.elements.length) {\r\n            return;\r\n        }\r\n        //find the better child\r\n        const child = (right >= this.elements.length || this.compare(this.elements[left], this.elements[right]))\r\n            ? left : right;\r\n        //continues to sift down if the child is better than the current position\r\n        if(this.compare(this.elements[child], this.elements[pos])) {\r\n            this.swap(child, pos);\r\n            this.siftDown(child);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal move function\r\n     * @param from\r\n     * @param to\r\n     */\r\n    private move(from: number, to: number) {\r\n        this.elements[to] = this.elements[from];\r\n    }\r\n\r\n    /**\r\n     * Internal swap function\r\n     * @param a\r\n     * @param b\r\n     */\r\n    private swap(a: number, b: number) {\r\n        let val = this.elements[a];\r\n        this.elements[a] = this.elements[b];\r\n        this.elements[b] = val;\r\n    }\r\n}\r\n\r\nexport default Heap;","import {Point, Tile} from '../core/Components';\r\nimport Navigator from '../core/Navigator';\r\nimport {Node} from './Node';\r\n\r\n/**\r\n * Pathfinder performs algorithms operations on the grid\r\n * Uses the navigator rank and expand nodes\r\n */\r\nabstract class Pathfinder\r\n{\r\n    protected recentSearch: Node[] = [];\r\n    protected navigator: Navigator;\r\n\r\n    constructor(navigator: Navigator) {\r\n        this.navigator = navigator;\r\n    }\r\n\r\n    setNavigator(navigator: Navigator) {\r\n        this.navigator = navigator;\r\n    }\r\n\r\n    getNavigator() {\r\n        return this.navigator;\r\n    }\r\n\r\n    getRecentNodes() {\r\n        return this.recentSearch.length;\r\n    }\r\n\r\n    clearRecentSearch() {\r\n        this.recentSearch = [];\r\n    }\r\n\r\n    addRecent(node: Node) {\r\n        this.recentSearch.push(node);\r\n    }\r\n\r\n    abstract getAlgorithmName(): string;\r\n\r\n    /**\r\n     * Finds the best path between initial and goal on the grid\r\n     * and returns it in an array\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    abstract findPath(initial: Point, goal: Point): Tile[];\r\n\r\n    /**\r\n     * Reconstructs the solution using the recent search array and calls a\r\n     * function for every generation and for every expansion\r\n     * @param onGeneration to determine what to do when a node's generation is expanded\r\n     */\r\n    reconstructSolution(onGeneration: (nodes: Node) => void) {\r\n        for(const node of this.recentSearch) {\r\n            onGeneration(node);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Reconstructs the path from a tree, given the bottomLeaf, and\r\n * returns the shortest path in an array\r\n * @param bottomLeaf bottom of the tree to start from\r\n */\r\nexport function reconstructPath(bottomLeaf: Node): Tile[] {\r\n    return reconstructPathReversed(bottomLeaf).reverse();\r\n}\r\n\r\n/**\r\n * Reconstructs the path from a tree, given the bottomLeaf, and\r\n * returns the shortest path in an array\r\n * @param bottomLeaf bottom of the tree to start from\r\n */\r\nexport function reconstructPathReversed(bottomLeaf: Node): Tile[] {\r\n    const path: Tile[] = [];\r\n    while(bottomLeaf.parent !== null) {\r\n        path.push(bottomLeaf.tile);\r\n        bottomLeaf = bottomLeaf.parent;\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default Pathfinder;","import {Tile} from '../core/Components';\r\n\r\n/**\r\n * Represents a search Tree Node\r\n */\r\nexport class Node\r\n{\r\n    parent: Node | null = null; //parent node\r\n    readonly children: Node[] = [];\r\n    readonly tile: Tile; //stores a graph node\r\n\r\n    constructor(tile: Tile) {\r\n        this.tile = tile;\r\n    }\r\n\r\n    addChild(child: Node) {\r\n        child.parent = this;\r\n        this.children.push(child);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents an heuristic weighted aStar search tree node\r\n */\r\nexport class AStarNode extends Node\r\n{\r\n    readonly g: number; //path cost\r\n    readonly fScore: number; //heuristic\r\n\r\n    constructor(tile: Tile, g: number, fScore: number) {\r\n        super(tile);\r\n        this.g = g;\r\n        this.fScore = fScore;\r\n    }\r\n\r\n    f() {\r\n        return this.fScore;\r\n    }\r\n}\r\n","import {HashTable, stringify} from '../structures/Hash';\r\nimport Heap from '../structures/Heap';\r\nimport Pathfinder, {reconstructPath} from './Pathfinder';\r\nimport {Point, Tile} from '../core/Components';\r\nimport {AStarNode} from './Node';\r\nimport Navigator from '../core/Navigator';\r\nimport {euclidean, HeuristicFunc} from './Heuristics';\r\n\r\nclass AStarPathfinder extends Pathfinder\r\n{\r\n    private readonly heuristic: HeuristicFunc = (a: Point, b: Point) => euclidean(a,b);\r\n\r\n    constructor(navigator: Navigator, func?: HeuristicFunc) {\r\n        super(navigator);\r\n        if(func !== undefined) {\r\n            this.heuristic = func;\r\n        }\r\n    }\r\n\r\n    getAlgorithmName(): string {\r\n        return 'A*';\r\n    }\r\n\r\n    /**\r\n     * Performs aStar algorithm on the grid given an initial and goal point\r\n     * Always returns the shortest path, and performs well on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point): Tile[] {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const openSet = new Heap<AStarNode>(\r\n            (a, b) => a.f() < b.f()\r\n        );\r\n        const closedSet = new HashTable<number>();\r\n        const root = new AStarNode(\r\n            grid.get(initial), 0, 0\r\n        );\r\n        openSet.push(root);\r\n        closedSet.add(stringify(initial), root.f());\r\n        while (!openSet.isEmpty()) {\r\n            const currentNode = openSet.pop();\r\n            this.addRecent(currentNode);\r\n            const currentPoint = currentNode.tile.point;\r\n            if (this.navigator.equals(currentPoint, goal)) {\r\n                return reconstructPath(currentNode);\r\n            }\r\n            for (const neighbor of this.navigator.neighbors(currentPoint)) {\r\n                const neighborPoint = neighbor.point;\r\n                const neighborKey = stringify(neighborPoint);\r\n                const g = currentNode.g + this.stepCost(currentPoint, neighborPoint);\r\n                const f = g + this.heuristic(neighborPoint, goal);\r\n                if (!closedSet.has(neighborKey) || f < closedSet.get(neighborKey)!) {\r\n                    const neighborNode = new AStarNode(\r\n                        neighbor, g, f\r\n                    );\r\n                    currentNode.addChild(neighborNode);\r\n                    openSet.push(neighborNode);\r\n                    closedSet.add(neighborKey, neighborNode.f());\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * The step-cost function to be used, calculating the cost from\r\n     * currentPoint to neighborPoint. Uses the stepCost function provided by the\r\n     * navigator by default but can be overridden\r\n     * @param currentPoint\r\n     * @param neighborPoint\r\n     */\r\n    stepCost(currentPoint: Point, neighborPoint: Point) {\r\n        return this.navigator.cost(currentPoint, neighborPoint);\r\n    }\r\n}\r\n\r\nexport default AStarPathfinder;","import Pathfinder, {reconstructPath} from './Pathfinder';\r\nimport {Point, Tile} from '../core/Components';\r\nimport {HashSet, stringify} from '../structures/Hash';\r\nimport {Node} from './Node';\r\n\r\nclass BFSPathfinder extends Pathfinder\r\n{\r\n    getAlgorithmName(): string {\r\n        return 'Breadth First Search';\r\n    }\r\n\r\n    /**\r\n     * Implementation of BFS to find the shortest path from initial to point\r\n     * Always returns the shortest path, but performs poorly on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point): Tile[] {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const queue: Node[] = []; //fifo, stores nodes on the frontier\r\n        const visited = new HashSet();\r\n        const root = new Node(grid.get(initial));\r\n        queue.push(root); //enqueue\r\n        visited.add(stringify(initial));\r\n        while(queue.length !== 0) { //not empty\r\n            const currentNode = queue.shift()!; //dequeue\r\n            this.addRecent(currentNode);\r\n            const currentPoint = currentNode.tile.point;\r\n            if(this.navigator.equals(currentPoint, goal)) {\r\n                return reconstructPath(currentNode);\r\n            }\r\n            for(const neighbor of this.navigator.neighbors(currentPoint)) {\r\n                const neighborKey = stringify(neighbor.point);\r\n                if(!visited.has(neighborKey)) {\r\n                    const neighborNode = new Node(neighbor);\r\n                    currentNode.addChild(neighborNode);\r\n                    queue.push(neighborNode); //enqueue\r\n                    visited.add(neighborKey);\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\nexport default BFSPathfinder;","/**\r\n * Stack node\r\n */\r\nclass Node<E>\r\n{\r\n    next: Node<E> | null = null;\r\n    data: E;\r\n\r\n    constructor(data: E) {\r\n        this.data = data;\r\n    }\r\n}\r\n\r\n/**\r\n * Minimalist Implementation of the stack data structure\r\n */\r\nclass Stack<E>\r\n{\r\n    private top: Node<E> | null = null;\r\n    private size: number = 0;\r\n\r\n    peek() {\r\n        return this.top != null ? this.top.data : undefined;\r\n    }\r\n\r\n    push(e: E) {\r\n        const node = new Node(e);\r\n        node.next = this.top;\r\n        this.top = node;\r\n        this.size++;\r\n    }\r\n\r\n    pop() {\r\n        const top = this.peek();\r\n        if(this.top != null) {\r\n            this.top = this.top.next;\r\n            this.size--;\r\n        }\r\n        return top;\r\n    }\r\n\r\n    isEmpty() {\r\n        return this.size === 0;\r\n    }\r\n\r\n    getSize() {\r\n        return this.size;\r\n    }\r\n}\r\n\r\nexport default Stack;","import Pathfinder, {reconstructPath} from './Pathfinder';\r\nimport {Point, Tile} from '../core/Components';\r\nimport {HashSet, stringify} from '../structures/Hash';\r\nimport {Node} from './Node';\r\nimport Stack from '../structures/Stack';\r\n\r\nclass DFSPathfinder extends Pathfinder\r\n{\r\n    getAlgorithmName(): string {\r\n        return 'Depth First Search';\r\n    }\r\n\r\n    /**\r\n     * Calls DFS between a start and goal point, will typically not find the 'Best' path,\r\n     * and will instead find the best path capable for the algorithm\r\n     * As this algorithm is non optimal it should only be used for educational purposes\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point): Tile[] {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const root = new Node(grid.get(initial));\r\n        const stack = new Stack<Node>();\r\n        stack.push(root);\r\n        const visited = new HashSet();\r\n        visited.add(stringify(initial));\r\n        while(!stack.isEmpty()) {\r\n            const currentNode = stack.pop()!;\r\n            this.addRecent(currentNode);\r\n            const currentPoint = currentNode.tile.point;\r\n            visited.add(stringify(currentPoint));\r\n            if(this.navigator.equals(currentPoint, goal)) {\r\n                return reconstructPath(currentNode);\r\n            }\r\n            const neighbors = this.navigator.neighbors(currentPoint).reverse();\r\n            for(const neighbor of neighbors){\r\n                const neighborKey = stringify(neighbor.point);\r\n                if(!visited.has(neighborKey)) {\r\n                    const neighborNode = new Node(neighbor);\r\n                    currentNode.addChild(neighborNode);\r\n                    stack.push(neighborNode);\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\nexport default DFSPathfinder;\r\n","import {HashTable, stringify} from '../structures/Hash';\r\nimport Heap from '../structures/Heap';\r\nimport Pathfinder, {reconstructPath, reconstructPathReversed} from './Pathfinder';\r\nimport {Point, Tile} from '../core/Components';\r\nimport {AStarNode} from './Node';\r\nimport Navigator from '../core/Navigator';\r\nimport {euclidean, HeuristicFunc} from './Heuristics';\r\n\r\nclass BiAStarPathfinder extends Pathfinder\r\n{\r\n    private readonly heuristic: HeuristicFunc = (a: Point, b: Point) => euclidean(a,b);\r\n\r\n    constructor(navigator: Navigator, func?: HeuristicFunc) {\r\n        super(navigator);\r\n        if(func !== undefined) {\r\n            this.heuristic = func;\r\n        }\r\n    }\r\n\r\n    getAlgorithmName(): string {\r\n        return 'Bidirectional A*';\r\n    }\r\n\r\n    /**\r\n     * Performs aStar algorithm on the grid given an initial and goal point\r\n     * Always returns the shortest path, and performs well on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point): Tile[] {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const startOpenSet = new Heap<AStarNode>(\r\n            (a, b) => a.f() < b.f()\r\n        );\r\n        const startClosedSet = new HashTable<AStarNode>();\r\n        const endOpenSet = new Heap<AStarNode>(\r\n            (a, b) => a.f() < b.f()\r\n        );\r\n        const endClosedSet = new HashTable<AStarNode>();\r\n        const initialRoot = new AStarNode(\r\n            grid.get(initial), 0, 0\r\n        );\r\n        startOpenSet.push(initialRoot);\r\n        startClosedSet.add(stringify(initial), initialRoot);\r\n        const goalRoot = new AStarNode(\r\n            grid.get(goal), 0, 0\r\n        );\r\n        endOpenSet.push(goalRoot);\r\n        endClosedSet.add(stringify(goal), goalRoot);\r\n        while (!startOpenSet.isEmpty() && !endOpenSet.isEmpty()) {\r\n            //expand startOpenSet\r\n            const startCurrentNode = startOpenSet.pop();\r\n            this.addRecent(startCurrentNode);\r\n            const startCurrentPoint = startCurrentNode.tile.point;\r\n            const startCurrentPointKey = stringify(startCurrentPoint);\r\n            if(endClosedSet.has(startCurrentPointKey)) {\r\n                if(startCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startCurrentNode.parent\r\n                    ).concat(reconstructPathReversed(\r\n                        endClosedSet.get(startCurrentPointKey)!\r\n                    )).concat(\r\n                        grid.get(goal)\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n            }\r\n            for (const neighbor of this.navigator.neighbors(startCurrentPoint)) {\r\n                const neighborPoint = neighbor.point;\r\n                const neighborKey = stringify(neighborPoint);\r\n                const g = startCurrentNode.g + this.stepCost(startCurrentPoint, neighborPoint);\r\n                const f = g + this.heuristic(neighborPoint, goal);\r\n                if (!startClosedSet.has(neighborKey) || f < startClosedSet.get(neighborKey)!.f()) {\r\n                    const neighborNode = new AStarNode(\r\n                        neighbor, g, f\r\n                    );\r\n                    startCurrentNode.addChild(neighborNode);\r\n                    startOpenSet.push(neighborNode);\r\n                    startClosedSet.add(neighborKey, neighborNode);\r\n                }\r\n            }\r\n            //expand closedOpenSet\r\n            const endCurrentNode = endOpenSet.pop();\r\n            this.addRecent(endCurrentNode);\r\n            const endCurrentPoint = endCurrentNode.tile.point;\r\n            const endCurrentPointKey = stringify(endCurrentPoint);\r\n            if(startClosedSet.has(endCurrentPointKey)) {\r\n                if(endCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startClosedSet.get(endCurrentPointKey)!\r\n                    ).concat(reconstructPathReversed(\r\n                        endCurrentNode.parent!\r\n                    )).concat(\r\n                        grid.get(goal)\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n\r\n            }\r\n            for (const neighbor of this.navigator.neighbors(endCurrentPoint)) {\r\n                const neighborPoint = neighbor.point;\r\n                const neighborKey = stringify(neighborPoint);\r\n                const g = endCurrentNode.g + this.stepCost(endCurrentPoint, neighborPoint);\r\n                const f = g + this.heuristic(neighborPoint, initial);\r\n                if (!endClosedSet.has(neighborKey) || f < endClosedSet.get(neighborKey)!.f()) {\r\n                    const neighborNode = new AStarNode(\r\n                        neighbor, g, f\r\n                    );\r\n                    endCurrentNode.addChild(neighborNode);\r\n                    endOpenSet.push(neighborNode);\r\n                    endClosedSet.add(neighborKey, neighborNode);\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * The step-cost function to be used, calculating the cost from\r\n     * currentPoint to neighborPoint. Uses the stepCost function provided by the\r\n     * navigator by default but can be overridden\r\n     * @param currentPoint\r\n     * @param neighborPoint\r\n     */\r\n    stepCost(currentPoint: Point, neighborPoint: Point) {\r\n        return this.navigator.cost(currentPoint, neighborPoint);\r\n    }\r\n}\r\n\r\nexport default BiAStarPathfinder;","import Pathfinder, {reconstructPath, reconstructPathReversed} from './Pathfinder';\r\nimport {Point, Tile} from '../core/Components';\r\nimport {HashTable, stringify} from '../structures/Hash';\r\nimport {Node} from './Node';\r\n\r\nclass BiBFSPathfinder extends Pathfinder\r\n{\r\n    getAlgorithmName(): string {\r\n        return 'Bidirectional Breadth First Search';\r\n    }\r\n\r\n    /**\r\n     * Implementation of BFS to find the shortest path from initial to point\r\n     * Always returns the shortest path, but performs poorly on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point): Tile[] {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const startVisited = new HashTable<Node>();\r\n        const endVisited = new HashTable<Node>();\r\n        const startQueue: Node[] = [];\r\n        const endQueue: Node[] = [];\r\n        const initialRoot = new Node(grid.get(initial));\r\n        startQueue.push(initialRoot);\r\n        startVisited.add(stringify(initial), initialRoot);\r\n        const goalRoot = new Node(grid.get(goal));\r\n        endQueue.push(goalRoot);\r\n        endVisited.add(stringify(goal), goalRoot);\r\n        while(startQueue.length !== 0 && endQueue.length !== 0) {\r\n            //expand startQueue\r\n            const startCurrentNode = startQueue.shift()!;\r\n            this.addRecent(startCurrentNode);\r\n            const startCurrentPoint = startCurrentNode.tile.point;\r\n            const startCurrentPointKey = stringify(startCurrentPoint);\r\n            if(endVisited.has(startCurrentPointKey)) {\r\n                if(startCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startCurrentNode.parent\r\n                    ).concat(reconstructPathReversed(\r\n                        endVisited.get(startCurrentPointKey)!\r\n                    )).concat(\r\n                        grid.get(goal)\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n            }\r\n            for(const neighbor of this.navigator.neighbors(startCurrentPoint)) {\r\n                const neighborKey = stringify(neighbor.point);\r\n                if(!startVisited.has(neighborKey)) {\r\n                    const neighborNode = new Node(neighbor);\r\n                    startCurrentNode.addChild(neighborNode);\r\n                    startQueue.push(neighborNode);\r\n                    startVisited.add(neighborKey, neighborNode);\r\n                }\r\n            }\r\n            //expand endQueue\r\n            const endCurrentNode = endQueue.shift()!;\r\n            this.addRecent(endCurrentNode);\r\n            const endCurrentPoint = endCurrentNode.tile.point;\r\n            const endCurrentPointKey = stringify(endCurrentPoint);\r\n            if(startVisited.has(endCurrentPointKey)) {\r\n                if(endCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startVisited.get(endCurrentPointKey)!\r\n                    ).concat(reconstructPathReversed(\r\n                        endCurrentNode.parent\r\n                    )).concat(\r\n                        grid.get(goal)\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n            }\r\n            for(const neighbor of this.navigator.neighbors(endCurrentPoint)) {\r\n                const neighborKey = stringify(neighbor.point);\r\n                if(!endVisited.has(neighborKey)) {\r\n                    const neighborNode = new Node(neighbor);\r\n                    endCurrentNode.addChild(neighborNode);\r\n                    endQueue.push(neighborNode);\r\n                    endVisited.add(neighborKey, neighborNode);\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\nexport default BiBFSPathfinder;","import Navigator from '../core/Navigator';\r\nimport PlusNavigator from '../core/PlusNavigator';\r\nimport AsteriskNavigator from '../core/AsteriskNavigator';\r\nimport {Point} from '../core/Components';\r\nimport {Grid} from '../core/Grid';\r\nimport {chebyshev, euclidean, HeuristicFunc, manhattan, nullHeuristic, octile} from './Heuristics';\r\nimport Pathfinder from './Pathfinder';\r\nimport AStarPathfinder from './AStar';\r\nimport BFSPathfinder from './BFS';\r\nimport DFSPathfinder from './DFS';\r\nimport BiAStarPathfinder from './BidirectionalAStar';\r\nimport BiBFSPathfinder from \"./BidirectionalBFS\";\r\n\r\nconst CREATE_NAVIGATOR: {[key: string]: ((grid: Grid) => Navigator)} = {\r\n    'plus': (grid: Grid) => new PlusNavigator(grid),\r\n    'asterisk': (grid: Grid) => new AsteriskNavigator(grid)\r\n}\r\n\r\nconst CREATE_HEURISTIC: {[key: string]: (() => HeuristicFunc)} = {\r\n    'manhattan': () => (a,b) => manhattan(a,b),\r\n    'euclidean': () => (a,b) => euclidean(a,b),\r\n    'chebyshev': () => (a,b) => chebyshev(a,b),\r\n    'octile': () => (a,b) => octile(a,b),\r\n    'null': () => (a,b) => nullHeuristic(a,b)\r\n}\r\n\r\nconst CREATE_PATHFINDER: {[key: string]: ((navigator: Navigator, heuristic: HeuristicFunc) => Pathfinder)} = {\r\n    'dijkstra': (navigator) => {\r\n        return new (class DijkstraPathfinder extends AStarPathfinder {\r\n            getAlgorithmName(): string {\r\n                return 'Dijkstra';\r\n            }\r\n        })(navigator, (a,b) => nullHeuristic(a,b));\r\n    },\r\n    'best-first': (navigator, heuristic) => {\r\n        return new (class BestFirstPathfinder extends AStarPathfinder {\r\n            stepCost(currentPoint: Point, neighborPoint: Point) {\r\n                return 0;\r\n            }\r\n            getAlgorithmName(): string {\r\n                return 'Best-First Search';\r\n            }\r\n        })(navigator, heuristic);\r\n    },\r\n    'a*': (navigator, heuristic) => {\r\n        return new AStarPathfinder(navigator, heuristic);\r\n    },\r\n    'bfs': (navigator) => {\r\n        return new BFSPathfinder(navigator);\r\n    },\r\n    'dfs': (navigator) => {\r\n        return new DFSPathfinder(navigator);\r\n    },\r\n    'bi-a*': (navigator, heuristic) => {\r\n        return new BiAStarPathfinder(navigator, heuristic);\r\n    },\r\n    'bi-dijkstra': (navigator) => {\r\n        return new (class BiDijkstraPathfinder extends BiAStarPathfinder {\r\n            getAlgorithmName(): string {\r\n                return 'Bidirectional Dijkstra';\r\n            }\r\n        })(navigator, (a,b) => nullHeuristic(a,b));\r\n    },\r\n    'bi-bfs': (navigator) => {\r\n        return new BiBFSPathfinder(navigator);\r\n    }\r\n}\r\n\r\nclass PathfinderBuilder\r\n{\r\n    private navigator: string = 'plus';\r\n    private algorithm: string = 'a*';\r\n    private heuristic: string = 'null';\r\n    private readonly grid: Readonly<Grid>;\r\n\r\n    constructor(grid: Readonly<Grid>) {\r\n        this.grid = grid;\r\n    }\r\n\r\n    setNavigator(navigator: string) {\r\n        navigator = navigator.toLowerCase();\r\n        if(CREATE_NAVIGATOR[navigator] == null) {\r\n            throw new Error('No such navigator pattern exists')\r\n        } else {\r\n            this.navigator = navigator;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    setAlgorithm(algorithm: string) {\r\n        algorithm = algorithm.toLowerCase();\r\n        if(CREATE_PATHFINDER[algorithm] == null) {\r\n            throw new Error('No such pathfinding algorithm exists')\r\n        } else {\r\n            this.algorithm = algorithm;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    setHeuristic(heuristic: string) {\r\n        heuristic = heuristic.toLowerCase();\r\n        if(CREATE_HEURISTIC[heuristic] == null) {\r\n            throw new Error('No such heuristic function exists')\r\n        } else {\r\n            this.heuristic = heuristic;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Builds a pathfinder with a navigator with the set algorithm, heuristic, and navigator\r\n     */\r\n    build() {\r\n        const createHeuristic = CREATE_HEURISTIC[this.heuristic];\r\n        const createNavigator = CREATE_NAVIGATOR[this.navigator];\r\n        const createPathfinder = CREATE_PATHFINDER[this.algorithm];\r\n        return createPathfinder(createNavigator(this.grid), createHeuristic());\r\n    }\r\n\r\n    static usesHeuristic(algorithm: string) {\r\n        return algorithm === 'a*' || algorithm === 'bi-a*' ||\r\n            algorithm === 'best-first';\r\n    }\r\n\r\n    static hasBidirectional(algorithm: string) {\r\n        return CREATE_PATHFINDER['bi-' + algorithm] != null;\r\n    }\r\n\r\n    static makeBidirectional(algorithm: string) {\r\n        return 'bi-' + algorithm;\r\n    }\r\n}\r\n\r\nexport default PathfinderBuilder;\r\n\r\n","import GridGraph, {Grid} from '../core/Grid';\r\nimport {Point, Tile, createTile} from '../core/Components';\r\n\r\nconst LIMIT = 2;\r\n\r\nexport const NO_SKEW = 0;\r\nexport const VERTICAL_SKEW = 1;\r\nexport const HORIZONTAL_SKEW = 2;\r\n\r\ninterface Chamber\r\n{\r\n    topLeft: Point; //min\r\n    bottomRight: Point; //max\r\n}\r\n\r\nclass MazeGenerator\r\n{\r\n    private readonly width: number;\r\n    private readonly height: number;\r\n\r\n    private readonly divideWidth: (width: number, height: number) => boolean;\r\n\r\n    constructor(width: number, height: number, slant?: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n        if(slant === undefined || slant === NO_SKEW) {\r\n            this.divideWidth = divideWidthNoSkew;\r\n        } else if(slant === VERTICAL_SKEW) {\r\n            this.divideWidth = divideWidthVSkew;\r\n        } else if(slant === HORIZONTAL_SKEW) {\r\n            this.divideWidth = divideWidthHSkew;\r\n        } else {\r\n            throw new Error(\"Invalid recursive maze division skew type\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Performs the recursive division maze generation algorithm on a new empty grid\r\n     * by bisecting parts until the maze can no longer be bisected\r\n     * Params must be within bounds and create a chamber\r\n     * @param topLeft optional parameter to specify what point the maze should start from\r\n     *  This should not be further up/left than (1,1)\r\n     * @param bottomRight optional parameter to specify how far down and right the maze will go\r\n     *  This should not be further right/down than (width-2,height-2)\r\n     */\r\n    generateMaze(topLeft?: Point, bottomRight?: Point) {\r\n        const grid = new GridGraph(this.width, this.height);\r\n        if(topLeft === undefined) {\r\n            topLeft = {\r\n                x: 1, y: 1\r\n            }\r\n        }\r\n        if(bottomRight === undefined) {\r\n            bottomRight = {\r\n                x: grid.getWidth()-2,\r\n                y: grid.getHeight()-2\r\n            }\r\n        }\r\n        for(let x = topLeft.x - 1; x <= bottomRight.x + 1; x++) {\r\n            MazeGenerator.draw(grid,{\r\n                point: {\r\n                    x: x, y: topLeft.y - 1\r\n                },\r\n                data: createTile(true)\r\n            });\r\n            MazeGenerator.draw(grid,{\r\n                point: {\r\n                    x: x, y: bottomRight.y + 1\r\n                },\r\n                data: createTile(true)\r\n            });\r\n        }\r\n        for(let y = topLeft.y - 1; y <= bottomRight.y + 1; y++) {\r\n            MazeGenerator.draw(grid,{\r\n                point: {\r\n                    x: topLeft.x - 1, y: y\r\n                },\r\n                data: createTile(true)\r\n            });\r\n            MazeGenerator.draw(grid,{\r\n                point: {\r\n                    x: bottomRight.x + 1, y: y\r\n                },\r\n                data: createTile(true)\r\n            });\r\n        }\r\n        this.divide(grid,{\r\n            topLeft: topLeft,\r\n            bottomRight: bottomRight,\r\n        });\r\n        return grid;\r\n    }\r\n\r\n    /**\r\n     * Draws a list of tiles to the grid\r\n     * @param grid\r\n     * @param tiles\r\n     */\r\n    private static drawArr(grid: Grid, tiles: Tile[]) {\r\n        for(const tile of tiles) {\r\n            MazeGenerator.draw(grid, tile);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws a tile to the grid\r\n     * @param grid\r\n     * @param tile\r\n     */\r\n    private static draw(grid: Grid, tile: Tile) {\r\n        grid.mutateTile(tile);\r\n    }\r\n\r\n    /**\r\n     * Create a line between a region, with an open hole, in a chamber,\r\n     * and call bisection algorithm on it, and call division algorithms on\r\n     * its split chambers until no chambers can be bisected\r\n     * @param grid\r\n     * @param chamber\r\n     */\r\n    divide(grid: Grid, chamber: Chamber) {\r\n        const width = widthOf(chamber);\r\n        const height = heightOf(chamber);\r\n        const min = chamber.topLeft;\r\n        const max = chamber.bottomRight;\r\n        if(this.divideWidth(width,height)) {\r\n            if(width > LIMIT) {\r\n                //calculate axis\r\n                const randY = getRand(\r\n                    min.y, max.y,\r\n                );\r\n                const randX = getMidPoint(\r\n                    min.x, max.x\r\n                );\r\n                //create axis wall\r\n                const toDraw: Tile[] = [];\r\n                for(let y = min.y; y <= max.y; y++) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: y\r\n                        },\r\n                        data: createTile(true)\r\n                    });\r\n                }\r\n                //create holes in axis wall\r\n                let edgeBlocked = false;\r\n                if(!grid.get({\r\n                    x: randX, y: min.y-1\r\n                }).data.isSolid) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: min.y\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                    edgeBlocked = true;\r\n                }\r\n                if(!grid.get({\r\n                    x: randX, y: max.y+1\r\n                }).data.isSolid) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: max.y\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                    edgeBlocked = true;\r\n                }\r\n                if(!edgeBlocked) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: randY\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                }\r\n                MazeGenerator.drawArr(grid, toDraw);\r\n                //create children chambers and recurse\r\n                const leftChamber = {\r\n                    topLeft: chamber.topLeft,\r\n                    bottomRight: {\r\n                        x: randX-1,\r\n                        y: chamber.bottomRight.y\r\n                    },\r\n                };\r\n                const rightChamber = {\r\n                    topLeft: {\r\n                        x: randX+1,\r\n                        y: chamber.topLeft.y\r\n                    },\r\n                    bottomRight: chamber.bottomRight,\r\n                };\r\n                this.divide(grid, leftChamber);\r\n                this.divide(grid, rightChamber);\r\n            }\r\n        } else {\r\n            if(height > LIMIT) {\r\n                //calculate axis\r\n                const randX = getRand(\r\n                    min.x, max.x,\r\n                );\r\n                const randY = getMidPoint(\r\n                    min.y, max.y\r\n                );\r\n                //draw axis wall\r\n                const toDraw: Tile[] = [];\r\n                for(let x = min.x; x <= max.x; x++) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: x, y: randY\r\n                        },\r\n                        data: createTile(true)\r\n                    });\r\n                }\r\n                //create holes in axis wall\r\n                let edgeBlocked = false;\r\n                if(!grid.get({\r\n                    x: min.x-1, y: randY\r\n                }).data.isSolid) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: min.x, y: randY\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                    edgeBlocked = true;\r\n                }\r\n                if(!grid.get({\r\n                    x: max.x+1, y: randY\r\n                }).data.isSolid) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: max.x, y: randY\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                    edgeBlocked = true;\r\n                }\r\n                if(!edgeBlocked) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: randY\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                }\r\n                MazeGenerator.drawArr(grid, toDraw);\r\n                //create children chambers and recurse\r\n                const topChamber = {\r\n                    topLeft: chamber.topLeft,\r\n                    bottomRight: {\r\n                        x: chamber.bottomRight.x,\r\n                        y: randY-1\r\n                    },\r\n                };\r\n                const bottomChamber = {\r\n                    topLeft: {\r\n                        x: chamber.topLeft.x,\r\n                        y: randY+1\r\n                    },\r\n                    bottomRight: chamber.bottomRight,\r\n                };\r\n                this.divide(grid, topChamber);\r\n                this.divide(grid, bottomChamber);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction divideWidthNoSkew(width: number, height: number) {\r\n    return width >= height;\r\n}\r\n\r\nfunction divideWidthHSkew(width: number, height: number) {\r\n    return width >= height * 2;\r\n}\r\n\r\nfunction divideWidthVSkew(width: number, height: number) {\r\n    return width * 2 >= height;\r\n}\r\n\r\nfunction widthOf(chamber: Chamber) {\r\n    return chamber.bottomRight.x - chamber.topLeft.x + 1;\r\n}\r\n\r\nfunction heightOf(chamber: Chamber) {\r\n    return chamber.bottomRight.y - chamber.topLeft.y + 1;\r\n}\r\n\r\n/**\r\n * Returns the 'midpoint' to be used\r\n * @param min\r\n * @param max\r\n */\r\nfunction getMidPoint(min: number, max: number) {\r\n    const range = max - min;\r\n    if(range >= 20) {\r\n        return ((min+max)/2) >> 0;\r\n    } else if(range > 5) {\r\n        const mid = ((min+max)/2) >> 0;\r\n        const points = [mid, mid+1];\r\n        return points[getRand(0,points.length-1)];\r\n    } else {\r\n        return getRand(min+1,max-1);\r\n    }\r\n}\r\n\r\n/**\r\n * Generate a random number between min and max-1 then increment the number\r\n * if it is larger than or equal to excluded, inclusive for min and max\r\n * @param min\r\n * @param max\r\n * @param excluded\r\n */\r\nfunction getRandEx(min: number, max: number, excluded: number) {\r\n    let rand = getRand(min, max-1);\r\n    return rand >= excluded ? ++rand : rand;\r\n}\r\n\r\n/**\r\n * Generate a random number between min and max, inclusive for min and max\r\n * @param min\r\n * @param max\r\n */\r\nfunction getRand(min: number, max: number) {\r\n    return Math.floor(Math.random() * (max+1-min) + min);\r\n}\r\n\r\nexport default MazeGenerator;","import React, {RefObject} from 'react';\r\nimport GridBackground from './GridBackground';\r\nimport GridForeground from './GridForeground';\r\nimport StatsPanel from './StatsPanel';\r\nimport {Node} from '../../pathfinding/algorithms/Node';\r\nimport PathfindingSettings from '../PathfindingSettings';\r\nimport PathfinderBuilder from '../../pathfinding/algorithms/PathfinderBuilder';\r\nimport Pathfinder from '../../pathfinding/algorithms/Pathfinder';\r\nimport MazeGenerator from '../../pathfinding/algorithms/MazeGenerator';\r\nimport {Point, Tile} from '../../pathfinding/core/Components';\r\nimport {euclidean} from '../../pathfinding/algorithms/Heuristics';\r\n\r\ninterface IProps {\r\n    tileWidth: number,\r\n    settings: Readonly<PathfindingSettings>,\r\n    topMargin: number,\r\n    onChangeVisualizing: (visualizing: boolean) => void;\r\n}\r\n\r\ninterface IState {\r\n    tilesX: number,\r\n    tilesY: number,\r\n    time: number,\r\n    length: number,\r\n    nodes: number,\r\n    algorithm: string\r\n}\r\n\r\nclass PathfindingVisualizer extends React.Component<IProps,IState>\r\n{\r\n    //references to expose background and foreground grids to parent\r\n    private background: RefObject<GridBackground> = React.createRef();\r\n    private foreground: RefObject<GridForeground> = React.createRef();\r\n    private stats: RefObject<StatsPanel> = React.createRef();\r\n\r\n    private visualized = false;\r\n    private visualizing = false;\r\n    private visualTimeouts: NodeJS.Timeout[]  = [];\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        const w = window.screen.availWidth;\r\n        const h = window.screen.availHeight;\r\n        const tilesX = Math.floor(w / this.props.tileWidth) + 1;\r\n        const tilesY = Math.floor((h - this.props.topMargin - 30) / this.props.tileWidth) + 1;\r\n        this.state = {\r\n            tilesX: tilesX,\r\n            tilesY: tilesY,\r\n            time: -1,\r\n            length: -1,\r\n            nodes: -1,\r\n            algorithm: ''\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Performs the pathfinding algorithm on the grid and visualizes it\r\n     */\r\n    doPathfinding = () => {\r\n        const settings = this.props.settings;\r\n        const pathfinder = this.getPathfinder(settings);\r\n        const path = this.findPath(pathfinder);\r\n        this.clearPath();\r\n        const nodes: Node[] = [];\r\n        pathfinder.reconstructSolution((node) => {\r\n            nodes.push(node);\r\n        });\r\n        if(settings.showArrows && settings.algorithm !== 'dfs') {\r\n            this.addArrowGenerations(nodes);\r\n        }\r\n        if(settings.visualizeAlg) {\r\n            this.visualizeGenerations(nodes);\r\n        }\r\n        this.drawPath(path);\r\n    }\r\n\r\n    /**\r\n     * Performs the pathfinding algorithm on the grid and visualizes it with delays between successive\r\n     * node generations\r\n     */\r\n    doDelayedPathfinding = () => {\r\n        this.clearVisualization();\r\n        this.clearPath();\r\n        const settings = this.props.settings;\r\n        this.visualized = false;\r\n        const foreground = this.foreground.current!;\r\n        foreground.toggleDisable();\r\n        const nodes: Node[] = [];\r\n        if(!this.visualizing) {\r\n            this.visualizing = true;\r\n            this.props.onChangeVisualizing(this.visualizing);\r\n            const pathfinder = this.getPathfinder(settings);\r\n            const path = this.findPath(pathfinder);\r\n            const increment = settings.visualizeAlg ? settings.delayInc : 0;\r\n            const promises: Promise<NodeJS.Timeout>[] = []; //to call function when timeouts finish\r\n            this.visualTimeouts = [];\r\n            let delay = 0;\r\n            const expandVisualization = settings.visualizeAlg\r\n                ?\r\n                (node: Node) => {\r\n                    this.visualizeGeneration(node);\r\n                }\r\n                :\r\n                () => {}\r\n            pathfinder.reconstructSolution((node) => {\r\n                const promise = new Promise<NodeJS.Timeout>((resolve) => {\r\n                    //each generation gets a higher timeout\r\n                    const timeout = setTimeout(() => {\r\n                        expandVisualization(node);\r\n                        nodes.push(node);\r\n                        resolve(timeout);\r\n                    }, delay);\r\n                    this.visualTimeouts.push(timeout);\r\n                    delay += increment;\r\n                });\r\n                promises.push(promise);\r\n            });\r\n            //call functions when timeouts finish\r\n            Promise.all(promises).then(() => {\r\n                this.drawPath(path);\r\n                if(settings.showArrows && settings.algorithm !== 'dfs') {\r\n                    this.addArrowGenerations(nodes)\r\n                }\r\n                foreground.toggleDisable();\r\n                this.visualizing = false;\r\n                this.visualized = true;\r\n                this.props.onChangeVisualizing(this.visualizing);\r\n            });\r\n        } else {\r\n            for (let i = 0; i < this.visualTimeouts.length; i++) {\r\n                clearTimeout(this.visualTimeouts[i]);\r\n            }\r\n            this.visualizing = false;\r\n            this.props.onChangeVisualizing(this.visualizing);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the pathfinder for the settings\r\n     * @param settings\r\n     */\r\n    private getPathfinder = (settings: PathfindingSettings) => {\r\n        const algorithmKey = settings.algorithm;\r\n        const algorithm = settings.bidirectional && PathfinderBuilder.hasBidirectional(algorithmKey) ?\r\n            PathfinderBuilder.makeBidirectional(algorithmKey) : algorithmKey;\r\n        return new PathfinderBuilder(this.foreground.current!.state.grid)\r\n            .setAlgorithm(algorithm)\r\n            .setHeuristic(settings.heuristicKey)\r\n            .setNavigator(settings.navigatorKey)\r\n            .build();\r\n    }\r\n\r\n    /**\r\n     * Find path with a given pathfinder, includes benchmarking\r\n     * @param pathfinder\r\n     */\r\n    private findPath = (pathfinder: Pathfinder) => {\r\n        const foreground = this.foreground.current!;\r\n        const t0 = performance.now();\r\n        const path = pathfinder.findPath(foreground.state.initial, foreground.state.goal);\r\n        const t1 = performance.now();\r\n        const t2 = (t1 - t0);\r\n        this.setState({\r\n            time: t2,\r\n            nodes: pathfinder.getRecentNodes(),\r\n            length: calcLength(foreground.state.initial, path),\r\n            algorithm: pathfinder.getAlgorithmName()\r\n        });\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Draw path on the grid and change length on ui\r\n     * @param path\r\n     */\r\n    private drawPath = (path: Tile[]) => {\r\n        const foreground = this.foreground.current!\r\n        path.unshift(this.foreground.current!.state.grid.get(foreground.state.initial));\r\n        this.foreground.current!.drawPath(path);\r\n    }\r\n\r\n    /**\r\n     * Called when child foreground moves a tile\r\n     */\r\n    private onTilesDragged = () => {\r\n        if(this.visualized) {\r\n            this.clearVisualization();\r\n            this.doPathfinding();\r\n            this.visualized = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a maze on the grid foreground\r\n     */\r\n    createMaze = (slant: number) => {\r\n        if(this.visualizing) {\r\n            return;\r\n        }\r\n        this.clearTiles();\r\n        this.clearPath();\r\n        this.clearVisualization();\r\n        const prevGrid = this.foreground.current!.state.grid;\r\n        const generator = new MazeGenerator(prevGrid.getWidth(), prevGrid.getHeight(), slant);\r\n        const end = this.calcEndPointInView();\r\n        const topLeft = {\r\n            x: 1, y: 1\r\n        };\r\n        const bottomRight = {\r\n            x: end.x-2, y: end.y-2\r\n        };\r\n        const grid = generator.generateMaze(topLeft, bottomRight);\r\n        this.foreground.current!.drawGrid(grid);\r\n        this.setPositions({\r\n            x: end.x-2,\r\n            y: end.y-2\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Calculate the end/goal point in view of the screen\r\n     */\r\n    calcEndPointInView = () => {\r\n        const xEnd = window.innerWidth / this.props.tileWidth;\r\n        const yEnd = (window.innerHeight - this.props.topMargin\r\n            - this.stats.current!.getHeight()) / this.props.tileWidth;\r\n        const xFloor = Math.floor(xEnd);\r\n        const yFloor = Math.floor(yEnd);\r\n        const xDecimal = xEnd - xFloor;\r\n        const yDecimal = yEnd - yFloor;\r\n        return {\r\n            x: xDecimal > 0.05 ? Math.ceil(xEnd) : xFloor,\r\n            y: yDecimal > 0.05 ? Math.ceil(yEnd) : yFloor\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the positions in the grid foreground\r\n     */\r\n    private setPositions = (endPoint: Point) => {\r\n        this.foreground.current!.moveInitial({\r\n            x: 1, y:1\r\n        });\r\n        this.foreground.current!.moveGoal(endPoint);\r\n    }\r\n\r\n    clearPath = () => {\r\n        this.foreground.current!.erasePath();\r\n    }\r\n\r\n    clearTiles = () => {\r\n        this.foreground.current!.clearTiles();\r\n    }\r\n\r\n    clearTilesChecked = () => {\r\n        if(!this.visualizing) {\r\n            this.foreground.current!.clearTiles();\r\n        }\r\n    }\r\n\r\n    clearVisualization = () => {\r\n        this.visualized = false;\r\n        this.background.current!.clear();\r\n    }\r\n\r\n    clearVisualizationChecked = () => {\r\n        if(!this.visualizing) {\r\n            this.visualized = false;\r\n            this.background.current!.clear();\r\n        }\r\n    }\r\n\r\n    private visualizeGenerations = (generations: Node[]) => {\r\n        this.background.current!.visualizeGenerations(generations);\r\n        this.visualized = true;\r\n    }\r\n\r\n    private visualizeGeneration = (generation: Node) => {\r\n        this.background.current!.visualizeGeneration(generation);\r\n    }\r\n\r\n    private addArrowGenerations = (generations: Node[]) => {\r\n        this.background.current!.addArrowGenerations(generations);\r\n    }\r\n\r\n    private addArrowGeneration = (generation: Node) => {\r\n        this.background.current!.addArrowGeneration(generation);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <StatsPanel ref={this.stats} algorithm={this.state.algorithm} length={this.state.length}\r\n                            time={this.state.time} nodes={this.state.nodes}/>\r\n                <GridBackground ref={this.background} tileWidth={this.props.tileWidth}\r\n                                tilesX={this.state.tilesX} tilesY={this.state.tilesY}/>\r\n                <GridForeground ref={this.foreground} topMargin={this.props.topMargin}\r\n                                onTilesDragged={this.onTilesDragged} tileWidth={this.props.tileWidth}\r\n                                tilesX={this.state.tilesX} tilesY={this.state.tilesY}/>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction calcLength(initial: Point, path: Tile[]) {\r\n    if(path.length === 0) {\r\n        return 0;\r\n    }\r\n    let len = euclidean(initial, path[0].point);\r\n    for (let i = 0; i < path.length - 1; i++) {\r\n        len += euclidean(path[i].point, path[i + 1].point);\r\n    }\r\n    return +(len).toFixed(3);\r\n}\r\n\r\nexport default PathfindingVisualizer;","import React from 'react';\r\n\r\ninterface IProps {\r\n    boxStyle: string,\r\n    defaultChecked: boolean,\r\n    disabled?: boolean,\r\n    onChange: (checked: boolean) => void\r\n}\r\n\r\ninterface IState {\r\n    checked: boolean\r\n}\r\n\r\nclass Checkbox extends React.Component<IProps,IState>\r\n{\r\n    public static defaultProps = {\r\n        disabled: false\r\n    };\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.state = {\r\n            checked: this.props.defaultChecked\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger callback and change checkbox state\r\n     */\r\n    onChange = () => {\r\n        this.setState(prevState => ({\r\n            checked: !prevState.checked\r\n        }), () => this.props.onChange(this.state.checked));\r\n    }\r\n\r\n    render() {\r\n        return(\r\n            <div>\r\n                <input checked={this.state.checked} type='checkbox' disabled={this.props.disabled}\r\n                       className={this.props.boxStyle} onKeyPress={this.onChange} onChange={this.onChange}\r\n                >\r\n                </input>\r\n                {this.props.children}\r\n            </div>\r\n        );\r\n    };\r\n}\r\n\r\nexport default Checkbox;","import React from 'react';\r\n\r\ninterface IProps {\r\n    min: number,\r\n    max: number,\r\n    default: number,\r\n    step: number,\r\n    sliderStyle: string,\r\n    onChange: (val: number) => void\r\n}\r\n\r\ninterface IState {\r\n    value: number\r\n}\r\n\r\nclass SteppedRangeSlider extends React.Component<IProps, IState>\r\n{\r\n    private mouseUp = true;\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.state = {\r\n            value: this.props.default\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger callback when slider value is changed\r\n     * @param e\r\n     */\r\n    onChange = (e: React.FormEvent<HTMLInputElement>) => {\r\n        if(!this.mouseUp) { //to prevent firefox from resetting on release\r\n            const val = Number(e.currentTarget.value);\r\n            this.setState({\r\n                value: val\r\n            }, () => this.props.onChange(val));\r\n        }\r\n    }\r\n\r\n    onMouseUp = () => {\r\n        this.mouseUp = true;\r\n    }\r\n\r\n    onMouseDown = () => {\r\n        this.mouseUp = false;\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <input type='range' list='step-list'\r\n                   value={this.state.value}\r\n                   min={this.props.min} max={this.props.max}\r\n                   step={this.props.step} className={this.props.sliderStyle}\r\n                   onInput={this.onChange}\r\n                   onMouseUp={this.onMouseUp}\r\n                   onMouseDown={this.onMouseDown}\r\n            >\r\n            </input>\r\n        );\r\n    }\r\n}\r\n\r\nexport default SteppedRangeSlider;","import React from 'react';\r\n\r\ninterface IProps {\r\n    boxStyle: string,\r\n    defaultChecked: number,\r\n    disabled: boolean,\r\n    onChange: (() => void)[]\r\n}\r\n\r\ninterface IState {\r\n    checked: boolean[];\r\n}\r\n\r\nclass RadioButtonGroup extends React.Component<IProps, IState>\r\n{\r\n    public static defaultProps = {\r\n        disabled: false\r\n    };\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        const checked: boolean[] = [];\r\n        for(let i = 0; i < this.props.onChange.length; i++) {\r\n            checked.push(i === this.props.defaultChecked);\r\n        }\r\n        this.state = {\r\n            checked: checked\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set all radio buttons to checked aside from the index\r\n     * of the one that was changed\r\n     * Trigger callback\r\n     * @param index\r\n     */\r\n    private onChange = (index: number) => {\r\n        const checked: boolean[] = [];\r\n        for(let i = 0; i < this.props.onChange.length; i++) {\r\n            checked.push(i === index);\r\n        }\r\n        this.setState({\r\n            checked: checked\r\n        }, () => this.props.onChange[index]());\r\n    }\r\n\r\n    render() {\r\n        const children = React.Children.toArray(this.props.children);\r\n        const radioButtons: JSX.Element[] = [];\r\n        for(let i = 0; i < this.props.onChange.length; i++) {\r\n            radioButtons.push(\r\n                <div key={i}>\r\n                    <input checked={this.state.checked[i]} type='radio' disabled={this.props.disabled}\r\n                           className={this.props.boxStyle}\r\n                           onChange={() => this.onChange(i)}\r\n                    >\r\n                    </input>\r\n                    {children[i]}\r\n                </div>\r\n            );\r\n        }\r\n        return radioButtons;\r\n    };\r\n}\r\n\r\nexport default RadioButtonGroup;","import React from 'react';\r\nimport Checkbox from '../elements/Checkbox';\r\nimport SteppedRangeSlider from '../elements/SteppedRangeSlider';\r\nimport RadioButtonGroup from '../elements/RadioButtonGroup';\r\n\r\ninterface VisualProps {\r\n    onChangeViz: () => void,\r\n    onChangeShowArrows: () => void,\r\n    disabled: boolean\r\n}\r\n\r\ninterface SpeedProps {\r\n    onChange: (value: number) => void\r\n}\r\n\r\ninterface SpeedState {\r\n    speedText: string\r\n}\r\n\r\ninterface AlgorithmProps {\r\n    onChangeDiagonals: (checked: boolean) => void,\r\n    onChangeBidirectional: (checked: boolean) => void\r\n    disabled: boolean\r\n}\r\n\r\ninterface HeuristicProps {\r\n    onClickManhattan: () => void,\r\n    onClickEuclidean: () => void,\r\n    onClickChebyshev: () => void,\r\n    onClickOctile: () => void,\r\n    disabled: boolean\r\n}\r\n\r\nexport class VisualSettings extends React.Component<VisualProps>\r\n{\r\n    render() {\r\n        return (\r\n            <div>\r\n                <div className='draggable-content-title'>Visualization</div>\r\n                <Checkbox defaultChecked={true} boxStyle='box'\r\n                          onChange={this.props.onChangeViz}>\r\n                    Show Frontier\r\n                </Checkbox>\r\n                <Checkbox defaultChecked={true} boxStyle='box'\r\n                          onChange={this.props.onChangeShowArrows}\r\n                          disabled={this.props.disabled}>\r\n                    Show Tree\r\n                </Checkbox>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class SpeedSettings extends React.Component<SpeedProps, SpeedState>\r\n{\r\n    constructor(props: SpeedProps) {\r\n        super(props);\r\n        this.state = {\r\n            speedText: '10'\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback function to be called when slider is changed\r\n     * Call another callback and change text\r\n     * @param value\r\n     */\r\n    onChangeSpeed = (value: number) => {\r\n        const speedTexts = value*5;\r\n        this.setState({\r\n            speedText: String(speedTexts)\r\n        })\r\n        this.props.onChange(value);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className='slider-container'>\r\n                <div className='slider-text'>\r\n                    Speed: <div className='speed-text'> {this.state.speedText} </div>\r\n                </div>\r\n                <SteppedRangeSlider min={1} max={10} step={1} default={2}\r\n                                    sliderStyle='slider speed-slider'\r\n                                    onChange={this.onChangeSpeed}\r\n                />\r\n                <datalist id='step-list'>\r\n                    <option>1</option>\r\n                    <option>2</option>\r\n                    <option>3</option>\r\n                    <option>4</option>\r\n                    <option>5</option>\r\n                    <option>6</option>\r\n                    <option>7</option>\r\n                    <option>8</option>\r\n                    <option>9</option>\r\n                    <option>10</option>\r\n                </datalist>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class AlgorithmSettings extends React.Component<AlgorithmProps>\r\n{\r\n    constructor(props: AlgorithmProps) {\r\n        super(props);\r\n        this.state = {\r\n            disabled: false\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <div className='draggable-content-title'>Algorithm</div>\r\n                <Checkbox defaultChecked={true} boxStyle='box'\r\n                          onChange={this.props.onChangeDiagonals}>\r\n                    Allow Diagonals\r\n                </Checkbox>\r\n                <Checkbox defaultChecked={false} boxStyle='box'\r\n                          disabled={this.props.disabled}\r\n                          onChange={this.props.onChangeBidirectional}>\r\n                    Bidirectional\r\n                </Checkbox>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class HeuristicSettings extends React.Component<HeuristicProps>\r\n{\r\n    constructor(props: HeuristicProps) {\r\n        super(props);\r\n        this.state = {\r\n            disabled: false\r\n        }\r\n    }\r\n\r\n    disable = () => {\r\n        this.setState({\r\n            disabled: true\r\n        })\r\n    }\r\n\r\n    enable = () => {\r\n        this.setState({\r\n            disabled: false\r\n        })\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <div className='draggable-content-title'>Heuristic</div>\r\n                <RadioButtonGroup boxStyle='box'\r\n                                  defaultChecked={1}\r\n                                  disabled={this.props.disabled}\r\n                                  onChange={[\r\n                                      this.props.onClickManhattan, this.props.onClickEuclidean,\r\n                                      this.props.onClickChebyshev, this.props.onClickOctile\r\n                                  ]}\r\n                >\r\n                    {[<span key='Manhattan'>Manhattan</span>, <span key='Euclidean'>Euclidean</span>,\r\n                        <span key='Chebyshev'>Chebyshev</span>, <span key='Octile<'>Octile</span>]}\r\n                </RadioButtonGroup>\r\n            </div>\r\n        )\r\n    }\r\n}","import PathfindingSettings, {getDefaultSettings} from './PathfindingSettings';\r\n\r\nclass SettingsManager\r\n{\r\n    settings: PathfindingSettings = getDefaultSettings();\r\n\r\n    changeAlgo = (algo: string) => {\r\n        this.settings.algorithm = algo;\r\n    }\r\n\r\n    changeVisualize = () => {\r\n        this.settings.visualizeAlg = !this.settings.visualizeAlg;\r\n    }\r\n\r\n    changeShowArrows = () => {\r\n        this.settings.showArrows = !this.settings.showArrows;\r\n    }\r\n\r\n    changeBidirectional = () => {\r\n        this.settings.bidirectional = !this.settings.bidirectional;\r\n    }\r\n\r\n    changeDiagonals = (checked: boolean) => {\r\n        this.settings.navigatorKey = checked ? 'asterisk' : 'plus';\r\n    }\r\n\r\n    changeSpeed = (value: number) => {\r\n        this.settings.delayInc = value*5;\r\n    }\r\n\r\n    changeManhattan = () => {\r\n        this.settings.heuristicKey = 'manhattan';\r\n    }\r\n\r\n    changeEuclidean = () => {\r\n        this.settings.heuristicKey = 'euclidean';\r\n    }\r\n\r\n    changeChebyshev = () => {\r\n        this.settings.heuristicKey = 'chebyshev';\r\n    }\r\n\r\n    changeOctile = () => {\r\n        this.settings.heuristicKey = 'octile';\r\n    }\r\n}\r\n\r\nexport default SettingsManager;","interface PathfindingSettings\r\n{\r\n    visualizeAlg: boolean,\r\n    showArrows: boolean,\r\n    delayInc: number,\r\n    algorithm: string,\r\n    heuristicKey: string,\r\n    navigatorKey: string,\r\n    bidirectional: boolean\r\n}\r\n\r\nexport function getDefaultSettings(): PathfindingSettings {\r\n    return {\r\n        visualizeAlg: true,\r\n        showArrows: true,\r\n        delayInc: 8,\r\n        algorithm: 'a*',\r\n        heuristicKey: 'euclidean',\r\n        navigatorKey: 'asterisk',\r\n        bidirectional: false\r\n    }\r\n}\r\n\r\nexport default PathfindingSettings;","import React, {RefObject} from 'react';\r\nimport '../App.css';\r\nimport TopBar from './navbar/TopBar';\r\nimport {VisualizeButton, SettingsButton} from './navbar/Buttons';\r\nimport {AlgorithmDropDown, ClearDropDown, MazeDropDown} from './navbar/DropDown';\r\nimport DraggablePanel from './elements/DraggablePanel';\r\nimport PathfindingVisualizer from './grid/PathfindingVisualizer';\r\nimport {VisualSettings, SpeedSettings, AlgorithmSettings, HeuristicSettings} from './navbar/SettingPanels';\r\nimport SettingsManager from './SettingsManager';\r\nimport PathfinderBuilder from '../pathfinding/algorithms/PathfinderBuilder';\r\nimport {HORIZONTAL_SKEW, NO_SKEW, VERTICAL_SKEW} from '../pathfinding/algorithms/MazeGenerator';\r\n\r\ninterface IProps {}\r\n\r\ninterface IState {\r\n    length: number,\r\n    time: number,\r\n    heuristicDisabled: boolean,\r\n    bidirectionalDisabled: boolean,\r\n    arrowsDisabled: boolean,\r\n    panelShow: boolean,\r\n    topMargin: number,\r\n    vButtonColor: string\r\n}\r\n\r\nclass PathfindingApp extends React.Component<IProps, IState>\r\n{\r\n    //expose grid to parent to connect to button siblings\r\n    private grid: RefObject<PathfindingVisualizer> = React.createRef();\r\n\r\n    private algDropDown: RefObject<AlgorithmDropDown> = React.createRef();\r\n    private clrDropDown: RefObject<ClearDropDown> = React.createRef();\r\n    private mazeDropDown: RefObject<MazeDropDown> = React.createRef();\r\n\r\n    private settingsManager: SettingsManager = new SettingsManager();\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.state = {\r\n            length: 0,\r\n            time: 0,\r\n            heuristicDisabled: false,\r\n            bidirectionalDisabled: false,\r\n            arrowsDisabled: false,\r\n            panelShow: false,\r\n            topMargin: 75,\r\n            vButtonColor: 'green-button'\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n        window.addEventListener('click', e => {\r\n            this.algDropDown.current!.hide();\r\n            this.clrDropDown.current!.hide();\r\n            this.mazeDropDown.current!.hide();\r\n        });\r\n    }\r\n\r\n    onClickAlgDrop = () => {\r\n        this.clrDropDown.current!.hide();\r\n        this.mazeDropDown.current!.hide();\r\n    }\r\n\r\n    onClickClrDrop = () => {\r\n        this.algDropDown.current!.hide();\r\n        this.mazeDropDown.current!.hide();\r\n    }\r\n\r\n    onClickMazeDrop = () => {\r\n        this.clrDropDown.current!.hide();\r\n        this.algDropDown.current!.hide();\r\n    }\r\n\r\n    changeVButtonColor = (visualizing: boolean) => {\r\n        const color = visualizing ? 'red-button' : 'green-button';\r\n        this.setState({\r\n            vButtonColor: color\r\n        })\r\n    }\r\n\r\n    toggleSettings = () => {\r\n        this.setState(prevState => ({\r\n            panelShow: !prevState.panelShow\r\n        }));\r\n    }\r\n\r\n    hideSettings = () => {\r\n        this.setState({\r\n            panelShow: false\r\n        });\r\n    }\r\n\r\n    changeAlgo = (algorithm: string) => {\r\n        this.setState({\r\n            heuristicDisabled: !PathfinderBuilder.usesHeuristic(algorithm),\r\n            bidirectionalDisabled: !PathfinderBuilder.hasBidirectional(algorithm),\r\n            arrowsDisabled: algorithm === 'dfs'\r\n        });\r\n        this.settingsManager.changeAlgo(algorithm);\r\n    }\r\n\r\n    doPathfinding = () => {\r\n        this.grid.current!.doDelayedPathfinding();\r\n    }\r\n\r\n    clearPath = () => {\r\n        this.grid.current!.clearPath();\r\n        this.grid.current!.clearVisualizationChecked();\r\n    }\r\n\r\n    clearTiles = () => {\r\n        this.clearPath();\r\n        this.grid.current!.clearTilesChecked();\r\n    }\r\n\r\n    createMaze = () => {\r\n        this.grid.current!.createMaze(NO_SKEW);\r\n    }\r\n\r\n    createMazeVSkew = () => {\r\n        this.grid.current!.createMaze(VERTICAL_SKEW);\r\n    }\r\n\r\n    createMazeHSkew = () => {\r\n        this.grid.current!.createMaze(HORIZONTAL_SKEW);\r\n    }\r\n\r\n    setLength = (len: number) => {\r\n        this.setState({\r\n            length: len\r\n        });\r\n    }\r\n\r\n    setTime = (time: number) => {\r\n        this.setState({\r\n            time: time\r\n        });\r\n    }\r\n\r\n    onChangeHeight = (height: number) => {\r\n        this.setState({\r\n            topMargin: height\r\n        })\r\n    }\r\n\r\n    render() {\r\n        const tileWidth =  isMobile() ? 47 : Math.round(window.screen.availWidth / 57);\r\n        return (\r\n            <div>\r\n                <DraggablePanel title={'Grid Settings'}\r\n                                show={this.state.panelShow}\r\n                                onClickXButton={this.hideSettings}\r\n                >\r\n                    <VisualSettings disabled={this.state.arrowsDisabled}\r\n                                    onChangeViz={this.settingsManager.changeVisualize}\r\n                                    onChangeShowArrows={this.settingsManager.changeShowArrows}\r\n                    />\r\n                    <SpeedSettings onChange={this.settingsManager.changeSpeed}/>\r\n                    <AlgorithmSettings disabled={this.state.bidirectionalDisabled}\r\n                                       onChangeBidirectional={this.settingsManager.changeBidirectional}\r\n                                       onChangeDiagonals={this.settingsManager.changeDiagonals}\r\n                    />\r\n                    <HeuristicSettings disabled={this.state.heuristicDisabled}\r\n                                       onClickManhattan={this.settingsManager.changeManhattan}\r\n                                       onClickEuclidean={this.settingsManager.changeEuclidean}\r\n                                       onClickChebyshev={this.settingsManager.changeChebyshev}\r\n                                       onClickOctile={this.settingsManager.changeOctile}\r\n                    />\r\n                </DraggablePanel>\r\n                <TopBar onChangeHeight={this.onChangeHeight}>\r\n                    <a href='https://github.com/JosephPrichard/PathfinderReact' className='title'>\r\n                        Pathfinding Visualizer\r\n                    </a>\r\n                    <div className='top-container'>\r\n                        <AlgorithmDropDown ref={this.algDropDown}\r\n                                           onClick={this.onClickAlgDrop}\r\n                                           onChange={this.changeAlgo}\r\n                        />\r\n                        <VisualizeButton color={this.state.vButtonColor}\r\n                                         onClick={this.doPathfinding}\r\n                        />\r\n                        <ClearDropDown ref={this.clrDropDown}\r\n                                       onClick={this.onClickClrDrop}\r\n                                       onClickTiles={this.clearTiles}\r\n                                       onClickPath={this.clearPath}\r\n                        />\r\n                        <MazeDropDown ref={this.mazeDropDown}\r\n                                      onClick={this.onClickMazeDrop}\r\n                                      onClickMaze={this.createMaze}\r\n                                      onClickMazeHorizontal={this.createMazeHSkew}\r\n                                      onClickMazeVertical={this.createMazeVSkew}\r\n                        />\r\n                        <SettingsButton onClick={this.toggleSettings}/>\r\n                    </div>\r\n                </TopBar>\r\n                <PathfindingVisualizer ref={this.grid}\r\n                                       onChangeVisualizing={this.changeVButtonColor}\r\n                                       topMargin={this.state.topMargin}\r\n                                       settings={this.settingsManager.settings}\r\n                                       tileWidth={tileWidth}/>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction isMobile() {\r\n    return /Android|webOS|iPhone|iPad|Mac|Macintosh|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\r\n}\r\n\r\nexport default PathfindingApp;","import React from 'react';\nimport PathfindingApp from './view/PathfindingApp';\n\nclass App extends React.Component\n{\n    render() {\n        return (\n            <PathfindingApp/>\n        );\n    }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n//import reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n    <React.StrictMode>\n        <App/>\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n\n//reportWebVitals();\n"],"sourceRoot":""}
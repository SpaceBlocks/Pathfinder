{"version":3,"sources":["view/navbar/TopBar.tsx","view/navbar/Buttons.tsx","view/navbar/DropDown.tsx","view/utility/DraggablePanel.tsx","view/grid/GridBackground.tsx","pathfinding/core/Components.ts","pathfinding/core/Grid.ts","view/grid/TileFg.tsx","view/grid/GridForeground.tsx","view/grid/StatsPanel.tsx","pathfinding/core/Navigator.ts","pathfinding/core/PlusNavigator.ts","pathfinding/algorithms/Heuristics.ts","pathfinding/core/AsteriskNavigator.ts","pathfinding/structures/Hash.ts","pathfinding/structures/Heap.ts","pathfinding/algorithms/Pathfinder.ts","pathfinding/algorithms/Node.ts","pathfinding/algorithms/AStar.ts","pathfinding/algorithms/BFS.ts","pathfinding/structures/Stack.ts","pathfinding/algorithms/DFS.ts","pathfinding/algorithms/BidirectionalAStar.ts","pathfinding/algorithms/BidirectionalBFS.ts","pathfinding/algorithms/PathfinderBuilder.ts","view/utility/VirtualTimer.ts","pathfinding/algorithms/TerrainGenerator.ts","pathfinding/algorithms/RandomTerrainGenerator.ts","pathfinding/algorithms/MazeGenerator.ts","pathfinding/algorithms/TerrainGeneratorBuilder.ts","view/grid/PathfindingVisualizer.tsx","view/utility/Checkbox.tsx","view/utility/SteppedRangeSlider.tsx","view/utility/RadioButtonGroup.tsx","view/navbar/SettingPanels.tsx","view/SettingsManager.ts","view/PathfindingSettings.ts","view/PathfindingApp.tsx","App.tsx","index.tsx"],"names":["TopBar","bar","React","createRef","window","addEventListener","props","onChangeHeight","current","offsetHeight","this","ref","className","children","Component","SYMBOL_COLOR","DIMENSION","VisualizeButton","width","height","rx","fill","points","x","active","onMouseDown","e","preventDefault","onClick","paused","onResume","onPause","xmlns","getResumeSymbol","getPauseSymbol","onStartStop","getStopSymbol","SettingsButton","AlgorithmDropDown","show","setState","up","display","hide","toggle","stopPropagation","isHidden","state","contentStyle","onChange","key","algText","arrowClass","fade","tabIndex","onKeyPress","nativeEvent","style","click","ClearDropDown","onClickPath","onClickTiles","onClickReset","MazeDropDown","onClickMaze","onClickMazeHorizontal","onClickMazeVertical","onClickRandomTerrain","Clickable","DraggablePanel","draggable","draggableContainer","draggableContent","dragging","prevX","prevY","mouseDown","clientY","clientX","mouseUp","mouseMove","container","top","offsetTop","left","offsetLeft","content","innerHeight","innerWidth","offsetWidth","getPosition","visibleStyle","renderDraggable","draggableStyle","title","onClickXButton","document","minHeight","ARROW_COLOR","GridBackground","visualization","arrows","clear","createEmptyBg","forceUpdate","doGeneration","generation","point","tile","y","visualizeGeneration","visualizeGenerations","generations","doArrowGeneration","point1","point2","newArrow","from","to","i","length","a","index","indexOf","splice","push","addArrowGeneration","addArrowGenerations","doUpdate","renderArrows","tileWidth","offset","arrow","first","second","firstX","firstY","secondX","secondY","offsetX","offsetY","x1","y1","x2","y2","stroke","strokeWidth","markerEnd","renderTiles","tiles","row","renderTile","color","backgroundColor","tilesX","tilesY","id","markerWidth","markerHeight","refX","refY","orient","createTile","isSolid","pathCost","GridGraph","grid","mutateDefault","solid","mutate","undefined","nodes","data","createEmptyGrid","inBounds","get","console","str","log","JSON","stringify","TileFg","applyExpandAnimation","original","tileSize","setTimeout","applyShrinkAnimation","size","doAnimation","shapeRendering","ARROW_PATH_COLOR","pointsEqual","GridForeground","svg","mouseDown0","mouseDown2","draggingInitial","draggingGoal","disable","doTileAnimation","bounds","getBoundingRect","onPress","button","onDrag","touchStart","touch","touches","changedTouches","onTouch","touchMove","onEndingEvent","xCoordinate","yCoordinate","calculatePoint","initial","goal","drawTile","eraseTile","moveInitial","moveGoal","drawGrid","clearTiles","onTilesDragged","drawPath","path","slice","erasePath","Math","floor","resetPoints","end","calcEndPointInView","renderPath","lines","renderPathArrow","renderEndTile","round","topMargin","getBoundingClientRect","onContextMenu","onMouseUp","onMouseMove","onMouseLeave","onTouchStart","onTouchMoveCapture","onTouchEnd","onTouchCancel","StatsPanel","textLog","scrollTop","scrollHeight","clientHeight","time","toFixed","text","algorithm","readOnly","value","unselectable","onDrop","Navigator","b","PlusNavigator","getWidth","getHeight","manhattan","abs","euclidean","dx","dy","sqrt","octile","SQRT2","min","chebyshev","max","nullHeuristic","AsteriskNavigator","walkBottomRight","walkTopRight","walkBottomLeft","walkTopLeft","HashSet","map","HashTable","Heap","compare","elements","siftUp","val","peek","move","pop","siftDown","pos","parent","swap","right","child","reconstructPath","bottomLeaf","reconstructPathReversed","reverse","Pathfinder","navigator","recentSearch","node","Node","AStarNode","g","fScore","AStarPathfinder","func","canRediscover","heuristic","isNewScoreBetter","newScore","oldScore","clearRecentSearch","getGrid","openFrontier","f","closedSet","openSet","root","add","isEmpty","currentNode","currentPoint","currentKey","remove","addRecent","equals","neighbors","neighbor","neighborPoint","neighborKey","has","stepCost","neighborNode","addChild","cost","BFSPathfinder","frontier","visited","shift","next","Stack","DFSPathfinder","BiAStarPathfinder","startOpenFrontier","startOpenSet","endOpenFrontier","endOpenSet","initialRoot","goalRoot","startCurrentNode","startCurrentPoint","startCurrentPointKey","concat","endCurrentNode","endCurrentPoint","endCurrentPointKey","BiBFSPathfinder","startVisited","endVisited","startFrontier","endFrontier","CREATE_NAVIGATOR","CREATE_HEURISTIC","CREATE_PATHFINDER","getType","PathfinderBuilder","toLowerCase","Error","createHeuristic","createNavigator","createPathfinder","VirtualTimer","callback","countDown","timeout","timeStarted","timeRemaining","finished","Date","now","clearTimeout","TerrainGenerator","ignore","shouldIgnore","mutateTile","RandomTerrainGenerator","topLeft","bottomRight","random","draw","divideWidthNoSkew","divideWidthHSkew","divideWidthVSkew","getMidPoint","range","mid","getRand","MazeGenerator","slant","divideWidth","divide","chamber","widthOf","heightOf","randX","toDraw","edgeBlocked","randY","drawArr","leftChamber","rightChamber","topChamber","bottomChamber","TerrainGeneratorBuilder","type","calcLength","len","PathfindingVisualizer","background","foreground","stats","visualized","visualizing","visualTimeouts","canShowArrows","settings","showArrows","canShowFrontier","visualizeAlg","pausePathfinding","pause","resumePathfinding","resume","jumpToGeneration","clearPath","doPathfinding","pathfinder","getPathfinder","findPath","getRecentGenerations","doDelayedPathfinding","clearVisualization","toggleDisable","onChangeVisualizing","promises","baseIncrement","delayInc","delay","expandVisualization","expandArrows","forEach","promise","Promise","resolve","all","then","algorithmKey","bidirectional","hasBidirectional","makeBidirectional","setAlgorithm","setHeuristic","heuristicKey","setNavigator","navigatorKey","build","t0","performance","t2","getRecentNodes","getAlgorithmName","unshift","createTerrain","mazeType","prevGrid","generator","setDimensions","setGeneratorType","setIgnorePoints","generateTerrain","xEnd","yEnd","xFloor","yFloor","yDecimal","ceil","clearTilesChecked","clearVisualizationChecked","w","screen","availWidth","h","availHeight","Checkbox","prevState","checked","defaultChecked","disabled","boxStyle","defaultProps","SteppedRangeSlider","Number","currentTarget","default","list","step","sliderStyle","onInput","RadioButtonGroup","Children","toArray","radioButtons","VisualSettings","onChangeViz","onChangeShowArrows","SpeedSettings","onChangeSpeed","speed","speedText","String","SPEED_INITIAL","options","AlgorithmSettings","onChangeDiagonals","onChangeBidirectional","HeuristicSettings","enable","onClickManhattan","onClickEuclidean","onClickChebyshev","onClickOctile","SettingsManager","changeAlgo","algo","changeVisualize","changeShowArrows","changeBidirectional","changeDiagonals","changeSpeed","changeManhattan","changeEuclidean","changeChebyshev","changeOctile","PathfindingApp","algDropDown","clrDropDown","mazeDropDown","settingsManager","onClickAlgDrop","onClickClrDrop","onClickMazeDrop","changeVButtonColor","toggleSettings","panelShow","hideSettings","heuristicDisabled","usesHeuristic","bidirectionalDisabled","arrowsDisabled","resetBoard","createMaze","createMazeVSkew","createMazeHSkew","createRandomTerrain","test","userAgent","href","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.3542d91b.chunk.js","sourcesContent":["import React, {RefObject} from 'react';\r\n\r\ninterface IProps {\r\n    onChangeHeight: (height: number) => void\r\n}\r\n\r\nclass TopBar extends React.Component<IProps>\r\n{\r\n    private bar: RefObject<HTMLDivElement> = React.createRef();\r\n\r\n    componentDidMount() {\r\n        window.addEventListener('resize', () => this.props.onChangeHeight(this.bar.current!.offsetHeight));\r\n        this.props.onChangeHeight(this.bar.current!.offsetHeight);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div ref={this.bar} className='top-navbar navbar-expand-sm top-navbar'>\r\n                {this.props.children}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default TopBar;","import React from 'react';\r\n\r\ninterface VProps {\r\n    active: boolean,\r\n    paused: boolean,\r\n    onStartStop: ()  => void,\r\n    onPause: ()  => void,\r\n    onResume: ()  => void,\r\n}\r\n\r\ninterface SProps {\r\n    onClick: ()  => void\r\n}\r\n\r\nconst SYMBOL_COLOR = 'rgb(230,230,230)';\r\nconst OFFSET = 14;\r\nconst DIMENSION = 47 - 2 * OFFSET;\r\n\r\nexport class VisualizeButton extends React.Component<VProps>\r\n{\r\n    getStopSymbol() {\r\n        return (\r\n            <rect width={DIMENSION}\r\n                  height={DIMENSION}\r\n                  rx={4}\r\n                  fill={SYMBOL_COLOR}\r\n            />\r\n        );\r\n    }\r\n\r\n    getResumeSymbol() {\r\n        const midY = DIMENSION / 2;\r\n        return (\r\n            <polygon\r\n                  points={`${0},${0} ${0},${DIMENSION} ${DIMENSION},${midY}`}\r\n                  className={'track round'}\r\n                  fill={SYMBOL_COLOR}\r\n            />\r\n        );\r\n    }\r\n\r\n    getPauseSymbol() {\r\n        return (\r\n            <svg>\r\n                <rect width={DIMENSION/2.5}\r\n                      height={DIMENSION}\r\n                      rx={3}\r\n                      fill={SYMBOL_COLOR}\r\n                />\r\n                <rect width={DIMENSION/2.5}\r\n                      height={DIMENSION}\r\n                      x={0.2*DIMENSION + DIMENSION/2.5}\r\n                      rx={3}\r\n                      fill={SYMBOL_COLOR}\r\n                />\r\n            </svg>\r\n        );\r\n    }\r\n\r\n    render() {\r\n        if(this.props.active) {\r\n            return (\r\n                <div className={'half-button-wrapper'}>\r\n                    <button onMouseDown={e => e.preventDefault()}\r\n                            className={'center half-button-left red-button half-viz-button'}\r\n                            onClick={this.props.paused ? this.props.onResume : this.props.onPause}\r\n                    >\r\n                        <svg xmlns='http://www.w3.org/2000/svg'\r\n                             className='svg-icon'\r\n                             width={DIMENSION}\r\n                             height={DIMENSION}\r\n                        >\r\n                            {this.props.paused ? this.getResumeSymbol() : this.getPauseSymbol()}\r\n                        </svg>\r\n                    </button>\r\n                    <button onMouseDown={e => e.preventDefault()}\r\n                            className={'center half-button-right red-button half-viz-button'}\r\n                            onClick={this.props.onStartStop}\r\n                    >\r\n                        <svg xmlns='http://www.w3.org/2000/svg'\r\n                             className='svg-icon'\r\n                             width={DIMENSION}\r\n                             height={DIMENSION}\r\n                        >\r\n                            {this.getStopSymbol()}\r\n                        </svg>\r\n                    </button>\r\n                </div>\r\n            );\r\n        } else {\r\n            return (\r\n                <button onMouseDown={e => e.preventDefault()}\r\n                        className={'button green-button viz-button'}\r\n                        onClick={this.props.onStartStop}\r\n                >\r\n                    Visualize!\r\n                </button>\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nexport class SettingsButton extends React.Component<SProps>\r\n{\r\n    render() {\r\n        return (\r\n            <button onMouseDown={e => e.preventDefault()}\r\n                    className='button settings-button'\r\n                    onClick={this.props.onClick}>\r\n                Settings\r\n            </button>\r\n        );\r\n    }\r\n}","import React from 'react';\r\n\r\ninterface AlgProps {\r\n    onClick: () => void,\r\n    onChange: (alg: string) => void\r\n}\r\n\r\ninterface AlgState {\r\n    up: boolean,\r\n    display: string,\r\n    algText: string,\r\n    fade: string\r\n}\r\n\r\ninterface ClrProps {\r\n    onClick: () => void,\r\n    onClickPath: () => void,\r\n    onClickTiles: () => void,\r\n    onClickReset: () => void;\r\n}\r\n\r\ninterface DState {\r\n    up: boolean,\r\n    display: string,\r\n    fade: string\r\n}\r\n\r\ninterface MazeProps {\r\n    onClick: () => void,\r\n    onClickMaze: () => void,\r\n    onClickMazeHorizontal: () => void,\r\n    onClickMazeVertical: () => void,\r\n    onClickRandomTerrain: () => void\r\n}\r\n\r\nexport class AlgorithmDropDown extends React.Component<AlgProps, AlgState>\r\n{\r\n    constructor(props: AlgProps) {\r\n        super(props);\r\n        this.state = {\r\n            up: true,\r\n            display: 'none',\r\n            algText: 'A* Search',\r\n            fade: 'fade-in'\r\n        };\r\n    }\r\n\r\n    show = () => {\r\n        this.setState({\r\n            up: false,\r\n            display: 'block',\r\n        });\r\n    }\r\n\r\n    hide = () => {\r\n        this.setState({\r\n            display: 'none',\r\n            up: true,\r\n        });\r\n    }\r\n\r\n    toggle = (e: Event) => {\r\n        e.stopPropagation();\r\n        this.props.onClick();\r\n        if(this.isHidden()) {\r\n            this.show();\r\n        } else {\r\n            this.hide();\r\n        }\r\n    }\r\n\r\n    isHidden = () => {\r\n        return this.state.display === 'none';\r\n    }\r\n\r\n    contentStyle = () => {\r\n        return {\r\n            display: this.state.display\r\n        }\r\n    }\r\n\r\n    onChange = (key: string, algText: string) => {\r\n        this.props.onChange(key);\r\n        this.setState({\r\n            algText: algText\r\n        });\r\n    }\r\n\r\n    arrowClass = () => {\r\n        return this.state.up ? 'arrowUp' : 'arrowDown';\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div tabIndex={0} className='alg-drop-down drop-down'\r\n                 onMouseDown={e => e.preventDefault()}\r\n                 onKeyPress={(e) => this.toggle(e.nativeEvent)}\r\n                 onClick={(e) => this.toggle(e.nativeEvent)}\r\n            >\r\n                <div className='alg-drop-down-button drop-down-button'>\r\n                    <span className='alg-drop-down-text drop-down-text'>{this.state.algText}</span>\r\n                    <span className={'alg-arr ' + this.arrowClass()}/>\r\n                </div>\r\n                <div style={this.contentStyle()}\r\n                     className={this.state.fade + ' alg-drop-down-content drop-down-content'}\r\n                >\r\n                    <Clickable click={() => this.onChange('a*', 'A* Search')}>A* Search</Clickable>\r\n                    <Clickable click={() => this.onChange('dijkstra', 'Dijkstra')}>Dijkstra's Algorithm</Clickable>\r\n                    <Clickable click={() => this.onChange('best-first', 'Best First')}>Best First Search</Clickable>\r\n                    <Clickable click={() => this.onChange('bfs', 'Breadth First')}>Breadth First Search</Clickable>\r\n                    <Clickable click={() => this.onChange('dfs', 'Depth First')}>Depth First Search</Clickable>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class ClearDropDown extends React.Component<ClrProps, DState>\r\n{\r\n    constructor(props: ClrProps) {\r\n        super(props);\r\n        this.state = {\r\n            up: true,\r\n            display: 'none',\r\n            fade: 'fade-in'\r\n        };\r\n    }\r\n\r\n    show = () => {\r\n        this.setState({\r\n            up: false,\r\n            display: 'block',\r\n        });\r\n    }\r\n\r\n    hide = () => {\r\n        this.setState({\r\n            display: 'none',\r\n            up: true,\r\n        });\r\n    }\r\n\r\n    toggle = (e: Event) => {\r\n        e.stopPropagation();\r\n        this.props.onClick();\r\n        if(this.isHidden()) {\r\n            this.show();\r\n        } else {\r\n            this.hide();\r\n        }\r\n    }\r\n\r\n    isHidden = () => {\r\n        return this.state.display === 'none';\r\n    }\r\n\r\n    contentStyle = () => {\r\n        return {\r\n            display: this.state.display\r\n        }\r\n    }\r\n\r\n    arrowClass = () => {\r\n        return this.state.up ? 'arrowUpW' : 'arrowDownW';\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div tabIndex={0} className='clr-drop-down drop-down'\r\n                 onMouseDown={e => e.preventDefault()}\r\n                 onKeyPress={(e) => this.toggle(e.nativeEvent)}\r\n                 onClick={(e) => this.toggle(e.nativeEvent)}\r\n            >\r\n                <div className='clr-drop-down-button drop-down-button'>\r\n                    <span className='clr-drop-down-text drop-down-text'>Reset</span>\r\n                    <span className={'clr-arr ' + this.arrowClass()}/>\r\n                </div>\r\n                <div style={this.contentStyle()}\r\n                     className={this.state.fade + ' clr-drop-down-content drop-down-content'}\r\n                >\r\n                    <Clickable click={this.props.onClickPath}>Clear Path</Clickable>\r\n                    <Clickable click={this.props.onClickTiles}>Clear Tiles</Clickable>\r\n                    <Clickable click={this.props.onClickReset}>Reset Grid</Clickable>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class MazeDropDown extends React.Component<MazeProps, DState>\r\n{\r\n    constructor(props: MazeProps) {\r\n        super(props);\r\n        this.state = {\r\n            up: true,\r\n            display: 'none',\r\n            fade: 'fade-in'\r\n        };\r\n    }\r\n\r\n    show = () => {\r\n        this.setState({\r\n            up: false,\r\n            display: 'block',\r\n        });\r\n    }\r\n\r\n    hide = () => {\r\n        this.setState({\r\n            display: 'none',\r\n            up: true,\r\n        });\r\n    }\r\n\r\n    toggle = (e: Event) => {\r\n        e.stopPropagation();\r\n        this.props.onClick();\r\n        if(this.isHidden()) {\r\n            this.show();\r\n        } else {\r\n            this.hide();\r\n        }\r\n    }\r\n\r\n    isHidden = () => {\r\n        return this.state.display === 'none';\r\n    }\r\n\r\n    contentStyle = () => {\r\n        return {\r\n            display: this.state.display\r\n        }\r\n    }\r\n\r\n    arrowClass = () => {\r\n        return this.state.up ? 'arrowUpW' : 'arrowDownW';\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div tabIndex={0} className='maze-drop-down drop-down'\r\n                 onMouseDown={e => e.preventDefault()}\r\n                 onKeyPress={(e) => this.toggle(e.nativeEvent)}\r\n                 onClick={(e) => this.toggle(e.nativeEvent)}\r\n            >\r\n                <div className='maze-drop-down-button drop-down-button'>\r\n                    <span className='maze-drop-down-text drop-down-text'>Terrain</span>\r\n                    <span className={'clr-arr ' + this.arrowClass()}/>\r\n                </div>\r\n                <div style={this.contentStyle()}\r\n                     className={this.state.fade + ' maze-drop-down-content drop-down-content'}\r\n                >\r\n                    <Clickable click={this.props.onClickMaze}>Recursive Maze Division</Clickable>\r\n                    <Clickable click={this.props.onClickMazeHorizontal}>Horizontal Skewed Maze</Clickable>\r\n                    <Clickable click={this.props.onClickMazeVertical}>Vertical Skewed Maze</Clickable>\r\n                    <Clickable click={this.props.onClickRandomTerrain}>Random Terrain</Clickable>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\ninterface ClickableProps {\r\n    click: () => void;\r\n}\r\n\r\nclass Clickable extends React.Component<ClickableProps>\r\n{\r\n    render() {\r\n        return (\r\n            <div tabIndex={0} onKeyPress={this.props.click} onClick={this.props.click}>{this.props.children}</div>\r\n        )\r\n    }\r\n}","import React, {RefObject} from 'react';\r\n\r\ninterface IProps {\r\n    title: string,\r\n    show: boolean,\r\n    onClickXButton: () => void,\r\n    width: number,\r\n    height: number\r\n}\r\n\r\ninterface IState {\r\n    top: number,\r\n    left: number,\r\n}\r\n\r\nclass DraggablePanel extends React.Component<IProps, IState>\r\n{\r\n    //refs are used to access native DOM\r\n    private draggable: RefObject<HTMLDivElement> = React.createRef();\r\n    private draggableContainer: RefObject<HTMLDivElement> = React.createRef();\r\n    private draggableContent: RefObject<HTMLDivElement> = React.createRef();\r\n\r\n    //stores previous mouse location and drag\r\n    private dragging = false;\r\n    private prevX = 0;\r\n    private prevY = 0;\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.state = {\r\n            top: -1,\r\n            left: -1,\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        document.addEventListener('mouseup', e => {\r\n            this.mouseUp(e);\r\n        });\r\n        document.addEventListener('mousemove', e => {\r\n            this.mouseMove(e);\r\n        });\r\n        window.addEventListener('mouseleave', e => {\r\n            this.mouseUp(e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Start drag and init prev mouse location when mouse is clicked on draggable\r\n     * @param e\r\n     */\r\n    private mouseDown = (e: MouseEvent) => {\r\n        e.preventDefault();\r\n        this.prevY = e.clientY;\r\n        this.prevX = e.clientX;\r\n        this.dragging = true;\r\n    }\r\n\r\n    /**\r\n     * Called when mouse is risen on document stop drag\r\n     * @param e\r\n     */\r\n    private mouseUp = (e: MouseEvent) => {\r\n        e.preventDefault();\r\n        this.dragging = false;\r\n    }\r\n\r\n    /**\r\n     * Called when the mouse is moved over the document to calculate the new position of\r\n     * the draggable canvas\r\n     * @param e\r\n     */\r\n    private mouseMove = (e: MouseEvent) => {\r\n        if(this.dragging) {\r\n            const container = this.draggableContainer.current!;\r\n            let top = (container.offsetTop - (this.prevY - e.clientY))\r\n            let left = (container.offsetLeft - (this.prevX - e.clientX));\r\n            const content = this.draggableContent.current!;\r\n            const draggable = this.draggable.current!;\r\n            //stop drag if mouse goes out of bounds\r\n            if(e.clientY < 0 || e.clientY > window.innerHeight\r\n                    || e.clientX < 0 || e.clientX > window.innerWidth) {\r\n                this.dragging = false;\r\n            }\r\n            //check if position is out of bounds and prevent the panel from being dragged there\r\n            if(top < 0) {\r\n                top = 0;\r\n            } else if (top > window.innerHeight - draggable.offsetHeight) {\r\n                top = window.innerHeight - draggable.offsetHeight;\r\n            }\r\n            if(left < -content.offsetWidth/2) {\r\n                left = -content.offsetWidth/2;\r\n            } else if(left > window.innerWidth - content.offsetWidth/2) {\r\n                left = window.innerWidth - content.offsetWidth/2;\r\n            }\r\n            //set new position\r\n            this.setState({\r\n                top: top\r\n            });\r\n            this.setState({\r\n                left: left\r\n            });\r\n            //update previous pos\r\n            this.prevY = e.clientY;\r\n            this.prevX = e.clientX;\r\n        }\r\n    }\r\n\r\n    getPosition = () => {\r\n        const left = this.state.left;\r\n        const top = this.state.top;\r\n        if(left === -1 || top === -1) {\r\n            return {};\r\n        }\r\n        return {\r\n            left: left + 'px',\r\n            top: top + 'px',\r\n        };\r\n    }\r\n\r\n    visibleStyle = () => {\r\n        return this.props.show ? 'block' : 'none';\r\n    }\r\n\r\n    draggableStyle() {\r\n        return {\r\n            width: this.props.width,\r\n            display: this.visibleStyle()\r\n        }\r\n    }\r\n\r\n    contentStyle() {\r\n        return {\r\n            width: this.props.width,\r\n            minHeight: this.props.height,\r\n            display: this.visibleStyle()\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div ref={this.draggableContainer} className='draggable-container' style={this.getPosition()}>\r\n                {this.renderDraggable()}\r\n                <div ref={this.draggableContent} style={this.contentStyle()} className='draggable-content'>\r\n                    <div className='settings-general'>\r\n                        {this.props.children}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    private renderDraggable = () => {\r\n        return (\r\n            <div style={this.draggableStyle()} className='draggable'\r\n                 ref={this.draggable}\r\n                 onMouseDown={e => this.mouseDown(e.nativeEvent)}\r\n            >\r\n                <div className='draggable-title'>{this.props.title}</div>\r\n                <div className='x-button' onClick={this.props.onClickXButton}>X</div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default DraggablePanel;","import React from 'react';\r\nimport {Node} from '../../pathfinding/algorithms/Node';\r\nimport {Point} from '../../pathfinding/core/Components';\r\n\r\ninterface Arrow {\r\n    to: Point,\r\n    from: Point\r\n}\r\n\r\ninterface IProps {\r\n    tileWidth: number,\r\n    tilesX: number,\r\n    tilesY: number\r\n}\r\n\r\nconst CLOSED_NODE = 'rgb(198, 237, 238)';\r\nconst OPEN_NODE = 'rgb(191, 248, 159)';\r\nconst EMPTY_NODE = 'white';\r\nconst ARROW_COLOR = 'rgb(153,153,153)';\r\n\r\nconst BASE_WIDTH = 27;\r\n\r\nclass GridBackground extends React.Component<IProps>\r\n{\r\n    /**\r\n     * Represents the state of the component\r\n     * Stored outside of State to prevent copies, allowing\r\n     * updates with forceUpdate to improve App performance\r\n     */\r\n    private visualization: string[][];\r\n    private arrows: Arrow[];\r\n\r\n    private readonly width: number;\r\n    private readonly height: number;\r\n\r\n    /**\r\n     * Constructs a GridBackground with immutable height and width\r\n     * @param props\r\n     */\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.width = this.props.tilesX;\r\n        this.height = this.props.tilesY;\r\n        this.visualization = this.createEmptyBg();\r\n        this.arrows = []\r\n    }\r\n\r\n    /**\r\n     * Create a new empty visualization canvas\r\n     */\r\n    createEmptyBg() {\r\n        const visualization = [];\r\n        for(let y = 0; y < this.height; y++) {\r\n            const row: string[] = [];\r\n            for(let x = 0; x < this.width; x++) {\r\n                row.push(EMPTY_NODE);\r\n            }\r\n            visualization.push(row);\r\n        }\r\n        return visualization;\r\n    }\r\n\r\n    /**\r\n     * Clear the visualization canvas and update UI\r\n     */\r\n    clear = () => {\r\n        this.visualization = this.createEmptyBg();\r\n        this.arrows = [];\r\n        this.forceUpdate();\r\n    }\r\n\r\n    /**\r\n     * Perform a generation on a visualization array\r\n     * @param generation\r\n     * @param visualization\r\n     */\r\n    private doGeneration = (generation: Node, visualization: string[][]) => {\r\n        //modify state directly to improve performance\r\n        for(const node of generation.children) {\r\n            const point = node.tile.point;\r\n            visualization[point.y][point.x] = OPEN_NODE;\r\n        }\r\n        const point = generation.tile.point;\r\n        visualization[point.y][point.x] = CLOSED_NODE;\r\n        return visualization;\r\n    }\r\n\r\n    /**\r\n     * Visualize generation without updating UI\r\n     * @param generation\r\n     */\r\n    visualizeGeneration = (generation: Node) => {\r\n        this.doGeneration(generation, this.visualization);\r\n    }\r\n\r\n    /**\r\n     * Visualize generation array and update UI\r\n     * @param generations\r\n     */\r\n    visualizeGenerations = (generations: Node[]) => {\r\n        const visualization = this.createEmptyBg();\r\n        for(const generation of generations) {\r\n            this.doGeneration(generation, visualization);\r\n        }\r\n        this.visualization = visualization;\r\n        this.forceUpdate();\r\n    }\r\n\r\n    /**\r\n     * Perform an arrow generation\r\n     * @param generation\r\n     */\r\n    private doArrowGeneration = (generation: Node) => {\r\n        //modify state directly to improve performance\r\n        const point = generation.tile.point;\r\n        for(const node of generation.children) {\r\n            const childPoint = node.tile.point;\r\n            const newArrow = {\r\n                from: point,\r\n                to: childPoint,\r\n            };\r\n            //remove a duplicate arrow to indicate replacement\r\n            //in A* for example, we could have re-discovered a better path to a tile\r\n            for(let i = 0; i < this.arrows.length; i++) {\r\n                const a = this.arrows[i];\r\n                if(pointsEqual(a.to, newArrow.to)) {\r\n                    const index = this.arrows.indexOf(a);\r\n                    this.arrows.splice(index, 1);\r\n                    i--;\r\n                }\r\n            }\r\n            this.arrows.push(newArrow);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add arrow generation without updating UI\r\n     * @param generation\r\n     */\r\n    addArrowGeneration = (generation: Node) => {\r\n        this.doArrowGeneration(generation);\r\n    }\r\n\r\n    /**\r\n     * Add arrow generations and update UI\r\n     * @param generations\r\n     */\r\n    addArrowGenerations = (generations: Node[]) => {\r\n        this.arrows = [];\r\n        for(const generation of generations) {\r\n            this.doArrowGeneration(generation)\r\n        }\r\n        this.forceUpdate();\r\n    }\r\n\r\n    /**\r\n     * Should be called to update render and state when enough generations\r\n     * have been added\r\n     */\r\n    doUpdate = () => {\r\n        this.forceUpdate();\r\n    }\r\n\r\n    render() {\r\n        // console.timeEnd('time');\r\n        // console.time('time');\r\n        return (\r\n            <div>\r\n                <div className='bg'>\r\n                    {this.renderTiles()}\r\n                </div>\r\n                <svg xmlns='http://www.w3.org/2000/svg' className='grid'>\r\n                    <defs>\r\n                        <marker id='arrowhead' markerWidth='3' markerHeight='3'\r\n                                refX='0' refY='1.5' orient='auto'\r\n                                fill={ARROW_COLOR}\r\n                        >\r\n                            <polygon points='0 0, 3 1.5, 0 3'/>\r\n                        </marker>\r\n                    </defs>\r\n                    {this.renderArrows()}\r\n                </svg>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    private renderArrows = () => {\r\n        const width = this.props.tileWidth;\r\n        const offset = width/2;\r\n        const arrows: JSX.Element[] = [];\r\n        for(let i = 0; i < this.arrows.length; i++) {\r\n            //calculate arrow position and dimensions\r\n            const arrow = this.arrows[i];\r\n            const first = arrow.from;\r\n            const second = arrow.to;\r\n            const firstX = first.x * width;\r\n            const firstY = first.y * width;\r\n            const secondX = second.x * width;\r\n            const secondY = second.y * width;\r\n            const offsetX = (secondX - firstX)/4;\r\n            const offsetY = (secondY - firstY)/4;\r\n            arrows.push(<line key={'arrow ' + i}\r\n                              x1={firstX + offset + offsetX}\r\n                              y1={firstY + offset + offsetY}\r\n                              x2={secondX + offset - offsetX}\r\n                              y2={secondY + offset - offsetY}\r\n                              stroke={ARROW_COLOR}\r\n                              strokeWidth={2 * this.props.tileWidth/BASE_WIDTH}\r\n                              className='line-arrow'\r\n                              markerEnd='url(#arrowhead)' />);\r\n        }\r\n        return arrows;\r\n    }\r\n\r\n    private renderTiles = () => {\r\n        const tiles: JSX.Element[][] = [];\r\n        for(let y = 0; y < this.height; y++) {\r\n            const row: JSX.Element[] = [];\r\n            for(let x = 0; x < this.width; x++) {\r\n                const point = {\r\n                    x: x, y: y\r\n                };\r\n                row.push(\r\n                    this.renderTile(point, this.visualization[point.y][point.x])\r\n                );\r\n            }\r\n            tiles.push(row);\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    private renderTile = (point: Point, color: string) => {\r\n        const width = this.props.tileWidth;\r\n        const top = point.y * this.props.tileWidth;\r\n        const left = point.x * this.props.tileWidth;\r\n        const style = {\r\n            backgroundColor: color,\r\n            width: width + 'px',\r\n            height: width + 'px',\r\n            top: top,\r\n            left: left\r\n        };\r\n        return (\r\n            <div key={point.x + ',' + point.y} style={style} className='tile'/>\r\n        );\r\n    }\r\n}\r\n\r\nfunction pointsEqual(point1: Point, point2: Point) {\r\n    return point1.x === point2.x && point1.y === point2.y;\r\n}\r\n\r\nexport default GridBackground;","/**\r\n * Represents a point in 2d space\r\n */\r\nexport interface Point\r\n{\r\n    readonly x: number;\r\n    readonly y: number;\r\n}\r\n\r\n/**\r\n * Represents the data inside a tile\r\n * Solid tiles cannot be passed while non solid ones can\r\n * pathCost stores how expensive it is to travel to the tile if it isn't solid\r\n */\r\nexport interface TileData\r\n{\r\n    readonly pathCost: number;\r\n    readonly isSolid: boolean;\r\n}\r\n\r\n/**\r\n * Represents a tile on the Grid\r\n */\r\nexport interface Tile\r\n{\r\n    data: TileData;\r\n    readonly point: Point;\r\n}\r\n\r\n/**\r\n * Simple function to create a solid tile with path cost of 1\r\n * @param isSolid\r\n */\r\nexport function createTile(isSolid: boolean) {\r\n    return {\r\n        pathCost: 1,\r\n        isSolid: isSolid\r\n    }\r\n}\r\n\r\n","import {createTile, Point, Tile, TileData} from './Components';\r\n\r\nexport interface Grid\r\n{\r\n    getWidth(): number;\r\n    getHeight(): number;\r\n    inBounds(point: Point): boolean;\r\n    get(point: Point): Tile;\r\n    isSolid(point: Point): boolean;\r\n    mutate(point: Point, data: TileData): void;\r\n    mutateTile(tile: Tile): void;\r\n    mutateDefault(point: Point, solid: boolean): void;\r\n    output(console: Console): void;\r\n    getJson(): string;\r\n    walkable(point: Point): boolean;\r\n    clone(): Grid;\r\n}\r\n\r\n/**\r\n * A square grid system that stores nodes in a matrix\r\n * Uses an x,y system where x corresponds to column of the matrix,\r\n * and y corresponds to the row of the matrix\r\n * TileData.ts should be treated like graph nodes\r\n */\r\nclass GridGraph implements Grid\r\n{\r\n    private readonly tiles: Tile[][];\r\n    private readonly width: number;\r\n    private readonly height: number;\r\n\r\n    /**\r\n     * Constructs a grid either with empty or predefined tiles\r\n     * @param width of the grid\r\n     * @param height of grid\r\n     * will perform a defensive copy to the grid\r\n     * @param grid, optional parameter to copy tiles from that grid to\r\n     * this grid\r\n     */\r\n    constructor(width: number, height: number, grid?: Grid) {\r\n        this.width = width;\r\n        this.height = height;\r\n        if(grid === undefined) {\r\n            this.tiles = createEmptyGrid(width, height);\r\n        } else {\r\n            this.tiles = [];\r\n            for(let y = 0; y < height; y++) {\r\n                const row: Tile[] = [];\r\n                for(let x = 0; x < width; x++) {\r\n                    const point = {\r\n                        x: x, y: y\r\n                    }\r\n                    const inBounds = grid.inBounds(point);\r\n                    row.push({\r\n                        data: {\r\n                            pathCost: inBounds ? grid.get(point).data.pathCost : 1,\r\n                            isSolid: inBounds ? grid.get(point).data.isSolid : false\r\n                        },\r\n                        point: {\r\n                            x: x, y: y\r\n                        }\r\n                    });\r\n                }\r\n               this.tiles.push(row);\r\n            }\r\n        }\r\n    }\r\n\r\n    getWidth() {\r\n        return this.width;\r\n    }\r\n\r\n    getHeight() {\r\n        return this.height;\r\n    }\r\n\r\n    /**\r\n     * Checks if a given point is in bounds\r\n     * Other functions assume arguments are in bounds, this should be used\r\n     * if there is reasonable doubt about whether a point is in bounds\r\n     * @param point, to check\r\n     */\r\n    inBounds(point: Point) {\r\n        return point.x >= 0 && point.x < this.width && point.y >= 0 && point.y < this.height;\r\n    }\r\n\r\n    /**\r\n     * Retrieves a defensive tile for a position\r\n     * Defensive copy prevents this object from being mutated without calling\r\n     * a mutate function\r\n     * @param point, point to get\r\n     */\r\n    get(point: Point) {\r\n        return {\r\n            point: this.tiles[point.y][point.x].point,\r\n            data: this.tiles[point.y][point.x].data\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Mutates a position's tile to solid or non solid\r\n     * @param point, point to mutate\r\n     * @param data to mutate to\r\n     */\r\n    mutate(point: Point, data: TileData) {\r\n        this.tiles[point.y][point.x].data = data;\r\n    }\r\n\r\n    /**\r\n     * Mutates a a tile by point\r\n     * @param tile to mutate\r\n     */\r\n    mutateTile(tile: Tile) {\r\n        this.tiles[tile.point.y][tile.point.x].data = tile.data;\r\n    }\r\n\r\n    /**\r\n     * Mutate tile at point\r\n     * @param point to mutate at\r\n     * @param solid to determine what default tile to create\r\n     */\r\n    mutateDefault = (point: Point, solid: boolean) => {\r\n        this.mutate(\r\n            point, createTile(solid)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Outputs the grid to a console\r\n     * @param console\r\n     */\r\n    output(console: Console) {\r\n        for(let y = 0; y < this.height; y++) {\r\n            let str = '';\r\n            for(let x = 0; x < this.width; x++) {\r\n                str += this.tiles[y][x].data.isSolid + ', ';\r\n            }\r\n            console.log(str);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns json of tiles\r\n     */\r\n    getJson() {\r\n        return JSON.stringify(this.tiles);\r\n    }\r\n\r\n    /**\r\n     * Determines if a tile can be walked on\r\n     * @param point\r\n     */\r\n    walkable(point: Point) {\r\n        return !this.get(point).data.isSolid;\r\n    }\r\n\r\n    isSolid(point: Point): boolean {\r\n        return this.get(point).data.isSolid;\r\n    }\r\n\r\n    clone(): Grid {\r\n        return new GridGraph(this.width, this.height, this);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a 2d matrix of empty nodes\r\n */\r\nfunction createEmptyGrid(width: number, height: number) {\r\n    const nodes: Tile[][] = [];\r\n    for(let y = 0; y < height; y++) {\r\n        const row: Tile[] = [];\r\n        for(let x = 0; x < width; x++) {\r\n            row.push({\r\n                point: {\r\n                    x: x, y: y\r\n                },\r\n                data: createTile(false)\r\n            });\r\n        }\r\n        nodes.push(row);\r\n    }\r\n    return nodes;\r\n}\r\n\r\nexport default GridGraph;","import React from 'react';\r\nimport {Point} from '../../pathfinding/core/Components';\r\n\r\ninterface IProps {\r\n    tileWidth: number,\r\n    point: Point,\r\n    color: string,\r\n    doAnimation: boolean\r\n}\r\n\r\ninterface IState {\r\n    tileSize: number\r\n}\r\n\r\nclass TileFg extends React.Component<IProps, IState>\r\n{\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        const size = this.props.doAnimation ?  0 : this.props.tileWidth;\r\n        this.state = {\r\n            tileSize: size,\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n        if(this.props.doAnimation) {\r\n            this.applyExpandAnimation();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Animation to expand element from half size to full size over a few milliseconds\r\n     * Can be slow to execute so animations should be enabled with caution\r\n     */\r\n    applyExpandAnimation = () => {\r\n        const total = 5\r\n        const original = this.state.tileSize;\r\n        for(let i = 1; i <= total; i++) {\r\n            const expand = () => this.setState({\r\n                tileSize: original + i * (this.props.tileWidth/(total))\r\n            });\r\n            setTimeout(expand, i*10);\r\n        }\r\n    }\r\n\r\n    applyShrinkAnimation = () => {\r\n        const total = 5\r\n        const original = this.state.tileSize;\r\n        for(let i = 1; i <= total; i++) {\r\n            const expand = () => this.setState({\r\n                tileSize: original - i * (this.props.tileWidth/(total))\r\n            });\r\n            setTimeout(expand, i*10);\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const width = this.state.tileSize;\r\n        const top = this.props.point.y * this.props.tileWidth + (this.props.tileWidth - width)/2;\r\n        const left = this.props.point.x * this.props.tileWidth + (this.props.tileWidth - width)/2;\r\n        const style = {\r\n            fill: this.props.color,\r\n            stroke: 'none',\r\n            display: 'block'\r\n        };\r\n        return (\r\n            <rect x={left} y={top}\r\n                  shapeRendering='crispEdges'\r\n                  width={width} height={width}\r\n                  style={style} className={'tile svg-tile'}\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nexport default TileFg;","import React, {RefObject} from 'react';\r\nimport {Point, Tile} from '../../pathfinding/core/Components';\r\nimport GridGraph, {Grid} from '../../pathfinding/core/Grid';\r\nimport TileFg from './TileFg';\r\n\r\ninterface IProps {\r\n    tileWidth: number,\r\n    tilesX: number,\r\n    tilesY: number,\r\n    onTilesDragged: () => void,\r\n    topMargin: number,\r\n}\r\n\r\ninterface IState {\r\n    grid: Grid,\r\n    initial: Point,\r\n    goal: Point,\r\n    path: Tile[]\r\n}\r\n\r\nconst SOLID_COLOR = 'rgb(45, 48, 54)';\r\nconst INITIAL_COLOR = 'rgb(131, 217, 52)';\r\nconst GOAL_COLOR = 'rgb(203, 75, 14)';\r\nconst ARROW_PATH_COLOR = 'rgb(73, 79, 250)';\r\n\r\nconst BASE_WIDTH = 27;\r\n\r\nclass GridForeground extends React.Component<IProps,IState>\r\n{\r\n    private svg: RefObject<SVGSVGElement> = React.createRef();\r\n\r\n    private mouseDown0: boolean = false;\r\n    private mouseDown2: boolean = false;\r\n    private draggingInitial: boolean = false;\r\n    private draggingGoal: boolean = false;\r\n    private disable: boolean = false;\r\n\r\n    private doTileAnimation: boolean = true;\r\n\r\n    private readonly width: number;\r\n    private readonly height: number;\r\n\r\n    /**\r\n     * Constructs a GridForeground with immutable height and width\r\n     * @param props\r\n     */\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.width = this.props.tilesX;\r\n        this.height = this.props.tilesY;\r\n        const end = this.calcEndPointInView();\r\n        this.state = {\r\n            grid: new GridGraph(this.width, this.height),\r\n            path: [],\r\n            initial: {\r\n                x: ((end.x)/3) >> 0,\r\n                y: ((end.y)/3) >> 0\r\n            },\r\n            goal: {\r\n                x: ((2*(end.x)/3) >> 0) - 1,\r\n                y: ((2*(end.y)/3) >> 0) - 1\r\n            }\r\n        }\r\n    }\r\n\r\n    calcEndPointInView() {\r\n        const xEnd = Math.round(window.innerWidth / this.props.tileWidth);\r\n        const yEnd = Math.round((window.innerHeight - this.props.topMargin - 30) / this.props.tileWidth);\r\n        return {\r\n            x: xEnd, y: yEnd\r\n        }\r\n    }\r\n\r\n    toggleDisable() {\r\n        this.disable = !this.disable;\r\n    }\r\n\r\n    getBoundingRect() {\r\n        return this.svg.current!.getBoundingClientRect();\r\n    }\r\n\r\n    private mouseDown = (e: MouseEvent) => {\r\n        e.preventDefault();\r\n        const bounds = this.getBoundingRect();\r\n        this.onPress(e.clientX - bounds.left, e.clientY - bounds.top, e.button);\r\n    }\r\n\r\n    private mouseUp = (e: MouseEvent) => {\r\n        e.preventDefault();\r\n        if(e.button === 0) {\r\n            this.draggingGoal = false;\r\n            this.draggingInitial = false;\r\n            this.mouseDown0 = false;\r\n        } else if(e.button === 2) {\r\n            this.mouseDown2 = false;\r\n        }\r\n    }\r\n\r\n    private mouseMove = (e: MouseEvent) => {\r\n        const bounds = this.getBoundingRect();\r\n        this.onDrag(e.clientX - bounds.left, e.clientY - bounds.top);\r\n    }\r\n\r\n    private touchStart = (e: TouchEvent) => {\r\n        const touch = e.touches[0] || e.changedTouches[0];\r\n        const bounds = this.getBoundingRect();\r\n        this.onTouch(touch.clientX - bounds.left, touch.clientY - bounds.top);\r\n    }\r\n\r\n    private touchMove = (e: TouchEvent) => {\r\n        const touch = e.touches[0] || e.changedTouches[0];\r\n        const bounds = this.getBoundingRect();\r\n        this.onDrag(touch.clientX - bounds.left, touch.clientY - bounds.top);\r\n    }\r\n\r\n    private onEndingEvent = (e: Event) => {\r\n        e.preventDefault();\r\n        this.draggingGoal = false;\r\n        this.draggingInitial = false;\r\n        this.mouseDown0 = false;\r\n        this.mouseDown2 = false;\r\n    }\r\n\r\n    /**\r\n     * Responds to the event thrown at screen coordinates on press\r\n     * @param xCoordinate\r\n     * @param yCoordinate\r\n     * @param button\r\n     */\r\n    private onPress = (xCoordinate: number, yCoordinate: number, button: number) => {\r\n        const point = this.calculatePoint(xCoordinate,yCoordinate);\r\n        if(button === 0) {\r\n            this.mouseDown0 = true;\r\n            if(pointsEqual(point, this.state.initial)) {\r\n                this.draggingInitial = true;\r\n            } else if(pointsEqual(point, this.state.goal)) {\r\n                this.draggingGoal = true;\r\n            } else if(!this.disable) {\r\n                this.drawTile(point);\r\n            }\r\n        } else if(button === 2) {\r\n            this.mouseDown2 = true;\r\n            if(!pointsEqual(point,this.state.initial) && !pointsEqual(point, this.state.goal) && !this.disable) {\r\n                this.eraseTile(point);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Responds to the event thrown at screen coordinates on touch\r\n     * @param xCoordinate\r\n     * @param yCoordinate\r\n     */\r\n    private onTouch = (xCoordinate: number, yCoordinate: number) => {\r\n        const point = this.calculatePoint(xCoordinate,yCoordinate);\r\n        if(pointsEqual(point, this.state.initial)) {\r\n            this.mouseDown0 = true;\r\n            this.draggingInitial = true;\r\n        } else if(pointsEqual(point, this.state.goal)) {\r\n            this.mouseDown0 = true;\r\n            this.draggingGoal = true;\r\n        } else if(!this.state.grid.isSolid(point)) {\r\n            this.mouseDown0 = true;\r\n            if(!this.disable) {\r\n                this.drawTile(point);\r\n            }\r\n        } else {\r\n            this.mouseDown2 = true;\r\n            if(!pointsEqual(point, this.state.initial) && !pointsEqual(point, this.state.goal) && !this.disable) {\r\n                this.eraseTile(point);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Responds to the event thrown at screen coordinates on drag/move\r\n     * @param xCoordinate\r\n     * @param yCoordinate\r\n     */\r\n    private onDrag = (xCoordinate: number, yCoordinate: number) => {\r\n        const point = this.calculatePoint(xCoordinate,yCoordinate);\r\n        if(this.mouseDown0) {\r\n            if(this.draggingInitial) {\r\n                this.moveInitial(point);\r\n            } else if(this.draggingGoal) {\r\n                this.moveGoal(point);\r\n            } else if(!pointsEqual(point,this.state.initial) && !pointsEqual(point, this.state.goal) && !this.disable) {\r\n                this.drawTile(point);\r\n            }\r\n        } else if(this.mouseDown2) {\r\n            if(!pointsEqual(point, this.state.initial) && !pointsEqual(point, this.state.goal) && !this.disable) {\r\n                this.eraseTile(point);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw an entire new grid on the foreground with disabled animations\r\n     * @param grid\r\n     */\r\n    drawGrid = (grid: Grid) => {\r\n        this.doTileAnimation = false;\r\n        this.setState({\r\n            grid: grid\r\n        }, () => this.doTileAnimation = true)\r\n    }\r\n\r\n    /**\r\n     * Draw tile at point\r\n     * @param point\r\n     */\r\n    drawTile = (point: Point) => {\r\n        const grid = this.state.grid;\r\n        if(grid.inBounds(point)) {\r\n            grid.mutateDefault(point, true);\r\n        }\r\n        this.forceUpdate();\r\n    }\r\n\r\n    /**\r\n     * Checks if a node is visualized, then changes the tile to empty if it isn't\r\n     * @param point\r\n     */\r\n    eraseTile = (point: Point) => {\r\n        const grid = this.state.grid;\r\n        if(grid.inBounds(point)) {\r\n            grid.mutateDefault(point, false);\r\n        }\r\n        this.forceUpdate();\r\n    }\r\n\r\n    /**\r\n     * Clear grid in state\r\n     */\r\n    clearTiles = () => {\r\n        const grid = this.state.grid;\r\n        for(let y = 0; y < this.height; y++) {\r\n            for(let x = 0; x < this.width; x++) {\r\n                const point = {\r\n                    x: x, y: y\r\n                }\r\n                grid.mutateDefault(point, false);\r\n            }\r\n        }\r\n        this.forceUpdate();\r\n    }\r\n\r\n    /**\r\n     * Moves initial to a new point\r\n     * @param point\r\n     */\r\n    moveInitial = (point: Point) => {\r\n        if(this.state.grid.inBounds(point)\r\n            && !this.state.grid.isSolid(point)\r\n            && !pointsEqual(this.state.goal, point)\r\n            && !pointsEqual(this.state.initial, point)\r\n            && !this.disable)\r\n        {\r\n            this.setState({\r\n                initial: point\r\n            }, () => this.props.onTilesDragged());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves goal to a new point\r\n     * @param point\r\n     */\r\n    moveGoal = (point: Point) => {\r\n        if(this.state.grid.inBounds(point)\r\n            && !this.state.grid.isSolid(point)\r\n            && !pointsEqual(this.state.initial, point)\r\n            && !pointsEqual(this.state.goal, point)\r\n            && !this.disable)\r\n        {\r\n            this.setState({\r\n                goal: point\r\n            }, () => this.props.onTilesDragged());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw a path onto the grid\r\n     * @param path\r\n     */\r\n    drawPath = (path: Tile[]) => {\r\n        this.setState({\r\n            path: path.slice()\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Erase path from the grid\r\n     */\r\n    erasePath = () => {\r\n        this.setState({\r\n            path: []\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts real screen x,y coordinates into\r\n     * a 2d point position on the grid\r\n     * @param xCoordinate\r\n     * @param yCoordinate\r\n     */\r\n    calculatePoint = (xCoordinate: number, yCoordinate: number) => {\r\n        return {\r\n            x: Math.floor(xCoordinate/this.props.tileWidth),\r\n            y: Math.floor(yCoordinate/this.props.tileWidth)\r\n        }\r\n    }\r\n\r\n    resetPoints = () => {\r\n        const end = this.calcEndPointInView();\r\n        this.setState({\r\n            initial: {\r\n                x: ((end.x)/3) >> 0,\r\n                y: ((end.y)/3) >> 0\r\n            },\r\n            goal: {\r\n                x: ((2*(end.x)/3) >> 0) - 1,\r\n                y: ((2*(end.y)/3) >> 0) - 1\r\n            }\r\n        });\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <svg ref={this.svg} xmlns='http://www.w3.org/2000/svg' className='grid'\r\n                 onContextMenu={e => e.preventDefault()}\r\n                 onMouseDown={e => this.mouseDown(e.nativeEvent)}\r\n                 onMouseUp={e => this.mouseUp(e.nativeEvent)}\r\n                 onMouseMove={e => this.mouseMove(e.nativeEvent)}\r\n                 onMouseLeave={e => this.onEndingEvent(e.nativeEvent)}\r\n                 onTouchStart={e => this.touchStart(e.nativeEvent)}\r\n                 onTouchMoveCapture={e => this.touchMove(e.nativeEvent)}\r\n                 onTouchEnd={e => this.onEndingEvent(e.nativeEvent)}\r\n                 onTouchCancel={e => this.onEndingEvent(e.nativeEvent)}\r\n            >\r\n                <defs>\r\n                    <marker id='arrowhead-path' markerWidth='3' markerHeight='3'\r\n                            refX='0' refY='1.5' orient='auto'\r\n                            fill={ARROW_PATH_COLOR}\r\n                    >\r\n                        <polygon points='0 0, 3 1.5, 0 3'/>\r\n                    </marker>\r\n                </defs>\r\n                {this.renderEndTile(this.state.initial, INITIAL_COLOR,'initial')}\r\n                {this.renderEndTile(this.state.goal, GOAL_COLOR,'goal')}\r\n                {this.renderPath()}\r\n                {this.renderTiles()}\r\n            </svg>\r\n        );\r\n    }\r\n\r\n    private renderPath = () => {\r\n        const lines: JSX.Element[] = [];\r\n        for(let i = 0; i < this.state.path.length-1; i++) {\r\n            const first = this.state.path[i].point;\r\n            const second = this.state.path[i+1].point;\r\n            lines.push(this.renderPathArrow(i, first, second));\r\n        }\r\n        return lines;\r\n    }\r\n\r\n    private renderPathArrow = (index: number, first: Point, second: Point) => {\r\n        const width = this.props.tileWidth;\r\n        const offset = width/2;\r\n        const firstX = first.x * width;\r\n        const firstY = first.y * width;\r\n        const secondX = second.x * width;\r\n        const secondY = second.y * width;\r\n        const offsetX = (secondX - firstX)/4;\r\n        const offsetY = (secondY - firstY)/4;\r\n        return (\r\n            <line key={'path ' + index}\r\n                  x1={firstX + offset + offsetX}\r\n                  y1={firstY + offset + offsetY}\r\n                  x2={secondX + offset - offsetX}\r\n                  y2={secondY + offset - offsetY}\r\n                  stroke={ARROW_PATH_COLOR}\r\n                  strokeWidth={2 * this.props.tileWidth/BASE_WIDTH}\r\n                  className='line-path-arrow'\r\n                  markerEnd='url(#arrowhead-path)' />\r\n        );\r\n    }\r\n\r\n    private renderTiles = () => {\r\n        const tiles: JSX.Element[] = [];\r\n        for(let y = 0; y < this.height; y++) {\r\n            for(let x = 0; x < this.width; x++) {\r\n                const point = {\r\n                    x: x, y: y\r\n                }\r\n                if(this.state.grid.isSolid(point)) {\r\n                    tiles.push(\r\n                        <TileFg key={point.x + ',' + point.y} point={point}\r\n                                doAnimation={this.doTileAnimation}\r\n                                tileWidth={this.props.tileWidth}\r\n                                color={SOLID_COLOR}\r\n                        />\r\n                    );\r\n                }\r\n            }\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    private renderEndTile = (point: Point, color: string, key: string) => {\r\n        return <TileFg key={key} point={point} doAnimation={false}\r\n                       tileWidth={this.props.tileWidth}\r\n                       color={color}/>\r\n    }\r\n}\r\n\r\nfunction pointsEqual(point1: Point, point2: Point) {\r\n    return point1.x === point2.x && point1.y === point2.y;\r\n}\r\n\r\nexport default GridForeground;","import React, {RefObject} from 'react';\r\n\r\ninterface IProps {\r\n    algorithm: string,\r\n    length: number,\r\n    time: number,\r\n    nodes: number,\r\n}\r\n\r\nclass StatsPanel extends React.Component<IProps>\r\n{\r\n    private readonly textLog: RefObject<HTMLTextAreaElement> = React.createRef();\r\n\r\n    componentDidUpdate() {\r\n        this.textLog.current!.scrollTop = this.textLog.current!.scrollHeight;\r\n    }\r\n\r\n    getHeight() {\r\n        return this.textLog.current!.clientHeight;\r\n    }\r\n\r\n    render() {\r\n        const time = precise(this.props.time);\r\n        const text = this.props.algorithm === '' ? '' :\r\n            this.props.algorithm + ' visited ' + this.props.nodes + ' nodes in ' +\r\n            time + ' ms. Path length = ' + this.props.length + '. ';\r\n        return(\r\n            <div>\r\n                <textarea tabIndex={-1} ref={this.textLog} readOnly={true}\r\n                          className='stats-text-area no-select'\r\n                          value={text} unselectable={'on'} onDrop={() => false}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction precise(x: number) {\r\n    return x.toFixed(2);\r\n}\r\n\r\nexport default StatsPanel;","import {Grid} from './Grid';\r\nimport {Point, Tile} from './Components';\r\n\r\nexport const UNIT = 1; //number of tiles we can move at once\r\n\r\n/**\r\n * Describes an abstract navigator for a grid\r\n * Provides graph-like traversal for the grid\r\n * Determines where we can travel to from a certain point,\r\n * whether we have reached a destination, and the cost to\r\n * travel to a certain point\r\n */\r\nabstract class Navigator\r\n{\r\n    protected readonly grid: Grid;\r\n\r\n    constructor(grid: Grid) {\r\n        this.grid = grid;\r\n    }\r\n\r\n    getGrid() {\r\n        return this.grid;\r\n    }\r\n\r\n    /**\r\n     * Goal check function: Checks if two points are equal\r\n     * @param a\r\n     * @param b\r\n     */\r\n    equals(a: Point, b: Point) {\r\n        return a.x === b.x && a.y === b.y;\r\n    }\r\n\r\n    /**\r\n     * Step cost function from a to b\r\n     * @param a\r\n     * @param b to point to travel to\r\n     */\r\n    abstract cost(a: Point, b: Point): number;\r\n\r\n    /**\r\n     * Neighbors function: Gets the available neighbors for a point in a grid we can make\r\n     * in a given move\r\n     * @param point\r\n     */\r\n    abstract neighbors(point: Point): Tile[];\r\n\r\n    abstract getType(): string;\r\n}\r\n\r\nexport default Navigator;","import {Point, Tile} from './Components';\r\nimport Navigator, {UNIT} from './Navigator';\r\n\r\n/**\r\n * Concretion of a Plus Navigator for a grid\r\n * Allows movement akin to a 'plus' symbol\r\n */\r\nclass PlusNavigator extends Navigator\r\n{\r\n    /**\r\n     * Adds the neighbors of a point to the left, right, top and down\r\n     * @param point\r\n     */\r\n    neighbors(point: Point): Tile[] {\r\n        const tiles: Tile[] = [];\r\n        if(point.x + UNIT < this.grid.getWidth()) {\r\n            const tile = this.grid.get({\r\n                x: point.x + UNIT,\r\n                y: point.y\r\n            })\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.y + UNIT < this.grid.getHeight()) {\r\n            const tile = this.grid.get({\r\n                x: point.x,\r\n                y: point.y + UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.x - UNIT >= 0) {\r\n            const tile = this.grid.get({\r\n                x: point.x - UNIT,\r\n                y: point.y\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.y - UNIT >= 0) {\r\n            const tile = this.grid.get({\r\n                x: point.x,\r\n                y: point.y - UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    /**\r\n     * Step cost function that works by getting the pathCost stored in the grid\r\n     * from one point a to b\r\n     * @param a\r\n     * @param b to point to travel to\r\n     */\r\n    cost(a: Point, b: Point) {\r\n        return this.grid.get(b).data.pathCost;\r\n    }\r\n\r\n    getType() {\r\n        return 'plus';\r\n    }\r\n}\r\n\r\nexport default PlusNavigator;","import {Point} from '../core/Components';\r\n\r\nexport type HeuristicFunc = (a: Point, b: Point) => number;\r\n\r\nexport function manhattan(a: Point, b: Point): number {\r\n    const dx = Math.abs(a.x - b.x) ;\r\n    const dy = Math.abs(a.y - b.y);\r\n    return dx + dy;\r\n}\r\n\r\nexport function euclidean(a: Point, b: Point): number {\r\n    const dx = Math.abs(a.x - b.x);\r\n    const dy = Math.abs(a.y - b.y);\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\r\n\r\nexport function octile(a: Point, b: Point): number {\r\n    const dx = Math.abs(a.x - b.x);\r\n    const dy = Math.abs(a.y - b.y);\r\n    return Math.SQRT2 * Math.min(dx, dy) + Math.abs(dx - dy);\r\n}\r\n\r\nexport function chebyshev(a: Point, b: Point): number {\r\n    const dx = Math.abs(a.x - b.x);\r\n    const dy = Math.abs(a.y - b.y);\r\n    return Math.max(dx, dy);\r\n}\r\n\r\nexport function nullHeuristic(a: Point, b: Point): number {\r\n    return 0;\r\n}","import {Point, Tile} from './Components';\r\nimport Navigator, {UNIT} from './Navigator';\r\nimport {euclidean} from '../algorithms/Heuristics';\r\n\r\n/**\r\n * Concretion of a Plus Navigator for a grid\r\n * Allows movement akin to a 'asterisk' symbol\r\n */\r\nclass AsteriskNavigator extends Navigator\r\n{\r\n    /**\r\n     * Adds the neighbors of a point to the left, right, top and down\r\n     * @param point\r\n     */\r\n    neighbors(point: Point): Tile[] {\r\n        //keep track of double squares that block diagonals\r\n        let walkBottomRight = false;\r\n        let walkTopRight = false;\r\n        let walkBottomLeft = false;\r\n        let walkTopLeft = false;\r\n        //plus\r\n        const tiles: Tile[] = [];\r\n        if(point.x + UNIT < this.grid.getWidth()) {\r\n            const tile = this.grid.get({\r\n                x: point.x + UNIT,\r\n                y: point.y\r\n            })\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n                walkBottomRight = true;\r\n                walkTopRight = true;\r\n            }\r\n        }\r\n        if(point.y + UNIT < this.grid.getHeight()) {\r\n            const tile = this.grid.get({\r\n                x: point.x,\r\n                y: point.y + UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n                walkBottomRight = true;\r\n                walkBottomLeft = true;\r\n            }\r\n        }\r\n        if(point.x - UNIT >= 0) {\r\n            const tile = this.grid.get({\r\n                x: point.x - UNIT,\r\n                y: point.y\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n                walkBottomLeft = true;\r\n                walkTopLeft = true;\r\n            }\r\n        }\r\n        if(point.y - UNIT >= 0) {\r\n            const tile = this.grid.get({\r\n                x: point.x,\r\n                y: point.y - UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n                walkTopRight = true;\r\n                walkTopLeft = true;\r\n            }\r\n        }\r\n        //diagonals\r\n        if(point.x + UNIT < this.grid.getWidth() &&\r\n            point.y + UNIT < this.grid.getHeight() &&\r\n            walkBottomRight) {\r\n            const tile = this.grid.get({\r\n                x: point.x + UNIT,\r\n                y: point.y + UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.x - UNIT >= 0 &&\r\n            point.y + UNIT < this.grid.getHeight() &&\r\n            walkBottomLeft) {\r\n            const tile = this.grid.get({\r\n                x: point.x - UNIT,\r\n                y: point.y + UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.x + UNIT < this.grid.getWidth() &&\r\n            point.y - UNIT >= 0 &&\r\n            walkTopRight) {\r\n            const tile =  this.grid.get({\r\n                x: point.x + UNIT,\r\n                y: point.y - UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.x - UNIT >= 0 &&\r\n            point.y - UNIT >= 0 &&\r\n            walkTopLeft) {\r\n            const tile =  this.grid.get({\r\n                x: point.x - UNIT,\r\n                y: point.y - UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    /**\r\n     * Step cost function that works by getting the pathCost stored in the grid\r\n     * from one point a to b\r\n     * Returns the exact distance multiplied by the cost to travel there\r\n     * @param a\r\n     * @param b to point to travel to\r\n     */\r\n    cost(a: Point, b: Point) {\r\n        return euclidean(a,b) * this.grid.get(b).data.pathCost;\r\n    }\r\n\r\n    getType() {\r\n        return 'asterisk';\r\n    }\r\n}\r\n\r\nexport default AsteriskNavigator;","import {Point} from '../core/Components';\r\n\r\n/**\r\n * A simple data structure that keeps track of whether keys have been added to it\r\n */\r\nexport class HashSet\r\n{\r\n    private map: {[key: string]: boolean} = {};\r\n\r\n    add(key: string) {\r\n        this.map[key] = true;\r\n    }\r\n\r\n    remove(key: string) {\r\n        this.map[key] = false;\r\n    }\r\n\r\n    has(key: string) {\r\n        return this.map[key];\r\n    }\r\n\r\n    clear() {\r\n        this.map = {};\r\n    }\r\n}\r\n\r\n/**\r\n * A simple data structure that stores a type at a key\r\n */\r\nexport class HashTable<Value>\r\n{\r\n    private map: {[key: string]: Value | undefined} = {};\r\n\r\n    add(key: string, data: Value) {\r\n        this.map[key] = data;\r\n    }\r\n\r\n    remove(key: string) {\r\n        this.map[key] = undefined;\r\n    }\r\n\r\n    get(key: string) {\r\n        return this.map[key];\r\n    }\r\n\r\n    has(key: string) {\r\n        return this.map[key] !== undefined;\r\n    }\r\n\r\n    clear() {\r\n        this.map = {};\r\n    }\r\n}\r\n\r\n/**\r\n * Serialize point into a unique string\r\n * @param point\r\n */\r\nexport function stringify(point: Point) {\r\n    return 'x' + point.x + 'y' + point.y;\r\n}","/**\r\n * A compare function to determine if a is 'better' (deserves a higher position) than b\r\n */\r\nexport type Comparator<E> = (a: E, b: E) => boolean\r\n\r\n/**\r\n * Minimalist Implementation of the heap data structure as an array\r\n */\r\nclass Heap<E>\r\n{\r\n    private elements: E[] = [];\r\n    readonly compare: Comparator<E>;\r\n\r\n    constructor(compare: Comparator<E>) {\r\n        this.compare = compare;\r\n    }\r\n\r\n    /**\r\n     * Returns the size of the heap\r\n     */\r\n    getSize() {\r\n        return this.elements.length;\r\n    }\r\n\r\n    /**\r\n     * Checks if heap is empty\r\n     */\r\n    isEmpty() {\r\n        return this.elements.length === 0;\r\n    }\r\n\r\n    /**\r\n     * Add a new element to the heap\r\n     * @param e\r\n     */\r\n    push(e: E) {\r\n        this.elements.push(e);\r\n        this.siftUp(this.elements.length-1); //last element\r\n    }\r\n\r\n    /**\r\n     * Returns the top of the heap without removing it\r\n     * Fails if heap is empty\r\n     */\r\n    peek() {\r\n        return this.elements[0];\r\n    }\r\n\r\n    /**\r\n     * Returns the top of the heap and removes it\r\n     * Fails if heap is empty\r\n     */\r\n    pop() {\r\n        const val = this.peek();\r\n        this.move(this.elements.length - 1, 0);\r\n        this.elements.pop();\r\n        this.siftDown(0);\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Clear the heap\r\n     */\r\n    clear() {\r\n        this.elements = [];\r\n    }\r\n\r\n    /**\r\n     * Sifts a new element that is out of order up to the right position\r\n     * @param pos of new element\r\n     */\r\n    private siftUp(pos: number) {\r\n        let parent = ((pos - 1) / 2) >> 0; //integer division\r\n        while(parent >= 0) {\r\n            //if the current position is better than parent\r\n            if(this.compare(this.elements[pos], this.elements[parent])) {\r\n                //then current position with parent and move to next\r\n                this.swap(pos, parent);\r\n                pos = parent;\r\n                parent = ((pos - 1) / 2) >> 0;\r\n            } else {\r\n                //otherwise stop\r\n                parent = -1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sifts a new element that is out of order down to the right position\r\n     * @param pos of new element\r\n     */\r\n    private siftDown(pos: number) {\r\n        const left = 2 * pos + 1;\r\n        const right = 2 * pos + 2;\r\n        //stop if the children are out of bounds\r\n        if(left >= this.elements.length) {\r\n            return;\r\n        }\r\n        //find the better child\r\n        const child = (right >= this.elements.length || this.compare(this.elements[left], this.elements[right]))\r\n            ? left : right;\r\n        //continues to sift down if the child is better than the current position\r\n        if(this.compare(this.elements[child], this.elements[pos])) {\r\n            this.swap(child, pos);\r\n            this.siftDown(child);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal move function\r\n     * @param from\r\n     * @param to\r\n     */\r\n    private move(from: number, to: number) {\r\n        this.elements[to] = this.elements[from];\r\n    }\r\n\r\n    /**\r\n     * Internal swap function\r\n     * @param a\r\n     * @param b\r\n     */\r\n    private swap(a: number, b: number) {\r\n        let val = this.elements[a];\r\n        this.elements[a] = this.elements[b];\r\n        this.elements[b] = val;\r\n    }\r\n}\r\n\r\nexport default Heap;","import {Point, Tile} from '../core/Components';\r\nimport Navigator from '../core/Navigator';\r\nimport {Node} from './Node';\r\n\r\n/**\r\n * Pathfinder performs algorithms operations on the grid\r\n * Uses the navigator rank and expand nodes\r\n */\r\nabstract class Pathfinder\r\n{\r\n    protected recentSearch: Node[] = [];\r\n    protected navigator: Navigator;\r\n\r\n    constructor(navigator: Navigator) {\r\n        this.navigator = navigator;\r\n    }\r\n\r\n    setNavigator(navigator: Navigator) {\r\n        this.navigator = navigator;\r\n    }\r\n\r\n    getNavigator() {\r\n        return this.navigator;\r\n    }\r\n\r\n    getRecentNodes() {\r\n        return this.recentSearch.length;\r\n    }\r\n\r\n    clearRecentSearch() {\r\n        this.recentSearch = [];\r\n    }\r\n\r\n    getRecentGenerations() {\r\n        return this.recentSearch.slice();\r\n    }\r\n\r\n    protected addRecent(node: Node) {\r\n        this.recentSearch.push(node);\r\n    }\r\n\r\n    abstract getAlgorithmName(): string;\r\n\r\n    /**\r\n     * Finds the best path between initial and goal on the grid\r\n     * and returns it in an array\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    abstract findPath(initial: Point, goal: Point): Tile[];\r\n}\r\n\r\n/**\r\n * Reconstructs the path from a tree, given the bottomLeaf, and\r\n * returns the shortest path in an array\r\n * @param bottomLeaf bottom of the tree to start from\r\n */\r\nexport function reconstructPath(bottomLeaf: Node): Tile[] {\r\n    return reconstructPathReversed(bottomLeaf).reverse();\r\n}\r\n\r\n/**\r\n * Reconstructs the path from a tree, given the bottomLeaf, and\r\n * returns the shortest path in an array\r\n * @param bottomLeaf bottom of the tree to start from\r\n */\r\nexport function reconstructPathReversed(bottomLeaf: Node): Tile[] {\r\n    const path: Tile[] = [];\r\n    while(bottomLeaf.parent !== null) {\r\n        path.push(bottomLeaf.tile);\r\n        bottomLeaf = bottomLeaf.parent;\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default Pathfinder;","import {Tile} from '../core/Components';\r\n\r\n/**\r\n * Represents a search Tree Node\r\n */\r\nexport class Node\r\n{\r\n    parent: Node | null = null; //parent node\r\n    readonly children: Node[] = [];\r\n    readonly tile: Tile; //stores a graph node\r\n\r\n    constructor(tile: Tile) {\r\n        this.tile = tile;\r\n    }\r\n\r\n    addChild(child: Node) {\r\n        child.parent = this;\r\n        this.children.push(child);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents an heuristic weighted aStar search tree node\r\n */\r\nexport class AStarNode extends Node\r\n{\r\n    readonly g: number; //path cost\r\n    readonly fScore: number; //heuristic\r\n\r\n    constructor(tile: Tile, g: number, fScore: number) {\r\n        super(tile);\r\n        this.g = g;\r\n        this.fScore = fScore;\r\n    }\r\n\r\n    f() {\r\n        return this.fScore;\r\n    }\r\n}\r\n","import {HashSet, HashTable, stringify} from '../structures/Hash';\r\nimport Heap from '../structures/Heap';\r\nimport Pathfinder, {reconstructPath} from './Pathfinder';\r\nimport {Point, Tile} from '../core/Components';\r\nimport {AStarNode} from './Node';\r\nimport Navigator from '../core/Navigator';\r\nimport {euclidean, HeuristicFunc} from './Heuristics';\r\n\r\nclass AStarPathfinder extends Pathfinder\r\n{\r\n    private readonly heuristic: HeuristicFunc = (a: Point, b: Point) => euclidean(a,b);\r\n    private readonly isNewScoreBetter: (newF: number, oldF: number) => boolean;\r\n\r\n    constructor(navigator: Navigator, func?: HeuristicFunc, canRediscover?: boolean) {\r\n        super(navigator);\r\n        if(func !== undefined) {\r\n            this.heuristic = func;\r\n        }\r\n        this.isNewScoreBetter = canRediscover === undefined || canRediscover ?\r\n            (newScore: number, oldScore: number) => newScore < oldScore :\r\n            () => false;\r\n    }\r\n\r\n    getAlgorithmName(): string {\r\n        return 'A*';\r\n    }\r\n\r\n    /**\r\n     * Performs aStar algorithm on the grid given an initial and goal point\r\n     * Always returns the shortest path, and performs well on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point): Tile[] {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const openFrontier = new Heap<AStarNode>(\r\n            (a, b) => a.f() < b.f()\r\n        );\r\n        const closedSet = new HashSet();\r\n        const openSet = new HashTable<number>();\r\n        const root = new AStarNode(\r\n            grid.get(initial), 0, 0\r\n        );\r\n        openFrontier.push(root);\r\n        openSet.add(stringify(initial), root.g);\r\n        while (!openFrontier.isEmpty()) {\r\n            const currentNode = openFrontier.pop();\r\n            const currentPoint = currentNode.tile.point;\r\n            const currentKey = stringify(currentPoint);\r\n            openSet.remove(currentKey);\r\n            closedSet.add(currentKey);\r\n            this.addRecent(currentNode);\r\n            if (this.navigator.equals(currentPoint, goal)) {\r\n                return reconstructPath(currentNode);\r\n            }\r\n            for (const neighbor of this.navigator.neighbors(currentPoint)) {\r\n                const neighborPoint = neighbor.point;\r\n                const neighborKey = stringify(neighborPoint);\r\n                if(closedSet.has(neighborKey)) {\r\n                    continue;\r\n                }\r\n                const g = currentNode.g + this.stepCost(currentPoint, neighborPoint);\r\n                const f = g + this.heuristic(neighborPoint, goal);\r\n                if (!openSet.has(neighborKey) || this.isNewScoreBetter(g, openSet.get(neighborKey)!)) {\r\n                    const neighborNode = new AStarNode(\r\n                        neighbor, g, f\r\n                    );\r\n                    currentNode.addChild(neighborNode);\r\n                    openFrontier.push(neighborNode);\r\n                    openSet.add(neighborKey, neighborNode.g);\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * The step-cost function to be used, calculating the cost from\r\n     * currentPoint to neighborPoint. Uses the stepCost function provided by the\r\n     * navigator by default but can be overridden\r\n     * @param currentPoint\r\n     * @param neighborPoint\r\n     */\r\n    stepCost(currentPoint: Point, neighborPoint: Point) {\r\n        return this.navigator.cost(currentPoint, neighborPoint);\r\n    }\r\n}\r\n\r\nexport default AStarPathfinder;","import Pathfinder, {reconstructPath} from './Pathfinder';\r\nimport {Point, Tile} from '../core/Components';\r\nimport {HashSet, stringify} from '../structures/Hash';\r\nimport {Node} from './Node';\r\n\r\nclass BFSPathfinder extends Pathfinder\r\n{\r\n    getAlgorithmName(): string {\r\n        return 'Breadth First Search';\r\n    }\r\n\r\n    /**\r\n     * Implementation of BFS to find the shortest path from initial to point\r\n     * Always returns the shortest path, but performs poorly on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point): Tile[] {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const frontier: Node[] = []; //fifo, stores nodes on the frontier\r\n        const visited = new HashSet();\r\n        const root = new Node(grid.get(initial));\r\n        frontier.push(root); //enqueue\r\n        visited.add(stringify(initial));\r\n        while(frontier.length !== 0) { //not empty\r\n            const currentNode = frontier.shift()!; //dequeue\r\n            const currentPoint = currentNode.tile.point;\r\n            this.addRecent(currentNode);\r\n            if(this.navigator.equals(currentPoint, goal)) {\r\n                return reconstructPath(currentNode);\r\n            }\r\n            for(const neighbor of this.navigator.neighbors(currentPoint)) {\r\n                const neighborKey = stringify(neighbor.point);\r\n                if(!visited.has(neighborKey)) {\r\n                    const neighborNode = new Node(neighbor);\r\n                    currentNode.addChild(neighborNode);\r\n                    frontier.push(neighborNode); //enqueue\r\n                    visited.add(neighborKey);\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\nexport default BFSPathfinder;","/**\r\n * Stack node\r\n */\r\nclass Node<E>\r\n{\r\n    next: Node<E> | null = null;\r\n    data: E;\r\n\r\n    constructor(data: E) {\r\n        this.data = data;\r\n    }\r\n}\r\n\r\n/**\r\n * Minimalist Implementation of the stack data structure\r\n */\r\nclass Stack<E>\r\n{\r\n    private top: Node<E> | null = null;\r\n    private size: number = 0;\r\n\r\n    peek() {\r\n        return this.top != null ? this.top.data : undefined;\r\n    }\r\n\r\n    push(e: E) {\r\n        const node = new Node(e);\r\n        node.next = this.top;\r\n        this.top = node;\r\n        this.size++;\r\n    }\r\n\r\n    pop() {\r\n        const top = this.peek();\r\n        if(this.top != null) {\r\n            this.top = this.top.next;\r\n            this.size--;\r\n        }\r\n        return top;\r\n    }\r\n\r\n    isEmpty() {\r\n        return this.size === 0;\r\n    }\r\n\r\n    getSize() {\r\n        return this.size;\r\n    }\r\n}\r\n\r\nexport default Stack;","import Pathfinder, {reconstructPath} from './Pathfinder';\r\nimport {Point, Tile} from '../core/Components';\r\nimport {HashSet, stringify} from '../structures/Hash';\r\nimport {Node} from './Node';\r\nimport Stack from '../structures/Stack';\r\n\r\nclass DFSPathfinder extends Pathfinder\r\n{\r\n    getAlgorithmName(): string {\r\n        return 'Depth First Search';\r\n    }\r\n\r\n    /**\r\n     * Calls DFS between a start and goal point, will typically not find the 'Best' path,\r\n     * and will instead find the best path capable for the algorithm\r\n     * As this algorithm is non optimal it should only be used for educational purposes\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point): Tile[] {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const root = new Node(grid.get(initial));\r\n        const frontier = new Stack<Node>();\r\n        frontier.push(root);\r\n        const visited = new HashSet();\r\n        visited.add(stringify(initial));\r\n        while(!frontier.isEmpty()) {\r\n            const currentNode = frontier.pop()!;\r\n            const currentPoint = currentNode.tile.point;\r\n            visited.add(stringify(currentPoint));\r\n            this.addRecent(currentNode);\r\n            if(this.navigator.equals(currentPoint, goal)) {\r\n                return reconstructPath(currentNode);\r\n            }\r\n            const neighbors = this.navigator.neighbors(currentPoint).reverse();\r\n            for(const neighbor of neighbors){\r\n                const neighborKey = stringify(neighbor.point);\r\n                if(!visited.has(neighborKey)) {\r\n                    const neighborNode = new Node(neighbor);\r\n                    currentNode.addChild(neighborNode);\r\n                    frontier.push(neighborNode);\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\nexport default DFSPathfinder;\r\n","import {HashSet, HashTable, stringify} from '../structures/Hash';\r\nimport Heap from '../structures/Heap';\r\nimport Pathfinder, {reconstructPath, reconstructPathReversed} from './Pathfinder';\r\nimport {Point, Tile} from '../core/Components';\r\nimport {AStarNode} from './Node';\r\nimport Navigator from '../core/Navigator';\r\nimport {euclidean, HeuristicFunc} from './Heuristics';\r\n\r\nclass BiAStarPathfinder extends Pathfinder\r\n{\r\n    private readonly heuristic: HeuristicFunc = (a: Point, b: Point) => euclidean(a,b);\r\n    private readonly isNewScoreBetter: (newF: number, oldF: number) => boolean;\r\n\r\n    constructor(navigator: Navigator, func?: HeuristicFunc, canRediscover?: boolean) {\r\n        super(navigator);\r\n        if(func !== undefined) {\r\n            this.heuristic = func;\r\n        }\r\n        this.isNewScoreBetter = canRediscover === undefined || canRediscover ?\r\n            (newScore: number, oldScore: number) => newScore < oldScore :\r\n            () => false;\r\n    }\r\n\r\n    getAlgorithmName(): string {\r\n        return 'Bidirectional A*';\r\n    }\r\n\r\n    /**\r\n     * Performs aStar algorithm on the grid given an initial and goal point\r\n     * Always returns the shortest path, and performs well on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point): Tile[] {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const closedSet = new HashSet();\r\n        const startOpenFrontier = new Heap<AStarNode>(\r\n            (a, b) => a.f() < b.f()\r\n        );\r\n        const startOpenSet = new HashTable<AStarNode>();\r\n        const endOpenFrontier = new Heap<AStarNode>(\r\n            (a, b) => a.f() < b.f()\r\n        );\r\n        const endOpenSet = new HashTable<AStarNode>();\r\n        const initialRoot = new AStarNode(\r\n            grid.get(initial), 0, 0\r\n        );\r\n        startOpenFrontier.push(initialRoot);\r\n        startOpenSet.add(stringify(initial), initialRoot);\r\n        const goalRoot = new AStarNode(\r\n            grid.get(goal), 0, 0\r\n        );\r\n        endOpenFrontier.push(goalRoot);\r\n        endOpenSet.add(stringify(goal), goalRoot);\r\n        while (!startOpenFrontier.isEmpty() && !endOpenFrontier.isEmpty()) {\r\n            //expand startOpenFrontier\r\n            const startCurrentNode = startOpenFrontier.pop();\r\n            const startCurrentPoint = startCurrentNode.tile.point;\r\n            const startCurrentPointKey = stringify(startCurrentPoint);\r\n            startOpenSet.remove(startCurrentPointKey);\r\n            closedSet.add(startCurrentPointKey);\r\n            this.addRecent(startCurrentNode);\r\n            if(endOpenSet.has(startCurrentPointKey)) {\r\n                if(startCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startCurrentNode.parent\r\n                    ).concat(reconstructPathReversed(\r\n                        endOpenSet.get(startCurrentPointKey)!\r\n                    )).concat(\r\n                        grid.get(goal)\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n            }\r\n            for (const neighbor of this.navigator.neighbors(startCurrentPoint)) {\r\n                const neighborPoint = neighbor.point;\r\n                const neighborKey = stringify(neighborPoint);\r\n                if(closedSet.has(neighborKey)) {\r\n                    continue;\r\n                }\r\n                const g = startCurrentNode.g + this.stepCost(startCurrentPoint, neighborPoint);\r\n                const f = g + this.heuristic(neighborPoint, goal);\r\n                if (!startOpenSet.has(neighborKey) || this.isNewScoreBetter(g, startOpenSet.get(neighborKey)!.g)) {\r\n                    const neighborNode = new AStarNode(\r\n                        neighbor, g, f\r\n                    );\r\n                    startCurrentNode.addChild(neighborNode);\r\n                    startOpenFrontier.push(neighborNode);\r\n                    startOpenSet.add(neighborKey, neighborNode);\r\n                }\r\n            }\r\n            //expand endOpenFrontier\r\n            const endCurrentNode = endOpenFrontier.pop();\r\n            const endCurrentPoint = endCurrentNode.tile.point;\r\n            const endCurrentPointKey = stringify(endCurrentPoint);\r\n            endOpenSet.remove(endCurrentPointKey);\r\n            closedSet.add(endCurrentPointKey);\r\n            this.addRecent(endCurrentNode);\r\n            if(startOpenSet.has(endCurrentPointKey)) {\r\n                if(endCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startOpenSet.get(endCurrentPointKey)!\r\n                    ).concat(reconstructPathReversed(\r\n                        endCurrentNode.parent!\r\n                    )).concat(\r\n                        grid.get(goal)\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n            }\r\n            for (const neighbor of this.navigator.neighbors(endCurrentPoint)) {\r\n                const neighborPoint = neighbor.point;\r\n                const neighborKey = stringify(neighborPoint);\r\n                if(closedSet.has(neighborKey)) {\r\n                    continue;\r\n                }\r\n                const g = endCurrentNode.g + this.stepCost(endCurrentPoint, neighborPoint);\r\n                const f = g + this.heuristic(neighborPoint, initial);\r\n                if (!endOpenSet.has(neighborKey) || this.isNewScoreBetter(g, endOpenSet.get(neighborKey)!.g)) {\r\n                    const neighborNode = new AStarNode(\r\n                        neighbor, g, f\r\n                    );\r\n                    endCurrentNode.addChild(neighborNode);\r\n                    endOpenFrontier.push(neighborNode);\r\n                    endOpenSet.add(neighborKey, neighborNode);\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * The step-cost function to be used, calculating the cost from\r\n     * currentPoint to neighborPoint. Uses the stepCost function provided by the\r\n     * navigator by default but can be overridden\r\n     * @param currentPoint\r\n     * @param neighborPoint\r\n     */\r\n    stepCost(currentPoint: Point, neighborPoint: Point) {\r\n        return this.navigator.cost(currentPoint, neighborPoint);\r\n    }\r\n}\r\n\r\nexport default BiAStarPathfinder;","import Pathfinder, {reconstructPath, reconstructPathReversed} from './Pathfinder';\r\nimport {Point, Tile} from '../core/Components';\r\nimport {HashTable, stringify} from '../structures/Hash';\r\nimport {Node} from './Node';\r\n\r\nclass BiBFSPathfinder extends Pathfinder\r\n{\r\n    getAlgorithmName(): string {\r\n        return 'Bidirectional Breadth First Search';\r\n    }\r\n\r\n    /**\r\n     * Implementation of BFS to find the shortest path from initial to point\r\n     * Always returns the shortest path, but performs poorly on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point): Tile[] {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const startVisited = new HashTable<Node>();\r\n        const endVisited = new HashTable<Node>();\r\n        const startFrontier: Node[] = [];\r\n        const endFrontier: Node[] = [];\r\n        const initialRoot = new Node(grid.get(initial));\r\n        startFrontier.push(initialRoot);\r\n        startVisited.add(stringify(initial), initialRoot);\r\n        const goalRoot = new Node(grid.get(goal));\r\n        endFrontier.push(goalRoot);\r\n        endVisited.add(stringify(goal), goalRoot);\r\n        while(startFrontier.length !== 0 && endFrontier.length !== 0) {\r\n            //expand startQueue\r\n            const startCurrentNode = startFrontier.shift()!;\r\n            const startCurrentPoint = startCurrentNode.tile.point;\r\n            const startCurrentPointKey = stringify(startCurrentPoint);\r\n            this.addRecent(startCurrentNode);\r\n            if(endVisited.has(startCurrentPointKey)) {\r\n                if(startCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startCurrentNode.parent\r\n                    ).concat(reconstructPathReversed(\r\n                        endVisited.get(startCurrentPointKey)!\r\n                    )).concat(\r\n                        grid.get(goal)\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n            }\r\n            for(const neighbor of this.navigator.neighbors(startCurrentPoint)) {\r\n                const neighborKey = stringify(neighbor.point);\r\n                if(!startVisited.has(neighborKey)) {\r\n                    const neighborNode = new Node(neighbor);\r\n                    startCurrentNode.addChild(neighborNode);\r\n                    startFrontier.push(neighborNode);\r\n                    startVisited.add(neighborKey, neighborNode);\r\n                }\r\n            }\r\n            //expand endQueue\r\n            const endCurrentNode = endFrontier.shift()!;\r\n            const endCurrentPoint = endCurrentNode.tile.point;\r\n            const endCurrentPointKey = stringify(endCurrentPoint);\r\n            this.addRecent(endCurrentNode);\r\n            if(startVisited.has(endCurrentPointKey)) {\r\n                if(endCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startVisited.get(endCurrentPointKey)!\r\n                    ).concat(reconstructPathReversed(\r\n                        endCurrentNode.parent\r\n                    )).concat(\r\n                        grid.get(goal)\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n            }\r\n            for(const neighbor of this.navigator.neighbors(endCurrentPoint)) {\r\n                const neighborKey = stringify(neighbor.point);\r\n                if(!endVisited.has(neighborKey)) {\r\n                    const neighborNode = new Node(neighbor);\r\n                    endCurrentNode.addChild(neighborNode);\r\n                    endFrontier.push(neighborNode);\r\n                    endVisited.add(neighborKey, neighborNode);\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\nexport default BiBFSPathfinder;","import Navigator from '../core/Navigator';\r\nimport PlusNavigator from '../core/PlusNavigator';\r\nimport AsteriskNavigator from '../core/AsteriskNavigator';\r\nimport {Point} from '../core/Components';\r\nimport {Grid} from '../core/Grid';\r\nimport {chebyshev, euclidean, HeuristicFunc, manhattan, nullHeuristic, octile} from './Heuristics';\r\nimport Pathfinder from './Pathfinder';\r\nimport AStarPathfinder from './AStar';\r\nimport BFSPathfinder from './BFS';\r\nimport DFSPathfinder from './DFS';\r\nimport BiAStarPathfinder from './BidirectionalAStar';\r\nimport BiBFSPathfinder from \"./BidirectionalBFS\";\r\n\r\nconst CREATE_NAVIGATOR: {[key: string]: ((grid: Grid) => Navigator)} = {\r\n    'plus': (grid: Grid) => new PlusNavigator(grid),\r\n    'asterisk': (grid: Grid) => new AsteriskNavigator(grid)\r\n}\r\n\r\nconst CREATE_HEURISTIC: {[key: string]: (() => HeuristicFunc)} = {\r\n    'manhattan': () => manhattan,\r\n    'euclidean': () => euclidean,\r\n    'chebyshev': () => chebyshev,\r\n    'octile': () => octile,\r\n    'null': () => nullHeuristic\r\n}\r\n\r\nconst CREATE_PATHFINDER: {[key: string]: ((navigator: Navigator, heuristic: HeuristicFunc) => Pathfinder)} = {\r\n    'dijkstra': (navigator) => {\r\n        return new (class DijkstraPathfinder extends AStarPathfinder {\r\n            getAlgorithmName(): string {\r\n                return 'Dijkstra';\r\n            }\r\n        })(navigator, nullHeuristic);\r\n    },\r\n    'best-first': (navigator, heuristic) => {\r\n        return new (class BestFirstPathfinder extends AStarPathfinder {\r\n            stepCost(currentPoint: Point, neighborPoint: Point) {\r\n                return 0;\r\n            }\r\n            getAlgorithmName(): string {\r\n                return 'Best-First Search';\r\n            }\r\n        })(navigator, heuristic);\r\n    },\r\n    'a*': (navigator, heuristic) => {\r\n        return new AStarPathfinder(navigator, heuristic,navigator.getType() !== 'plus');\r\n    },\r\n    'bfs': (navigator) => {\r\n        return new BFSPathfinder(navigator);\r\n    },\r\n    'dfs': (navigator) => {\r\n        return new DFSPathfinder(navigator);\r\n    },\r\n    'bi-a*': (navigator, heuristic) => {\r\n        return new BiAStarPathfinder(navigator, heuristic, navigator.getType() !== 'plus');\r\n    },\r\n    'bi-dijkstra': (navigator) => {\r\n        return new (class BiDijkstraPathfinder extends BiAStarPathfinder {\r\n            getAlgorithmName(): string {\r\n                return 'Bidirectional Dijkstra';\r\n            }\r\n        })(navigator, nullHeuristic);\r\n    },\r\n    'bi-bfs': (navigator) => {\r\n        return new BiBFSPathfinder(navigator);\r\n    }\r\n}\r\n\r\nclass PathfinderBuilder\r\n{\r\n    private navigator: string = 'plus';\r\n    private algorithm: string = 'a*';\r\n    private heuristic: string = 'null';\r\n    private readonly grid: Readonly<Grid>;\r\n\r\n    constructor(grid: Readonly<Grid>) {\r\n        this.grid = grid;\r\n    }\r\n\r\n    setNavigator(navigator: string) {\r\n        navigator = navigator.toLowerCase();\r\n        if(CREATE_NAVIGATOR[navigator] == null) {\r\n            throw new Error('No such navigator pattern exists')\r\n        } else {\r\n            this.navigator = navigator;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    setAlgorithm(algorithm: string) {\r\n        algorithm = algorithm.toLowerCase();\r\n        if(CREATE_PATHFINDER[algorithm] == null) {\r\n            throw new Error('No such pathfinding algorithm exists')\r\n        } else {\r\n            this.algorithm = algorithm;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    setHeuristic(heuristic: string) {\r\n        heuristic = heuristic.toLowerCase();\r\n        if(CREATE_HEURISTIC[heuristic] == null) {\r\n            throw new Error('No such heuristic function exists')\r\n        } else {\r\n            this.heuristic = heuristic;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Builds a pathfinder with a navigator with the set algorithm, heuristic, and navigator\r\n     */\r\n    build() {\r\n        const createHeuristic = CREATE_HEURISTIC[this.heuristic];\r\n        const createNavigator = CREATE_NAVIGATOR[this.navigator];\r\n        const createPathfinder = CREATE_PATHFINDER[this.algorithm];\r\n        return createPathfinder(createNavigator(this.grid), createHeuristic());\r\n    }\r\n\r\n    static usesHeuristic(algorithm: string) {\r\n        return algorithm === 'a*' || algorithm === 'bi-a*' ||\r\n            algorithm === 'best-first';\r\n    }\r\n\r\n    static hasBidirectional(algorithm: string) {\r\n        return CREATE_PATHFINDER['bi-' + algorithm] != null;\r\n    }\r\n\r\n    static makeBidirectional(algorithm: string) {\r\n        return 'bi-' + algorithm;\r\n    }\r\n}\r\n\r\nexport default PathfinderBuilder;\r\n\r\n","class VirtualTimer\r\n{\r\n    private timeout: NodeJS.Timeout;\r\n    private readonly callback: () => void\r\n    private timeStarted: number;\r\n    private timeRemaining: number;\r\n    private finished: boolean;\r\n\r\n    constructor(callback: () => void, countDown: number) {\r\n        this.callback = callback;\r\n        this.finished = false;\r\n        this.timeStarted = Date.now();\r\n        this.timeRemaining = countDown;\r\n        this.timeout = setTimeout(() => {\r\n            callback();\r\n            this.finished = true;\r\n        }, this.timeRemaining);\r\n    }\r\n\r\n    clear() {\r\n        clearTimeout(this.timeout);\r\n        this.finished = true;\r\n    }\r\n\r\n    pause() {\r\n        if(!this.finished) {\r\n            clearTimeout(this.timeout);\r\n            this.timeRemaining -= Date.now() - this.timeStarted;\r\n        }\r\n    }\r\n\r\n    resume() {\r\n        if(!this.finished) {\r\n            this.timeStarted = Date.now();\r\n            this.timeout = setTimeout(() => {\r\n                this.callback();\r\n                this.finished = true;\r\n            }, this.timeRemaining);\r\n        }\r\n    }\r\n\r\n    isFinished() {\r\n        return this.finished;\r\n    }\r\n\r\n    getNativeTimeout() {\r\n        return this.timeout;\r\n    }\r\n}\r\n\r\nexport default VirtualTimer;","import {Point, Tile} from '../core/Components';\r\nimport {Grid} from '../core/Grid';\r\nimport {HashSet, stringify} from '../structures/Hash';\r\n\r\nabstract class TerrainGenerator\r\n{\r\n    protected readonly width: number;\r\n    protected readonly height: number;\r\n    protected readonly ignore: HashSet;\r\n\r\n    protected constructor(width: number, height: number, ignore?: Point[]) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.ignore = new HashSet();\r\n        if(ignore !== undefined) {\r\n            for(const i of ignore) {\r\n                this.ignore.add(stringify(i));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws a tile to the grid\r\n     * @param grid\r\n     * @param tile\r\n     */\r\n    protected draw(grid: Grid, tile: Tile) {\r\n        if(!this.shouldIgnore(tile.point)) {\r\n            grid.mutateTile(tile);\r\n        }\r\n    }\r\n\r\n    shouldIgnore(point: Point) {\r\n        return this.ignore.has(stringify(point));\r\n    }\r\n\r\n    abstract generateTerrain(topLeft?: Point, bottomRight?: Point): Grid;\r\n}\r\n\r\nexport default TerrainGenerator;","import TerrainGenerator from './TerrainGenerator';\r\nimport {createTile, Point} from '../core/Components';\r\nimport GridGraph, {Grid} from '../core/Grid';\r\n\r\nclass RandomTerrainGenerator extends TerrainGenerator\r\n{\r\n    constructor(width: number, height: number, ignore?: Point[]) {\r\n        super(width, height, ignore);\r\n    }\r\n\r\n    /**\r\n     * Performs a random terrain generation algorithm where each tile has a 1/4\r\n     * chance of being solid\r\n     * @param topLeft optional parameter to specify what point the terrain should start from\r\n     *  This should not be further up/left than (1,1)\r\n     * @param bottomRight optional parameter to specify how far down and right the terrain will go\r\n     *  This should not be further right/down than (width-2,height-2)\r\n     */\r\n    generateTerrain(topLeft?: Point, bottomRight?: Point): Grid {\r\n        const grid = new GridGraph(this.width, this.height);\r\n        if(topLeft === undefined) {\r\n            topLeft = {\r\n                x: 1, y: 1\r\n            }\r\n        }\r\n        if(bottomRight === undefined) {\r\n            bottomRight = {\r\n                x: grid.getWidth()-2,\r\n                y: grid.getHeight()-2\r\n            }\r\n        }\r\n        for(let x = topLeft.x - 1; x <= bottomRight.x + 1; x++) {\r\n            for(let y = topLeft.y - 1; y <= bottomRight.y + 1; y++) {\r\n                if(getRand(0, 3) === 0) {\r\n                    this.draw(grid,{\r\n                        point: {\r\n                            x: x, y: y\r\n                        },\r\n                        data: createTile(true)\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        return grid;\r\n    }\r\n}\r\n\r\n/**\r\n * Generate a random number between min and max, inclusive for min and max\r\n * @param min\r\n * @param max\r\n */\r\nfunction getRand(min: number, max: number) {\r\n    return Math.floor(Math.random() * (max+1-min) + min);\r\n}\r\n\r\nexport default RandomTerrainGenerator;","import GridGraph, {Grid} from '../core/Grid';\r\nimport {Point, Tile, createTile} from '../core/Components';\r\nimport TerrainGenerator from './TerrainGenerator';\r\n\r\nconst LIMIT = 2;\r\n\r\nexport const NO_SKEW = 0;\r\nexport const VERTICAL_SKEW = 1;\r\nexport const HORIZONTAL_SKEW = 2;\r\n\r\ninterface Chamber\r\n{\r\n    topLeft: Point; //min\r\n    bottomRight: Point; //max\r\n}\r\n\r\nclass MazeGenerator extends TerrainGenerator\r\n{\r\n    private readonly divideWidth: (width: number, height: number) => boolean;\r\n\r\n    constructor(width: number, height: number, ignore?: Point[], slant?: number) {\r\n        super(width, height, ignore);\r\n        if(slant === undefined || slant === NO_SKEW) {\r\n            this.divideWidth = divideWidthNoSkew;\r\n        } else if(slant === VERTICAL_SKEW) {\r\n            this.divideWidth = divideWidthVSkew;\r\n        } else if(slant === HORIZONTAL_SKEW) {\r\n            this.divideWidth = divideWidthHSkew;\r\n        } else {\r\n            throw new Error(\"Invalid recursive maze division skew type\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Performs the recursive division maze generation algorithm on a new empty grid\r\n     * by bisecting parts until the maze can no longer be bisected\r\n     * Params must be within bounds and create a chamber\r\n     * @param topLeft optional parameter to specify what point the maze should start from\r\n     *  This should not be further up/left than (1,1)\r\n     * @param bottomRight optional parameter to specify how far down and right the maze will go\r\n     *  This should not be further right/down than (width-2,height-2)\r\n     */\r\n    generateTerrain(topLeft?: Point, bottomRight?: Point) {\r\n        const grid = new GridGraph(this.width, this.height);\r\n        if(topLeft === undefined) {\r\n            topLeft = {\r\n                x: 1, y: 1\r\n            }\r\n        }\r\n        if(bottomRight === undefined) {\r\n            bottomRight = {\r\n                x: grid.getWidth()-2,\r\n                y: grid.getHeight()-2\r\n            }\r\n        }\r\n        for(let x = topLeft.x - 1; x <= bottomRight.x + 1; x++) {\r\n            this.draw(grid,{\r\n                point: {\r\n                    x: x, y: topLeft.y - 1\r\n                },\r\n                data: createTile(true)\r\n            });\r\n            this.draw(grid,{\r\n                point: {\r\n                    x: x, y: bottomRight.y + 1\r\n                },\r\n                data: createTile(true)\r\n            });\r\n        }\r\n        for(let y = topLeft.y - 1; y <= bottomRight.y + 1; y++) {\r\n            this.draw(grid,{\r\n                point: {\r\n                    x: topLeft.x - 1, y: y\r\n                },\r\n                data: createTile(true)\r\n            });\r\n            this.draw(grid,{\r\n                point: {\r\n                    x: bottomRight.x + 1, y: y\r\n                },\r\n                data: createTile(true)\r\n            });\r\n        }\r\n        this.divide(grid,{\r\n            topLeft: topLeft,\r\n            bottomRight: bottomRight,\r\n        });\r\n        return grid;\r\n    }\r\n\r\n    /**\r\n     * Draws a list of tiles to the grid\r\n     * @param grid\r\n     * @param tiles\r\n     */\r\n    private drawArr(grid: Grid, tiles: Tile[]) {\r\n        for(const tile of tiles) {\r\n            this.draw(grid, tile);\r\n        }\r\n    }\r\n    /**\r\n     * Create a line between a region, with an open hole, in a chamber,\r\n     * and call bisection algorithm on it, and call division algorithms on\r\n     * its split chambers until no chambers can be bisected\r\n     * @param grid\r\n     * @param chamber\r\n     */\r\n    divide(grid: Grid, chamber: Chamber) {\r\n        const width = widthOf(chamber);\r\n        const height = heightOf(chamber);\r\n        const min = chamber.topLeft;\r\n        const max = chamber.bottomRight;\r\n        if(this.divideWidth(width,height)) {\r\n            if(width > LIMIT) {\r\n                //calculate axis\r\n                const randX = getMidPoint(\r\n                    min.x, max.x\r\n                );\r\n                //create axis wall\r\n                const toDraw: Tile[] = [];\r\n                for(let y = min.y; y <= max.y; y++) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: y\r\n                        },\r\n                        data: createTile(true)\r\n                    });\r\n                }\r\n                //create holes in axis wall\r\n                let edgeBlocked = false;\r\n                if(!grid.get({\r\n                    x: randX, y: min.y-1\r\n                }).data.isSolid) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: min.y\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                    edgeBlocked = true;\r\n                }\r\n                if(!grid.get({\r\n                    x: randX, y: max.y+1\r\n                }).data.isSolid) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: max.y\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                    edgeBlocked = true;\r\n                }\r\n                if(!edgeBlocked) {\r\n                    const randY = getRand(\r\n                        min.y, max.y,\r\n                    );\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: randY\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                }\r\n                this.drawArr(grid, toDraw);\r\n                //create children chambers and recurse\r\n                const leftChamber = {\r\n                    topLeft: chamber.topLeft,\r\n                    bottomRight: {\r\n                        x: randX-1,\r\n                        y: chamber.bottomRight.y\r\n                    },\r\n                };\r\n                const rightChamber = {\r\n                    topLeft: {\r\n                        x: randX+1,\r\n                        y: chamber.topLeft.y\r\n                    },\r\n                    bottomRight: chamber.bottomRight,\r\n                };\r\n                this.divide(grid, leftChamber);\r\n                this.divide(grid, rightChamber);\r\n            }\r\n        } else {\r\n            if(height > LIMIT) {\r\n                //calculate axis\r\n                const randY = getMidPoint(\r\n                    min.y, max.y\r\n                );\r\n                //draw axis wall\r\n                const toDraw: Tile[] = [];\r\n                for(let x = min.x; x <= max.x; x++) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: x, y: randY\r\n                        },\r\n                        data: createTile(true)\r\n                    });\r\n                }\r\n                //create holes in axis wall\r\n                let edgeBlocked = false;\r\n                if(!grid.get({\r\n                    x: min.x-1, y: randY\r\n                }).data.isSolid) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: min.x, y: randY\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                    edgeBlocked = true;\r\n                }\r\n                if(!grid.get({\r\n                    x: max.x+1, y: randY\r\n                }).data.isSolid) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: max.x, y: randY\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                    edgeBlocked = true;\r\n                }\r\n                if(!edgeBlocked) {\r\n                    const randX = getRand(\r\n                        min.x, max.x,\r\n                    );\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: randY\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                }\r\n                this.drawArr(grid, toDraw);\r\n                //create children chambers and recurse\r\n                const topChamber = {\r\n                    topLeft: chamber.topLeft,\r\n                    bottomRight: {\r\n                        x: chamber.bottomRight.x,\r\n                        y: randY-1\r\n                    },\r\n                };\r\n                const bottomChamber = {\r\n                    topLeft: {\r\n                        x: chamber.topLeft.x,\r\n                        y: randY+1\r\n                    },\r\n                    bottomRight: chamber.bottomRight,\r\n                };\r\n                this.divide(grid, topChamber);\r\n                this.divide(grid, bottomChamber);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction divideWidthNoSkew(width: number, height: number) {\r\n    return width >= height;\r\n}\r\n\r\nfunction divideWidthHSkew(width: number, height: number) {\r\n    return width >= height * 2;\r\n}\r\n\r\nfunction divideWidthVSkew(width: number, height: number) {\r\n    return width * 2 >= height;\r\n}\r\n\r\nfunction widthOf(chamber: Chamber) {\r\n    return chamber.bottomRight.x - chamber.topLeft.x + 1;\r\n}\r\n\r\nfunction heightOf(chamber: Chamber) {\r\n    return chamber.bottomRight.y - chamber.topLeft.y + 1;\r\n}\r\n\r\n/**\r\n * Returns the 'midpoint' to be used\r\n * @param min\r\n * @param max\r\n */\r\nfunction getMidPoint(min: number, max: number) {\r\n    const range = max - min;\r\n    if(range >= 20) {\r\n        return ((min+max)/2) >> 0;\r\n    } else if(range > 5) {\r\n        const mid = ((min+max)/2) >> 0;\r\n        const points = [mid, mid+1];\r\n        return points[getRand(0,points.length-1)];\r\n    } else {\r\n        return getRand(min+1,max-1);\r\n    }\r\n}\r\n\r\n/**\r\n * Generate a random number between min and max-1 then increment the number\r\n * if it is larger than or equal to excluded, inclusive for min and max\r\n * @param min\r\n * @param max\r\n * @param excluded\r\n */\r\nfunction getRandEx(min: number, max: number, excluded: number) {\r\n    let rand = getRand(min, max-1);\r\n    return rand >= excluded ? ++rand : rand;\r\n}\r\n\r\n/**\r\n * Generate a random number between min and max, inclusive for min and max\r\n * @param min\r\n * @param max\r\n */\r\nfunction getRand(min: number, max: number) {\r\n    return Math.floor(Math.random() * (max+1-min) + min);\r\n}\r\n\r\nexport default MazeGenerator;","import RandomTerrainGenerator from './RandomTerrainGenerator';\r\nimport MazeGenerator from './MazeGenerator';\r\nimport {Point} from '../core/Components';\r\n\r\nexport const MAZE = 0;\r\nexport const MAZE_VERTICAL_SKEW = 1;\r\nexport const MAZE_HORIZONTAL_SKEW = 2;\r\nexport const RANDOM_TERRAIN = 3;\r\n\r\nclass TerrainGeneratorBuilder\r\n{\r\n    private width: number = 0;\r\n    private height: number = 0;\r\n    private type: number = MAZE;\r\n    private ignore: Point[] = [];\r\n\r\n    setDimensions(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    setGeneratorType(type: number) {\r\n        this.type = type;\r\n        return this;\r\n    }\r\n\r\n    setIgnorePoints(ignore: Point[]) {\r\n        this.ignore = ignore.slice();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Builds a terrain generator with the specified type\r\n     */\r\n    build() {\r\n       if(this.type >= RANDOM_TERRAIN) {\r\n           return new RandomTerrainGenerator(this.width, this.height, this.ignore);\r\n       } else {\r\n           return new MazeGenerator(this.width, this.height, this.ignore, this.type);\r\n       }\r\n    }\r\n}\r\n\r\nexport default TerrainGeneratorBuilder;","import React, {RefObject} from 'react';\r\nimport GridBackground from './GridBackground';\r\nimport GridForeground from './GridForeground';\r\nimport StatsPanel from './StatsPanel';\r\nimport {Node} from '../../pathfinding/algorithms/Node';\r\nimport PathfindingSettings from '../PathfindingSettings';\r\nimport PathfinderBuilder from '../../pathfinding/algorithms/PathfinderBuilder';\r\nimport Pathfinder from '../../pathfinding/algorithms/Pathfinder';\r\nimport {Point, Tile} from '../../pathfinding/core/Components';\r\nimport {euclidean} from '../../pathfinding/algorithms/Heuristics';\r\nimport VirtualTimer from '../utility/VirtualTimer';\r\nimport TerrainGeneratorBuilder from '../../pathfinding/algorithms/TerrainGeneratorBuilder';\r\n\r\ninterface IProps {\r\n    tileWidth: number,\r\n    settings: Readonly<PathfindingSettings>,\r\n    topMargin: number,\r\n    onChangeVisualizing: (visualizing: boolean) => void;\r\n}\r\n\r\ninterface IState {\r\n    tilesX: number,\r\n    tilesY: number,\r\n    time: number,\r\n    length: number,\r\n    nodes: number,\r\n    algorithm: string\r\n}\r\n\r\nclass PathfindingVisualizer extends React.Component<IProps,IState>\r\n{\r\n    //references to expose background and foreground grids to parent\r\n    private background: RefObject<GridBackground> = React.createRef();\r\n    private foreground: RefObject<GridForeground> = React.createRef();\r\n    private stats: RefObject<StatsPanel> = React.createRef();\r\n\r\n    private visualized = false;\r\n    private visualizing = false;\r\n    private visualTimeouts: VirtualTimer[]  = [];\r\n    private generations: Node[] = [];\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        const w = window.screen.availWidth;\r\n        const h = window.screen.availHeight;\r\n        const tilesX = Math.floor(w / this.props.tileWidth) + 1;\r\n        const tilesY = Math.floor((h - this.props.topMargin - 30) / this.props.tileWidth) + 1;\r\n        this.state = {\r\n            tilesX: tilesX,\r\n            tilesY: tilesY,\r\n            time: -1,\r\n            length: -1,\r\n            nodes: -1,\r\n            algorithm: ''\r\n        }\r\n    }\r\n\r\n    canShowArrows = () => {\r\n        const settings = this.props.settings;\r\n        return settings.showArrows && settings.algorithm !== 'dfs';\r\n    }\r\n\r\n    canShowFrontier = () => {\r\n        const settings = this.props.settings;\r\n        return settings.visualizeAlg;\r\n    }\r\n\r\n    /**\r\n     * Pause the delayed pathfinding algorithm being performed\r\n     */\r\n    pausePathfinding = () => {\r\n        for(const timeout of this.visualTimeouts) {\r\n            timeout.pause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resume the delayed pathfinding algorithm being performed\r\n     * Will reset the timeouts to the last time the timeout was paused/started\r\n     * if not properly called while the timeout is paused\r\n     */\r\n    resumePathfinding = () => {\r\n        for(const timeout of this.visualTimeouts) {\r\n            timeout.resume();\r\n        }\r\n    }\r\n\r\n    jumpToGeneration = (generation: number) => {\r\n        this.clearPath();\r\n        const generations = this.generations.slice(generation);\r\n        if(this.canShowArrows()) {\r\n            this.addArrowGenerations(generations);\r\n        }\r\n        if(this.canShowFrontier()) {\r\n            this.visualizeGenerations(generations);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Performs the pathfinding algorithm on the grid and visualizes it\r\n     */\r\n    doPathfinding = () => {\r\n        this.clearPath();\r\n        const settings = this.props.settings;\r\n        const pathfinder = this.getPathfinder(settings);\r\n        const path = this.findPath(pathfinder);\r\n        this.generations = pathfinder.getRecentGenerations();\r\n        if(this.canShowArrows()) {\r\n            this.addArrowGenerations(this.generations);\r\n        }\r\n        if(this.canShowFrontier()) {\r\n            this.visualizeGenerations(this.generations);\r\n        }\r\n        this.drawPath(path);\r\n    }\r\n\r\n    /**\r\n     * Performs the pathfinding algorithm on the grid and visualizes it with delays between successive\r\n     * node generations\r\n     * If the visualizer is currently visualizing, the visualization stops instead\r\n     */\r\n    doDelayedPathfinding = () => {\r\n        this.clearVisualization();\r\n        this.clearPath();\r\n        const settings = this.props.settings;\r\n        this.visualized = false;\r\n        const foreground = this.foreground.current!;\r\n        foreground.toggleDisable();\r\n        if(!this.visualizing) { //start visualization if not visualizing\r\n            this.visualizing = true;\r\n            this.props.onChangeVisualizing(this.visualizing);\r\n            const pathfinder = this.getPathfinder(settings);\r\n            const path = this.findPath(pathfinder);\r\n            const promises: Promise<VirtualTimer>[] = []; //to call function when timeouts finish\r\n            this.visualTimeouts = [];\r\n            const baseIncrement = settings.delayInc;\r\n            let delay = 0;\r\n            const visualizeAlg = this.canShowFrontier();\r\n            const showArrows = this.canShowArrows();\r\n            if(showArrows || visualizeAlg) {\r\n                const expandVisualization = visualizeAlg ? this.visualizeGeneration : () => {};\r\n                const expandArrows = showArrows ? this.addArrowGeneration : () => {};\r\n                this.generations = pathfinder.getRecentGenerations();\r\n                this.generations.forEach((generation) => {\r\n                    const promise = new Promise<VirtualTimer>((resolve) => {\r\n                        //each generation gets a higher timeout\r\n                        const timeout = new VirtualTimer(() => {\r\n                            expandArrows(generation);\r\n                            expandVisualization(generation);\r\n                            this.background.current!.doUpdate();\r\n                            resolve(timeout);\r\n                        }, delay);\r\n                        this.visualTimeouts.push(timeout);\r\n                    });\r\n                    promises.push(promise);\r\n                    delay += baseIncrement;\r\n                });\r\n            }\r\n            //call functions when timeouts finish\r\n            Promise.all(promises).then(() => {\r\n                this.drawPath(path);\r\n                foreground.toggleDisable();\r\n                this.visualizing = false;\r\n                this.visualized = true;\r\n                this.props.onChangeVisualizing(this.visualizing);\r\n            });\r\n        } else { //stop visualizing if visualizing\r\n            for (const timeout of this.visualTimeouts) {\r\n                timeout.clear();\r\n            }\r\n            this.visualizing = false;\r\n            this.props.onChangeVisualizing(this.visualizing);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the pathfinder for the settings\r\n     * @param settings\r\n     */\r\n    private getPathfinder = (settings: PathfindingSettings) => {\r\n        const algorithmKey = settings.algorithm;\r\n        const algorithm = settings.bidirectional && PathfinderBuilder.hasBidirectional(algorithmKey) ?\r\n            PathfinderBuilder.makeBidirectional(algorithmKey) : algorithmKey;\r\n        return new PathfinderBuilder(this.foreground.current!.state.grid)\r\n            .setAlgorithm(algorithm)\r\n            .setHeuristic(settings.heuristicKey)\r\n            .setNavigator(settings.navigatorKey)\r\n            .build();\r\n    }\r\n\r\n    /**\r\n     * Find path with a given pathfinder, includes benchmarking\r\n     * @param pathfinder\r\n     */\r\n    private findPath = (pathfinder: Pathfinder) => {\r\n        const foreground = this.foreground.current!;\r\n        const t0 = performance.now();\r\n        const path = pathfinder.findPath(foreground.state.initial, foreground.state.goal);\r\n        const t1 = performance.now();\r\n        const t2 = (t1 - t0);\r\n        this.setState({\r\n            time: t2,\r\n            nodes: pathfinder.getRecentNodes(),\r\n            length: calcLength(foreground.state.initial, path),\r\n            algorithm: pathfinder.getAlgorithmName()\r\n        });\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Draw path on the grid and change length on ui\r\n     * @param path\r\n     */\r\n    private drawPath = (path: Tile[]) => {\r\n        const foreground = this.foreground.current!\r\n        path.unshift(this.foreground.current!.state.grid.get(foreground.state.initial));\r\n        this.foreground.current!.drawPath(path);\r\n    }\r\n\r\n    /**\r\n     * Called when child foreground moves a tile\r\n     */\r\n    private onTilesDragged = () => {\r\n        if(this.visualized) {\r\n            this.clearVisualization();\r\n            this.doPathfinding();\r\n            this.visualized = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create terrain on the grid foreground\r\n     */\r\n    createTerrain = (mazeType: number) => {\r\n        if(this.visualizing) {\r\n            return;\r\n        }\r\n        this.clearTiles();\r\n        this.clearPath();\r\n        this.clearVisualization();\r\n        const foreground = this.foreground.current!;\r\n        const end = this.calcEndPointInView();\r\n        foreground.setState({\r\n            initial: {\r\n                x: 1, y:1\r\n            },\r\n            goal: {\r\n                x: end.x-2, y: end.y-2\r\n            }\r\n        },() => {\r\n            const prevGrid = foreground.state.grid;\r\n            const generator = new TerrainGeneratorBuilder()\r\n                .setDimensions(\r\n                    prevGrid.getWidth(),\r\n                    prevGrid.getHeight()\r\n                )\r\n                .setGeneratorType(mazeType)\r\n                .setIgnorePoints([foreground.state.initial, foreground.state.goal])\r\n                .build();\r\n            const topLeft = {\r\n                x: 1, y: 1\r\n            };\r\n            const bottomRight = {\r\n                x: end.x-2, y: end.y-2\r\n            };\r\n            const grid = generator.generateTerrain(topLeft, bottomRight);\r\n            foreground.drawGrid(grid);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Calculate the end/goal point in view of the screen\r\n     */\r\n    calcEndPointInView = () => {\r\n        const xEnd = window.innerWidth / this.props.tileWidth;\r\n        const yEnd = (window.innerHeight - this.props.topMargin\r\n            - this.stats.current!.getHeight()) / this.props.tileWidth;\r\n        const xFloor = Math.floor(xEnd);\r\n        const yFloor = Math.floor(yEnd);\r\n        const xDecimal = xEnd - xFloor;\r\n        const yDecimal = yEnd - yFloor;\r\n        return {\r\n            x: xDecimal > 0.05 ? Math.ceil(xEnd) : xFloor,\r\n            y: yDecimal > 0.05 ? Math.ceil(yEnd) : yFloor\r\n        }\r\n    }\r\n\r\n    resetPoints = () => {\r\n        if(!this.visualizing) {\r\n            this.foreground.current!.resetPoints();\r\n        }\r\n    }\r\n\r\n    clearPath = () => {\r\n        this.foreground.current!.erasePath();\r\n    }\r\n\r\n    clearTiles = () => {\r\n        this.foreground.current!.clearTiles();\r\n    }\r\n\r\n    clearTilesChecked = () => {\r\n        if(!this.visualizing) {\r\n            this.foreground.current!.clearTiles();\r\n        }\r\n    }\r\n\r\n    clearVisualization = () => {\r\n        this.visualized = false;\r\n        this.background.current!.clear();\r\n    }\r\n\r\n    clearVisualizationChecked = () => {\r\n        if(!this.visualizing) {\r\n            this.visualized = false;\r\n            this.background.current!.clear();\r\n        }\r\n    }\r\n\r\n    private visualizeGenerations = (generations: Node[]) => {\r\n        this.background.current!.visualizeGenerations(generations);\r\n        this.visualized = true;\r\n    }\r\n\r\n    private visualizeGeneration = (generation: Node) => {\r\n        this.background.current!.visualizeGeneration(generation);\r\n    }\r\n\r\n    private addArrowGenerations = (generations: Node[]) => {\r\n        this.background.current!.addArrowGenerations(generations);\r\n    }\r\n\r\n    private addArrowGeneration = (generation: Node) => {\r\n        this.background.current!.addArrowGeneration(generation);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <StatsPanel ref={this.stats} algorithm={this.state.algorithm} length={this.state.length}\r\n                            time={this.state.time} nodes={this.state.nodes}/>\r\n                <GridBackground ref={this.background} tileWidth={this.props.tileWidth}\r\n                                tilesX={this.state.tilesX} tilesY={this.state.tilesY}/>\r\n                <GridForeground ref={this.foreground} topMargin={this.props.topMargin}\r\n                                onTilesDragged={this.onTilesDragged} tileWidth={this.props.tileWidth}\r\n                                tilesX={this.state.tilesX} tilesY={this.state.tilesY}/>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction calcLength(initial: Point, path: Tile[]) {\r\n    if(path.length === 0) {\r\n        return 0;\r\n    }\r\n    let len = euclidean(initial, path[0].point);\r\n    for (let i = 0; i < path.length - 1; i++) {\r\n        len += euclidean(path[i].point, path[i + 1].point);\r\n    }\r\n    return +(len).toFixed(3);\r\n}\r\n\r\nexport default PathfindingVisualizer;","import React from 'react';\r\n\r\ninterface IProps {\r\n    boxStyle: string,\r\n    defaultChecked: boolean,\r\n    disabled?: boolean,\r\n    onChange: (checked: boolean) => void\r\n}\r\n\r\ninterface IState {\r\n    checked: boolean\r\n}\r\n\r\nclass Checkbox extends React.Component<IProps,IState>\r\n{\r\n    public static defaultProps = {\r\n        disabled: false\r\n    };\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.state = {\r\n            checked: this.props.defaultChecked\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger callback and change checkbox state\r\n     */\r\n    onChange = () => {\r\n        this.setState(prevState => ({\r\n            checked: !prevState.checked\r\n        }), () => this.props.onChange(this.state.checked));\r\n    }\r\n\r\n    render() {\r\n        return(\r\n            <div>\r\n                <input checked={this.state.checked} type='checkbox' disabled={this.props.disabled}\r\n                       className={this.props.boxStyle} onKeyPress={this.onChange} onChange={this.onChange}\r\n                >\r\n                </input>\r\n                {this.props.children}\r\n            </div>\r\n        );\r\n    };\r\n}\r\n\r\nexport default Checkbox;","import React from 'react';\r\n\r\ninterface IProps {\r\n    min: number,\r\n    max: number,\r\n    default: number,\r\n    step: number,\r\n    sliderStyle: string,\r\n    onChange: (val: number) => void\r\n}\r\n\r\ninterface IState {\r\n    value: number\r\n}\r\n\r\nclass SteppedRangeSlider extends React.Component<IProps, IState>\r\n{\r\n    private mouseUp = true;\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.state = {\r\n            value: this.props.default\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger callback when slider value is changed\r\n     * @param e\r\n     */\r\n    onChange = (e: React.FormEvent<HTMLInputElement>) => {\r\n        if(!this.mouseUp) { //to prevent firefox from resetting on release\r\n            const val = Number(e.currentTarget.value);\r\n            this.setState({\r\n                value: val\r\n            }, () => this.props.onChange(val));\r\n        }\r\n    }\r\n\r\n    onMouseUp = () => {\r\n        this.mouseUp = true;\r\n    }\r\n\r\n    onMouseDown = () => {\r\n        this.mouseUp = false;\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <input type='range' list='step-list'\r\n                   value={this.state.value}\r\n                   min={this.props.min} max={this.props.max}\r\n                   step={this.props.step} className={this.props.sliderStyle}\r\n                   onInput={this.onChange}\r\n                   onMouseUp={this.onMouseUp}\r\n                   onMouseDown={this.onMouseDown}\r\n            >\r\n            </input>\r\n        );\r\n    }\r\n}\r\n\r\nexport default SteppedRangeSlider;","import React from 'react';\r\n\r\ninterface IProps {\r\n    boxStyle: string,\r\n    defaultChecked: number,\r\n    disabled: boolean,\r\n    onChange: (() => void)[]\r\n}\r\n\r\ninterface IState {\r\n    checked: boolean[];\r\n}\r\n\r\nclass RadioButtonGroup extends React.Component<IProps, IState>\r\n{\r\n    public static defaultProps = {\r\n        disabled: false\r\n    };\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        const checked: boolean[] = [];\r\n        for(let i = 0; i < this.props.onChange.length; i++) {\r\n            checked.push(i === this.props.defaultChecked);\r\n        }\r\n        this.state = {\r\n            checked: checked\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set all radio buttons to checked aside from the index\r\n     * of the one that was changed\r\n     * Trigger callback\r\n     * @param index\r\n     */\r\n    private onChange = (index: number) => {\r\n        const checked: boolean[] = [];\r\n        for(let i = 0; i < this.props.onChange.length; i++) {\r\n            checked.push(i === index);\r\n        }\r\n        this.setState({\r\n            checked: checked\r\n        }, () => this.props.onChange[index]());\r\n    }\r\n\r\n    render() {\r\n        const children = React.Children.toArray(this.props.children);\r\n        const radioButtons: JSX.Element[] = [];\r\n        for(let i = 0; i < this.props.onChange.length; i++) {\r\n            radioButtons.push(\r\n                <div key={i}>\r\n                    <input checked={this.state.checked[i]} type='radio' disabled={this.props.disabled}\r\n                           className={this.props.boxStyle}\r\n                           onChange={() => this.onChange(i)}\r\n                    >\r\n                    </input>\r\n                    {children[i]}\r\n                </div>\r\n            );\r\n        }\r\n        return radioButtons;\r\n    };\r\n}\r\n\r\nexport default RadioButtonGroup;","import React from 'react';\r\nimport Checkbox from '../utility/Checkbox';\r\nimport SteppedRangeSlider from '../utility/SteppedRangeSlider';\r\nimport RadioButtonGroup from '../utility/RadioButtonGroup';\r\n\r\ninterface VisualProps {\r\n    onChangeViz: () => void,\r\n    onChangeShowArrows: () => void,\r\n    disabled: boolean\r\n}\r\n\r\ninterface SpeedProps {\r\n    onChange: (value: number) => void\r\n}\r\n\r\ninterface SpeedState {\r\n    speedText: string\r\n}\r\n\r\ninterface AlgorithmProps {\r\n    onChangeDiagonals: (checked: boolean) => void,\r\n    onChangeBidirectional: (checked: boolean) => void\r\n    disabled: boolean\r\n}\r\n\r\ninterface HeuristicProps {\r\n    onClickManhattan: () => void,\r\n    onClickEuclidean: () => void,\r\n    onClickChebyshev: () => void,\r\n    onClickOctile: () => void,\r\n    disabled: boolean\r\n}\r\n\r\nconst SPEED_STEP = 2;\r\nconst SPEED_INITIAL = 2;\r\nconst MAX = 19;\r\n\r\nexport class VisualSettings extends React.Component<VisualProps>\r\n{\r\n    render() {\r\n        return (\r\n            <div>\r\n                <div className='draggable-content-title'>Visualization</div>\r\n                <Checkbox defaultChecked={true} boxStyle='box'\r\n                          onChange={this.props.onChangeViz}>\r\n                    Show Frontier\r\n                </Checkbox>\r\n                <Checkbox defaultChecked={true} boxStyle='box'\r\n                          onChange={this.props.onChangeShowArrows}\r\n                          disabled={this.props.disabled}>\r\n                    Show Tree\r\n                </Checkbox>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class SpeedSettings extends React.Component<SpeedProps, SpeedState>\r\n{\r\n    constructor(props: SpeedProps) {\r\n        super(props);\r\n        this.state = {\r\n            speedText: String(SPEED_INITIAL + SPEED_STEP * 2)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback function to be called when slider is changed\r\n     * Call another callback and change text\r\n     * @param value\r\n     */\r\n    onChangeSpeed = (value: number) => {\r\n        const speed = SPEED_INITIAL + SPEED_STEP * value;\r\n        this.setState({\r\n            speedText: String(speed)\r\n        })\r\n        this.props.onChange(speed);\r\n    }\r\n\r\n    render() {\r\n        const options: JSX.Element[] = [];\r\n        for(let i = 1; i <= MAX; i++) {\r\n            options.push(<option key={'option ' + i}>{i}</option>);\r\n        }\r\n        return (\r\n            <div className='slider-container'>\r\n                <div className='slider-text'>\r\n                    Speed: <div className='speed-text'> {this.state.speedText} </div>\r\n                </div>\r\n                    <SteppedRangeSlider min={1} max={MAX} step={1} default={2}\r\n                                    sliderStyle='slider speed-slider'\r\n                                    onChange={this.onChangeSpeed}\r\n                />\r\n                <datalist id='step-list'>\r\n                    {options}\r\n                </datalist>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class AlgorithmSettings extends React.Component<AlgorithmProps>\r\n{\r\n    constructor(props: AlgorithmProps) {\r\n        super(props);\r\n        this.state = {\r\n            disabled: false\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <div className='draggable-content-title'>Algorithm</div>\r\n                <Checkbox defaultChecked={true} boxStyle='box'\r\n                          onChange={this.props.onChangeDiagonals}>\r\n                    Allow Diagonals\r\n                </Checkbox>\r\n                <Checkbox defaultChecked={false} boxStyle='box'\r\n                          disabled={this.props.disabled}\r\n                          onChange={this.props.onChangeBidirectional}>\r\n                    Bidirectional\r\n                </Checkbox>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class HeuristicSettings extends React.Component<HeuristicProps>\r\n{\r\n    constructor(props: HeuristicProps) {\r\n        super(props);\r\n        this.state = {\r\n            disabled: false\r\n        }\r\n    }\r\n\r\n    disable = () => {\r\n        this.setState({\r\n            disabled: true\r\n        })\r\n    }\r\n\r\n    enable = () => {\r\n        this.setState({\r\n            disabled: false\r\n        })\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <div className='draggable-content-title'>Heuristic</div>\r\n                <RadioButtonGroup boxStyle='box'\r\n                                  defaultChecked={1}\r\n                                  disabled={this.props.disabled}\r\n                                  onChange={[\r\n                                      this.props.onClickManhattan, this.props.onClickEuclidean,\r\n                                      this.props.onClickChebyshev, this.props.onClickOctile\r\n                                  ]}\r\n                >\r\n                    {[<span key='Manhattan'>Manhattan</span>, <span key='Euclidean'>Euclidean</span>,\r\n                        <span key='Chebyshev'>Chebyshev</span>, <span key='Octile<'>Octile</span>]}\r\n                </RadioButtonGroup>\r\n            </div>\r\n        )\r\n    }\r\n}","import PathfindingSettings, {getDefaultSettings} from './PathfindingSettings';\r\n\r\nclass SettingsManager\r\n{\r\n    settings: PathfindingSettings = getDefaultSettings();\r\n\r\n    changeAlgo = (algo: string) => {\r\n        this.settings.algorithm = algo;\r\n    }\r\n\r\n    changeVisualize = () => {\r\n        this.settings.visualizeAlg = !this.settings.visualizeAlg;\r\n    }\r\n\r\n    changeShowArrows = () => {\r\n        this.settings.showArrows = !this.settings.showArrows;\r\n    }\r\n\r\n    changeBidirectional = () => {\r\n        this.settings.bidirectional = !this.settings.bidirectional;\r\n    }\r\n\r\n    changeDiagonals = (checked: boolean) => {\r\n        this.settings.navigatorKey = checked ? 'asterisk' : 'plus';\r\n    }\r\n\r\n    changeSpeed = (value: number) => {\r\n        this.settings.delayInc = value;\r\n    }\r\n\r\n    changeManhattan = () => {\r\n        this.settings.heuristicKey = 'manhattan';\r\n    }\r\n\r\n    changeEuclidean = () => {\r\n        this.settings.heuristicKey = 'euclidean';\r\n    }\r\n\r\n    changeChebyshev = () => {\r\n        this.settings.heuristicKey = 'chebyshev';\r\n    }\r\n\r\n    changeOctile = () => {\r\n        this.settings.heuristicKey = 'octile';\r\n    }\r\n}\r\n\r\nexport default SettingsManager;","interface PathfindingSettings\r\n{\r\n    visualizeAlg: boolean,\r\n    showArrows: boolean,\r\n    delayInc: number,\r\n    algorithm: string,\r\n    heuristicKey: string,\r\n    navigatorKey: string,\r\n    bidirectional: boolean\r\n}\r\n\r\nexport function getDefaultSettings(): PathfindingSettings {\r\n    return {\r\n        visualizeAlg: true,\r\n        showArrows: true,\r\n        delayInc: 6,\r\n        algorithm: 'a*',\r\n        heuristicKey: 'euclidean',\r\n        navigatorKey: 'asterisk',\r\n        bidirectional: false\r\n    }\r\n}\r\n\r\nexport default PathfindingSettings;","import React, {RefObject} from 'react';\r\nimport '../App.css';\r\nimport TopBar from './navbar/TopBar';\r\nimport {VisualizeButton, SettingsButton} from './navbar/Buttons';\r\nimport {AlgorithmDropDown, ClearDropDown, MazeDropDown} from './navbar/DropDown';\r\nimport DraggablePanel from './utility/DraggablePanel';\r\nimport PathfindingVisualizer from './grid/PathfindingVisualizer';\r\nimport {VisualSettings, SpeedSettings, AlgorithmSettings, HeuristicSettings} from './navbar/SettingPanels';\r\nimport SettingsManager from './SettingsManager';\r\nimport PathfinderBuilder from '../pathfinding/algorithms/PathfinderBuilder';\r\nimport {MAZE, MAZE_HORIZONTAL_SKEW, MAZE_VERTICAL_SKEW, RANDOM_TERRAIN} from '../pathfinding/algorithms/TerrainGeneratorBuilder';\r\n\r\ninterface IProps {}\r\n\r\ninterface IState {\r\n    heuristicDisabled: boolean,\r\n    bidirectionalDisabled: boolean,\r\n    arrowsDisabled: boolean,\r\n\r\n    panelShow: boolean,\r\n\r\n    topMargin: number,\r\n\r\n    visualizing: boolean,\r\n    paused: boolean\r\n}\r\n\r\nclass PathfindingApp extends React.Component<IProps, IState>\r\n{\r\n    //expose grid to parent to connect to button siblings\r\n    private grid: RefObject<PathfindingVisualizer> = React.createRef();\r\n\r\n    private algDropDown: RefObject<AlgorithmDropDown> = React.createRef();\r\n    private clrDropDown: RefObject<ClearDropDown> = React.createRef();\r\n    private mazeDropDown: RefObject<MazeDropDown> = React.createRef();\r\n\r\n    private settingsManager: SettingsManager = new SettingsManager();\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.state = {\r\n            heuristicDisabled: false,\r\n            bidirectionalDisabled: false,\r\n            arrowsDisabled: false,\r\n            panelShow: false,\r\n            topMargin: 75,\r\n            visualizing: false,\r\n            paused: false\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n        window.addEventListener('click', e => {\r\n            this.algDropDown.current!.hide();\r\n            this.clrDropDown.current!.hide();\r\n            this.mazeDropDown.current!.hide();\r\n        });\r\n    }\r\n\r\n    onClickAlgDrop = () => {\r\n        this.clrDropDown.current!.hide();\r\n        this.mazeDropDown.current!.hide();\r\n    }\r\n\r\n    onClickClrDrop = () => {\r\n        this.algDropDown.current!.hide();\r\n        this.mazeDropDown.current!.hide();\r\n    }\r\n\r\n    onClickMazeDrop = () => {\r\n        this.clrDropDown.current!.hide();\r\n        this.algDropDown.current!.hide();\r\n    }\r\n\r\n    changeVButtonColor = (visualizing: boolean) => {\r\n        this.setState({\r\n            visualizing: visualizing\r\n        })\r\n    }\r\n\r\n    toggleSettings = () => {\r\n        this.setState(prevState => ({\r\n            panelShow: !prevState.panelShow\r\n        }));\r\n    }\r\n\r\n    hideSettings = () => {\r\n        this.setState({\r\n            panelShow: false\r\n        });\r\n    }\r\n\r\n    changeAlgo = (algorithm: string) => {\r\n        this.setState({\r\n            heuristicDisabled: !PathfinderBuilder.usesHeuristic(algorithm),\r\n            bidirectionalDisabled: !PathfinderBuilder.hasBidirectional(algorithm),\r\n            arrowsDisabled: algorithm === 'dfs'\r\n        });\r\n        this.settingsManager.changeAlgo(algorithm);\r\n    }\r\n\r\n    doPathfinding = () => {\r\n        this.setState({\r\n            paused: false\r\n        });\r\n        this.grid.current!.doDelayedPathfinding();\r\n    }\r\n\r\n    pausePathfinding = () => {\r\n        this.setState({\r\n            paused: true\r\n        });\r\n        this.grid.current!.pausePathfinding();\r\n    }\r\n\r\n    resumePathfinding = () => {\r\n        this.setState({\r\n            paused: false\r\n        });\r\n        this.grid.current!.resumePathfinding();\r\n    }\r\n\r\n    clearPath = () => {\r\n        this.grid.current!.clearPath();\r\n        this.grid.current!.clearVisualizationChecked();\r\n    }\r\n\r\n    clearTiles = () => {\r\n        this.clearPath();\r\n        this.grid.current!.clearTilesChecked();\r\n    }\r\n\r\n    resetBoard = () => {\r\n        this.clearPath();\r\n        this.clearTiles();\r\n        this.grid.current!.resetPoints();\r\n    }\r\n\r\n    createMaze = () => {\r\n        this.grid.current!.createTerrain(MAZE);\r\n    }\r\n\r\n    createMazeVSkew = () => {\r\n        this.grid.current!.createTerrain(MAZE_VERTICAL_SKEW);\r\n    }\r\n\r\n    createMazeHSkew = () => {\r\n        this.grid.current!.createTerrain(MAZE_HORIZONTAL_SKEW);\r\n    }\r\n\r\n    createRandomTerrain = () => {\r\n        this.grid.current!.createTerrain(RANDOM_TERRAIN);\r\n    }\r\n\r\n    onChangeHeight = (height: number) => {\r\n        this.setState({\r\n            topMargin: height\r\n        })\r\n    }\r\n\r\n    render() {\r\n        const tileWidth =  isMobile() ? 47 : Math.round(window.screen.availWidth / 57);\r\n        return (\r\n            <div>\r\n                <DraggablePanel title='Grid Settings'\r\n                                show={this.state.panelShow}\r\n                                onClickXButton={this.hideSettings}\r\n                                width={350}\r\n                                height={420}\r\n                >\r\n                    <VisualSettings disabled={this.state.arrowsDisabled}\r\n                                    onChangeViz={this.settingsManager.changeVisualize}\r\n                                    onChangeShowArrows={this.settingsManager.changeShowArrows}\r\n                    />\r\n                    <SpeedSettings onChange={this.settingsManager.changeSpeed}/>\r\n                    <AlgorithmSettings disabled={this.state.bidirectionalDisabled}\r\n                                       onChangeBidirectional={this.settingsManager.changeBidirectional}\r\n                                       onChangeDiagonals={this.settingsManager.changeDiagonals}\r\n                    />\r\n                    <HeuristicSettings disabled={this.state.heuristicDisabled}\r\n                                       onClickManhattan={this.settingsManager.changeManhattan}\r\n                                       onClickEuclidean={this.settingsManager.changeEuclidean}\r\n                                       onClickChebyshev={this.settingsManager.changeChebyshev}\r\n                                       onClickOctile={this.settingsManager.changeOctile}\r\n                    />\r\n                </DraggablePanel>\r\n                <TopBar onChangeHeight={this.onChangeHeight}>\r\n                    <a href='https://github.com/JosephPrichard/PathfinderReact' className='title'>\r\n                        Pathfinding Visualizer\r\n                    </a>\r\n                    <div className='top-container'>\r\n                        <AlgorithmDropDown ref={this.algDropDown}\r\n                                           onClick={this.onClickAlgDrop}\r\n                                           onChange={this.changeAlgo}\r\n                        />\r\n                        <VisualizeButton active={this.state.visualizing}\r\n                                         paused={this.state.paused}\r\n                                         onPause={this.pausePathfinding}\r\n                                         onResume={this.resumePathfinding}\r\n                                         onStartStop={this.doPathfinding}\r\n                        />\r\n                        <ClearDropDown ref={this.clrDropDown}\r\n                                       onClick={this.onClickClrDrop}\r\n                                       onClickTiles={this.clearTiles}\r\n                                       onClickPath={this.clearPath}\r\n                                       onClickReset={this.resetBoard}\r\n                        />\r\n                        <MazeDropDown ref={this.mazeDropDown}\r\n                                      onClick={this.onClickMazeDrop}\r\n                                      onClickMaze={this.createMaze}\r\n                                      onClickMazeHorizontal={this.createMazeHSkew}\r\n                                      onClickMazeVertical={this.createMazeVSkew}\r\n                                      onClickRandomTerrain={this.createRandomTerrain}\r\n                        />\r\n                        <SettingsButton onClick={this.toggleSettings}/>\r\n                    </div>\r\n                </TopBar>\r\n                <PathfindingVisualizer ref={this.grid}\r\n                                       onChangeVisualizing={this.changeVButtonColor}\r\n                                       topMargin={this.state.topMargin}\r\n                                       settings={this.settingsManager.settings}\r\n                                       tileWidth={tileWidth}/>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction isMobile() {\r\n    return /Android|webOS|iPhone|iPad|Mac|Macintosh|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\r\n}\r\n\r\nexport default PathfindingApp;","import React from 'react';\nimport PathfindingApp from './view/PathfindingApp';\n\nclass App extends React.Component\n{\n    render() {\n        return (\n            <PathfindingApp/>\n        );\n    }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n//import reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n    <React.StrictMode>\n        <App/>\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n\n//reportWebVitals();\n"],"sourceRoot":""}